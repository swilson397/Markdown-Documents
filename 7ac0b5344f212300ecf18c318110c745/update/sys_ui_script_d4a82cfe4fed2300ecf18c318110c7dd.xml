<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_ui_script">
    <sys_ui_script action="INSERT_OR_UPDATE">
        <active>true</active>
        <description/>
        <global>false</global>
        <ignore_in_now_experience>false</ignore_in_now_experience>
        <name>x_58056_md_docs.simplemde_min</name>
        <script>/**&#13;
 * simplemde v1.11.2&#13;
 * Copyright Next Step Webs, Inc.&#13;
 * @link https://github.com/NextStepWebs/simplemde-markdown-editor&#13;
 * @license MIT&#13;
 */&#13;
(function(f){if(typeof exports==="object"&amp;&amp;typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.SimpleMDE = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){&#13;
'use strict'&#13;
&#13;
exports.toByteArray = toByteArray&#13;
exports.fromByteArray = fromByteArray&#13;
&#13;
var lookup = []&#13;
var revLookup = []&#13;
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array&#13;
&#13;
function init () {&#13;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'&#13;
  for (var i = 0, len = code.length; i &lt; len; ++i) {&#13;
    lookup[i] = code[i]&#13;
    revLookup[code.charCodeAt(i)] = i&#13;
  }&#13;
&#13;
  revLookup['-'.charCodeAt(0)] = 62&#13;
  revLookup['_'.charCodeAt(0)] = 63&#13;
}&#13;
&#13;
init()&#13;
&#13;
function toByteArray (b64) {&#13;
  var i, j, l, tmp, placeHolders, arr&#13;
  var len = b64.length&#13;
&#13;
  if (len % 4 &gt; 0) {&#13;
    throw new Error('Invalid string. Length must be a multiple of 4')&#13;
  }&#13;
&#13;
  // the number of equal signs (place holders)&#13;
  // if there are two placeholders, than the two characters before it&#13;
  // represent one byte&#13;
  // if there is only one, then the three characters before it represent 2 bytes&#13;
  // this is just a cheap hack to not do indexOf twice&#13;
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0&#13;
&#13;
  // base64 is 4/3 + up to two characters of the original data&#13;
  arr = new Arr(len * 3 / 4 - placeHolders)&#13;
&#13;
  // if there are placeholders, only get up to the last complete 4 chars&#13;
  l = placeHolders &gt; 0 ? len - 4 : len&#13;
&#13;
  var L = 0&#13;
&#13;
  for (i = 0, j = 0; i &lt; l; i += 4, j += 3) {&#13;
    tmp = (revLookup[b64.charCodeAt(i)] &lt;&lt; 18) | (revLookup[b64.charCodeAt(i + 1)] &lt;&lt; 12) | (revLookup[b64.charCodeAt(i + 2)] &lt;&lt; 6) | revLookup[b64.charCodeAt(i + 3)]&#13;
    arr[L++] = (tmp &gt;&gt; 16) &amp; 0xFF&#13;
    arr[L++] = (tmp &gt;&gt; 8) &amp; 0xFF&#13;
    arr[L++] = tmp &amp; 0xFF&#13;
  }&#13;
&#13;
  if (placeHolders === 2) {&#13;
    tmp = (revLookup[b64.charCodeAt(i)] &lt;&lt; 2) | (revLookup[b64.charCodeAt(i + 1)] &gt;&gt; 4)&#13;
    arr[L++] = tmp &amp; 0xFF&#13;
  } else if (placeHolders === 1) {&#13;
    tmp = (revLookup[b64.charCodeAt(i)] &lt;&lt; 10) | (revLookup[b64.charCodeAt(i + 1)] &lt;&lt; 4) | (revLookup[b64.charCodeAt(i + 2)] &gt;&gt; 2)&#13;
    arr[L++] = (tmp &gt;&gt; 8) &amp; 0xFF&#13;
    arr[L++] = tmp &amp; 0xFF&#13;
  }&#13;
&#13;
  return arr&#13;
}&#13;
&#13;
function tripletToBase64 (num) {&#13;
  return lookup[num &gt;&gt; 18 &amp; 0x3F] + lookup[num &gt;&gt; 12 &amp; 0x3F] + lookup[num &gt;&gt; 6 &amp; 0x3F] + lookup[num &amp; 0x3F]&#13;
}&#13;
&#13;
function encodeChunk (uint8, start, end) {&#13;
  var tmp&#13;
  var output = []&#13;
  for (var i = start; i &lt; end; i += 3) {&#13;
    tmp = (uint8[i] &lt;&lt; 16) + (uint8[i + 1] &lt;&lt; 8) + (uint8[i + 2])&#13;
    output.push(tripletToBase64(tmp))&#13;
  }&#13;
  return output.join('')&#13;
}&#13;
&#13;
function fromByteArray (uint8) {&#13;
  var tmp&#13;
  var len = uint8.length&#13;
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes&#13;
  var output = ''&#13;
  var parts = []&#13;
  var maxChunkLength = 16383 // must be multiple of 3&#13;
&#13;
  // go through the array every three bytes, we'll deal with trailing stuff later&#13;
  for (var i = 0, len2 = len - extraBytes; i &lt; len2; i += maxChunkLength) {&#13;
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) &gt; len2 ? len2 : (i + maxChunkLength)))&#13;
  }&#13;
&#13;
  // pad the end with zeros, but make sure to not forget the extra bytes&#13;
  if (extraBytes === 1) {&#13;
    tmp = uint8[len - 1]&#13;
    output += lookup[tmp &gt;&gt; 2]&#13;
    output += lookup[(tmp &lt;&lt; 4) &amp; 0x3F]&#13;
    output += '=='&#13;
  } else if (extraBytes === 2) {&#13;
    tmp = (uint8[len - 2] &lt;&lt; 8) + (uint8[len - 1])&#13;
    output += lookup[tmp &gt;&gt; 10]&#13;
    output += lookup[(tmp &gt;&gt; 4) &amp; 0x3F]&#13;
    output += lookup[(tmp &lt;&lt; 2) &amp; 0x3F]&#13;
    output += '='&#13;
  }&#13;
&#13;
  parts.push(output)&#13;
&#13;
  return parts.join('')&#13;
}&#13;
&#13;
},{}],2:[function(require,module,exports){&#13;
&#13;
},{}],3:[function(require,module,exports){&#13;
(function (global){&#13;
/*!&#13;
 * The buffer module from node.js, for the browser.&#13;
 *&#13;
 * @author   Feross Aboukhadijeh &lt;feross@feross.org&gt; &lt;http://feross.org&gt;&#13;
 * @license  MIT&#13;
 */&#13;
/* eslint-disable no-proto */&#13;
&#13;
'use strict'&#13;
&#13;
var base64 = require('base64-js')&#13;
var ieee754 = require('ieee754')&#13;
var isArray = require('isarray')&#13;
&#13;
exports.Buffer = Buffer&#13;
exports.SlowBuffer = SlowBuffer&#13;
exports.INSPECT_MAX_BYTES = 50&#13;
&#13;
/**&#13;
 * If `Buffer.TYPED_ARRAY_SUPPORT`:&#13;
 *   === true    Use Uint8Array implementation (fastest)&#13;
 *   === false   Use Object implementation (most compatible, even IE6)&#13;
 *&#13;
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,&#13;
 * Opera 11.6+, iOS 4.2+.&#13;
 *&#13;
 * Due to various browser bugs, sometimes the Object implementation will be used even&#13;
 * when the browser supports typed arrays.&#13;
 *&#13;
 * Note:&#13;
 *&#13;
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,&#13;
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.&#13;
 *&#13;
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.&#13;
 *&#13;
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of&#13;
 *     incorrect length in some situations.&#13;
&#13;
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they&#13;
 * get the Object implementation, which is slower but behaves correctly.&#13;
 */&#13;
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined&#13;
  ? global.TYPED_ARRAY_SUPPORT&#13;
  : typedArraySupport()&#13;
&#13;
/*&#13;
 * Export kMaxLength after typed array support is determined.&#13;
 */&#13;
exports.kMaxLength = kMaxLength()&#13;
&#13;
function typedArraySupport () {&#13;
  try {&#13;
    var arr = new Uint8Array(1)&#13;
    arr.foo = function () { return 42 }&#13;
    return arr.foo() === 42 &amp;&amp; // typed array instances can be augmented&#13;
        typeof arr.subarray === 'function' &amp;&amp; // chrome 9-10 lack `subarray`&#13;
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`&#13;
  } catch (e) {&#13;
    return false&#13;
  }&#13;
}&#13;
&#13;
function kMaxLength () {&#13;
  return Buffer.TYPED_ARRAY_SUPPORT&#13;
    ? 0x7fffffff&#13;
    : 0x3fffffff&#13;
}&#13;
&#13;
function createBuffer (that, length) {&#13;
  if (kMaxLength() &lt; length) {&#13;
    throw new RangeError('Invalid typed array length')&#13;
  }&#13;
  if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    // Return an augmented `Uint8Array` instance, for best performance&#13;
    that = new Uint8Array(length)&#13;
    that.__proto__ = Buffer.prototype&#13;
  } else {&#13;
    // Fallback: Return an object instance of the Buffer class&#13;
    if (that === null) {&#13;
      that = new Buffer(length)&#13;
    }&#13;
    that.length = length&#13;
  }&#13;
&#13;
  return that&#13;
}&#13;
&#13;
/**&#13;
 * The Buffer constructor returns instances of `Uint8Array` that have their&#13;
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of&#13;
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods&#13;
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it&#13;
 * returns a single octet.&#13;
 *&#13;
 * The `Uint8Array` prototype remains unmodified.&#13;
 */&#13;
&#13;
function Buffer (arg, encodingOrOffset, length) {&#13;
  if (!Buffer.TYPED_ARRAY_SUPPORT &amp;&amp; !(this instanceof Buffer)) {&#13;
    return new Buffer(arg, encodingOrOffset, length)&#13;
  }&#13;
&#13;
  // Common case.&#13;
  if (typeof arg === 'number') {&#13;
    if (typeof encodingOrOffset === 'string') {&#13;
      throw new Error(&#13;
        'If encoding is specified then the first argument must be a string'&#13;
      )&#13;
    }&#13;
    return allocUnsafe(this, arg)&#13;
  }&#13;
  return from(this, arg, encodingOrOffset, length)&#13;
}&#13;
&#13;
Buffer.poolSize = 8192 // not used by this implementation&#13;
&#13;
// TODO: Legacy, not needed anymore. Remove in next major version.&#13;
Buffer._augment = function (arr) {&#13;
  arr.__proto__ = Buffer.prototype&#13;
  return arr&#13;
}&#13;
&#13;
function from (that, value, encodingOrOffset, length) {&#13;
  if (typeof value === 'number') {&#13;
    throw new TypeError('"value" argument must not be a number')&#13;
  }&#13;
&#13;
  if (typeof ArrayBuffer !== 'undefined' &amp;&amp; value instanceof ArrayBuffer) {&#13;
    return fromArrayBuffer(that, value, encodingOrOffset, length)&#13;
  }&#13;
&#13;
  if (typeof value === 'string') {&#13;
    return fromString(that, value, encodingOrOffset)&#13;
  }&#13;
&#13;
  return fromObject(that, value)&#13;
}&#13;
&#13;
/**&#13;
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError&#13;
 * if value is a number.&#13;
 * Buffer.from(str[, encoding])&#13;
 * Buffer.from(array)&#13;
 * Buffer.from(buffer)&#13;
 * Buffer.from(arrayBuffer[, byteOffset[, length]])&#13;
 **/&#13;
Buffer.from = function (value, encodingOrOffset, length) {&#13;
  return from(null, value, encodingOrOffset, length)&#13;
}&#13;
&#13;
if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
  Buffer.prototype.__proto__ = Uint8Array.prototype&#13;
  Buffer.__proto__ = Uint8Array&#13;
  if (typeof Symbol !== 'undefined' &amp;&amp; Symbol.species &amp;&amp;&#13;
      Buffer[Symbol.species] === Buffer) {&#13;
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97&#13;
    Object.defineProperty(Buffer, Symbol.species, {&#13;
      value: null,&#13;
      configurable: true&#13;
    })&#13;
  }&#13;
}&#13;
&#13;
function assertSize (size) {&#13;
  if (typeof size !== 'number') {&#13;
    throw new TypeError('"size" argument must be a number')&#13;
  }&#13;
}&#13;
&#13;
function alloc (that, size, fill, encoding) {&#13;
  assertSize(size)&#13;
  if (size &lt;= 0) {&#13;
    return createBuffer(that, size)&#13;
  }&#13;
  if (fill !== undefined) {&#13;
    // Only pay attention to encoding if it's a string. This&#13;
    // prevents accidentally sending in a number that would&#13;
    // be interpretted as a start offset.&#13;
    return typeof encoding === 'string'&#13;
      ? createBuffer(that, size).fill(fill, encoding)&#13;
      : createBuffer(that, size).fill(fill)&#13;
  }&#13;
  return createBuffer(that, size)&#13;
}&#13;
&#13;
/**&#13;
 * Creates a new filled Buffer instance.&#13;
 * alloc(size[, fill[, encoding]])&#13;
 **/&#13;
Buffer.alloc = function (size, fill, encoding) {&#13;
  return alloc(null, size, fill, encoding)&#13;
}&#13;
&#13;
function allocUnsafe (that, size) {&#13;
  assertSize(size)&#13;
  that = createBuffer(that, size &lt; 0 ? 0 : checked(size) | 0)&#13;
  if (!Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    for (var i = 0; i &lt; size; i++) {&#13;
      that[i] = 0&#13;
    }&#13;
  }&#13;
  return that&#13;
}&#13;
&#13;
/**&#13;
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.&#13;
 * */&#13;
Buffer.allocUnsafe = function (size) {&#13;
  return allocUnsafe(null, size)&#13;
}&#13;
/**&#13;
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.&#13;
 */&#13;
Buffer.allocUnsafeSlow = function (size) {&#13;
  return allocUnsafe(null, size)&#13;
}&#13;
&#13;
function fromString (that, string, encoding) {&#13;
  if (typeof encoding !== 'string' || encoding === '') {&#13;
    encoding = 'utf8'&#13;
  }&#13;
&#13;
  if (!Buffer.isEncoding(encoding)) {&#13;
    throw new TypeError('"encoding" must be a valid string encoding')&#13;
  }&#13;
&#13;
  var length = byteLength(string, encoding) | 0&#13;
  that = createBuffer(that, length)&#13;
&#13;
  that.write(string, encoding)&#13;
  return that&#13;
}&#13;
&#13;
function fromArrayLike (that, array) {&#13;
  var length = checked(array.length) | 0&#13;
  that = createBuffer(that, length)&#13;
  for (var i = 0; i &lt; length; i += 1) {&#13;
    that[i] = array[i] &amp; 255&#13;
  }&#13;
  return that&#13;
}&#13;
&#13;
function fromArrayBuffer (that, array, byteOffset, length) {&#13;
  array.byteLength // this throws if `array` is not a valid ArrayBuffer&#13;
&#13;
  if (byteOffset &lt; 0 || array.byteLength &lt; byteOffset) {&#13;
    throw new RangeError('\'offset\' is out of bounds')&#13;
  }&#13;
&#13;
  if (array.byteLength &lt; byteOffset + (length || 0)) {&#13;
    throw new RangeError('\'length\' is out of bounds')&#13;
  }&#13;
&#13;
  if (length === undefined) {&#13;
    array = new Uint8Array(array, byteOffset)&#13;
  } else {&#13;
    array = new Uint8Array(array, byteOffset, length)&#13;
  }&#13;
&#13;
  if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    // Return an augmented `Uint8Array` instance, for best performance&#13;
    that = array&#13;
    that.__proto__ = Buffer.prototype&#13;
  } else {&#13;
    // Fallback: Return an object instance of the Buffer class&#13;
    that = fromArrayLike(that, array)&#13;
  }&#13;
  return that&#13;
}&#13;
&#13;
function fromObject (that, obj) {&#13;
  if (Buffer.isBuffer(obj)) {&#13;
    var len = checked(obj.length) | 0&#13;
    that = createBuffer(that, len)&#13;
&#13;
    if (that.length === 0) {&#13;
      return that&#13;
    }&#13;
&#13;
    obj.copy(that, 0, 0, len)&#13;
    return that&#13;
  }&#13;
&#13;
  if (obj) {&#13;
    if ((typeof ArrayBuffer !== 'undefined' &amp;&amp;&#13;
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {&#13;
      if (typeof obj.length !== 'number' || isnan(obj.length)) {&#13;
        return createBuffer(that, 0)&#13;
      }&#13;
      return fromArrayLike(that, obj)&#13;
    }&#13;
&#13;
    if (obj.type === 'Buffer' &amp;&amp; isArray(obj.data)) {&#13;
      return fromArrayLike(that, obj.data)&#13;
    }&#13;
  }&#13;
&#13;
  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')&#13;
}&#13;
&#13;
function checked (length) {&#13;
  // Note: cannot use `length &lt; kMaxLength` here because that fails when&#13;
  // length is NaN (which is otherwise coerced to zero.)&#13;
  if (length &gt;= kMaxLength()) {&#13;
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +&#13;
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')&#13;
  }&#13;
  return length | 0&#13;
}&#13;
&#13;
function SlowBuffer (length) {&#13;
  if (+length != length) { // eslint-disable-line eqeqeq&#13;
    length = 0&#13;
  }&#13;
  return Buffer.alloc(+length)&#13;
}&#13;
&#13;
Buffer.isBuffer = function isBuffer (b) {&#13;
  return !!(b != null &amp;&amp; b._isBuffer)&#13;
}&#13;
&#13;
Buffer.compare = function compare (a, b) {&#13;
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {&#13;
    throw new TypeError('Arguments must be Buffers')&#13;
  }&#13;
&#13;
  if (a === b) return 0&#13;
&#13;
  var x = a.length&#13;
  var y = b.length&#13;
&#13;
  for (var i = 0, len = Math.min(x, y); i &lt; len; ++i) {&#13;
    if (a[i] !== b[i]) {&#13;
      x = a[i]&#13;
      y = b[i]&#13;
      break&#13;
    }&#13;
  }&#13;
&#13;
  if (x &lt; y) return -1&#13;
  if (y &lt; x) return 1&#13;
  return 0&#13;
}&#13;
&#13;
Buffer.isEncoding = function isEncoding (encoding) {&#13;
  switch (String(encoding).toLowerCase()) {&#13;
    case 'hex':&#13;
    case 'utf8':&#13;
    case 'utf-8':&#13;
    case 'ascii':&#13;
    case 'binary':&#13;
    case 'base64':&#13;
    case 'raw':&#13;
    case 'ucs2':&#13;
    case 'ucs-2':&#13;
    case 'utf16le':&#13;
    case 'utf-16le':&#13;
      return true&#13;
    default:&#13;
      return false&#13;
  }&#13;
}&#13;
&#13;
Buffer.concat = function concat (list, length) {&#13;
  if (!isArray(list)) {&#13;
    throw new TypeError('"list" argument must be an Array of Buffers')&#13;
  }&#13;
&#13;
  if (list.length === 0) {&#13;
    return Buffer.alloc(0)&#13;
  }&#13;
&#13;
  var i&#13;
  if (length === undefined) {&#13;
    length = 0&#13;
    for (i = 0; i &lt; list.length; i++) {&#13;
      length += list[i].length&#13;
    }&#13;
  }&#13;
&#13;
  var buffer = Buffer.allocUnsafe(length)&#13;
  var pos = 0&#13;
  for (i = 0; i &lt; list.length; i++) {&#13;
    var buf = list[i]&#13;
    if (!Buffer.isBuffer(buf)) {&#13;
      throw new TypeError('"list" argument must be an Array of Buffers')&#13;
    }&#13;
    buf.copy(buffer, pos)&#13;
    pos += buf.length&#13;
  }&#13;
  return buffer&#13;
}&#13;
&#13;
function byteLength (string, encoding) {&#13;
  if (Buffer.isBuffer(string)) {&#13;
    return string.length&#13;
  }&#13;
  if (typeof ArrayBuffer !== 'undefined' &amp;&amp; typeof ArrayBuffer.isView === 'function' &amp;&amp;&#13;
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {&#13;
    return string.byteLength&#13;
  }&#13;
  if (typeof string !== 'string') {&#13;
    string = '' + string&#13;
  }&#13;
&#13;
  var len = string.length&#13;
  if (len === 0) return 0&#13;
&#13;
  // Use a for loop to avoid recursion&#13;
  var loweredCase = false&#13;
  for (;;) {&#13;
    switch (encoding) {&#13;
      case 'ascii':&#13;
      case 'binary':&#13;
      // Deprecated&#13;
      case 'raw':&#13;
      case 'raws':&#13;
        return len&#13;
      case 'utf8':&#13;
      case 'utf-8':&#13;
      case undefined:&#13;
        return utf8ToBytes(string).length&#13;
      case 'ucs2':&#13;
      case 'ucs-2':&#13;
      case 'utf16le':&#13;
      case 'utf-16le':&#13;
        return len * 2&#13;
      case 'hex':&#13;
        return len &gt;&gt;&gt; 1&#13;
      case 'base64':&#13;
        return base64ToBytes(string).length&#13;
      default:&#13;
        if (loweredCase) return utf8ToBytes(string).length // assume utf8&#13;
        encoding = ('' + encoding).toLowerCase()&#13;
        loweredCase = true&#13;
    }&#13;
  }&#13;
}&#13;
Buffer.byteLength = byteLength&#13;
&#13;
function slowToString (encoding, start, end) {&#13;
  var loweredCase = false&#13;
&#13;
  // No need to verify that "this.length &lt;= MAX_UINT32" since it's a read-only&#13;
  // property of a typed array.&#13;
&#13;
  // This behaves neither like String nor Uint8Array in that we set start/end&#13;
  // to their upper/lower bounds if the value passed is out of range.&#13;
  // undefined is handled specially as per ECMA-262 6th Edition,&#13;
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.&#13;
  if (start === undefined || start &lt; 0) {&#13;
    start = 0&#13;
  }&#13;
  // Return early if start &gt; this.length. Done here to prevent potential uint32&#13;
  // coercion fail below.&#13;
  if (start &gt; this.length) {&#13;
    return ''&#13;
  }&#13;
&#13;
  if (end === undefined || end &gt; this.length) {&#13;
    end = this.length&#13;
  }&#13;
&#13;
  if (end &lt;= 0) {&#13;
    return ''&#13;
  }&#13;
&#13;
  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.&#13;
  end &gt;&gt;&gt;= 0&#13;
  start &gt;&gt;&gt;= 0&#13;
&#13;
  if (end &lt;= start) {&#13;
    return ''&#13;
  }&#13;
&#13;
  if (!encoding) encoding = 'utf8'&#13;
&#13;
  while (true) {&#13;
    switch (encoding) {&#13;
      case 'hex':&#13;
        return hexSlice(this, start, end)&#13;
&#13;
      case 'utf8':&#13;
      case 'utf-8':&#13;
        return utf8Slice(this, start, end)&#13;
&#13;
      case 'ascii':&#13;
        return asciiSlice(this, start, end)&#13;
&#13;
      case 'binary':&#13;
        return binarySlice(this, start, end)&#13;
&#13;
      case 'base64':&#13;
        return base64Slice(this, start, end)&#13;
&#13;
      case 'ucs2':&#13;
      case 'ucs-2':&#13;
      case 'utf16le':&#13;
      case 'utf-16le':&#13;
        return utf16leSlice(this, start, end)&#13;
&#13;
      default:&#13;
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)&#13;
        encoding = (encoding + '').toLowerCase()&#13;
        loweredCase = true&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect&#13;
// Buffer instances.&#13;
Buffer.prototype._isBuffer = true&#13;
&#13;
function swap (b, n, m) {&#13;
  var i = b[n]&#13;
  b[n] = b[m]&#13;
  b[m] = i&#13;
}&#13;
&#13;
Buffer.prototype.swap16 = function swap16 () {&#13;
  var len = this.length&#13;
  if (len % 2 !== 0) {&#13;
    throw new RangeError('Buffer size must be a multiple of 16-bits')&#13;
  }&#13;
  for (var i = 0; i &lt; len; i += 2) {&#13;
    swap(this, i, i + 1)&#13;
  }&#13;
  return this&#13;
}&#13;
&#13;
Buffer.prototype.swap32 = function swap32 () {&#13;
  var len = this.length&#13;
  if (len % 4 !== 0) {&#13;
    throw new RangeError('Buffer size must be a multiple of 32-bits')&#13;
  }&#13;
  for (var i = 0; i &lt; len; i += 4) {&#13;
    swap(this, i, i + 3)&#13;
    swap(this, i + 1, i + 2)&#13;
  }&#13;
  return this&#13;
}&#13;
&#13;
Buffer.prototype.toString = function toString () {&#13;
  var length = this.length | 0&#13;
  if (length === 0) return ''&#13;
  if (arguments.length === 0) return utf8Slice(this, 0, length)&#13;
  return slowToString.apply(this, arguments)&#13;
}&#13;
&#13;
Buffer.prototype.equals = function equals (b) {&#13;
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')&#13;
  if (this === b) return true&#13;
  return Buffer.compare(this, b) === 0&#13;
}&#13;
&#13;
Buffer.prototype.inspect = function inspect () {&#13;
  var str = ''&#13;
  var max = exports.INSPECT_MAX_BYTES&#13;
  if (this.length &gt; 0) {&#13;
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')&#13;
    if (this.length &gt; max) str += ' ... '&#13;
  }&#13;
  return '&lt;Buffer ' + str + '&gt;'&#13;
}&#13;
&#13;
Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {&#13;
  if (!Buffer.isBuffer(target)) {&#13;
    throw new TypeError('Argument must be a Buffer')&#13;
  }&#13;
&#13;
  if (start === undefined) {&#13;
    start = 0&#13;
  }&#13;
  if (end === undefined) {&#13;
    end = target ? target.length : 0&#13;
  }&#13;
  if (thisStart === undefined) {&#13;
    thisStart = 0&#13;
  }&#13;
  if (thisEnd === undefined) {&#13;
    thisEnd = this.length&#13;
  }&#13;
&#13;
  if (start &lt; 0 || end &gt; target.length || thisStart &lt; 0 || thisEnd &gt; this.length) {&#13;
    throw new RangeError('out of range index')&#13;
  }&#13;
&#13;
  if (thisStart &gt;= thisEnd &amp;&amp; start &gt;= end) {&#13;
    return 0&#13;
  }&#13;
  if (thisStart &gt;= thisEnd) {&#13;
    return -1&#13;
  }&#13;
  if (start &gt;= end) {&#13;
    return 1&#13;
  }&#13;
&#13;
  start &gt;&gt;&gt;= 0&#13;
  end &gt;&gt;&gt;= 0&#13;
  thisStart &gt;&gt;&gt;= 0&#13;
  thisEnd &gt;&gt;&gt;= 0&#13;
&#13;
  if (this === target) return 0&#13;
&#13;
  var x = thisEnd - thisStart&#13;
  var y = end - start&#13;
  var len = Math.min(x, y)&#13;
&#13;
  var thisCopy = this.slice(thisStart, thisEnd)&#13;
  var targetCopy = target.slice(start, end)&#13;
&#13;
  for (var i = 0; i &lt; len; ++i) {&#13;
    if (thisCopy[i] !== targetCopy[i]) {&#13;
      x = thisCopy[i]&#13;
      y = targetCopy[i]&#13;
      break&#13;
    }&#13;
  }&#13;
&#13;
  if (x &lt; y) return -1&#13;
  if (y &lt; x) return 1&#13;
  return 0&#13;
}&#13;
&#13;
function arrayIndexOf (arr, val, byteOffset, encoding) {&#13;
  var indexSize = 1&#13;
  var arrLength = arr.length&#13;
  var valLength = val.length&#13;
&#13;
  if (encoding !== undefined) {&#13;
    encoding = String(encoding).toLowerCase()&#13;
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||&#13;
        encoding === 'utf16le' || encoding === 'utf-16le') {&#13;
      if (arr.length &lt; 2 || val.length &lt; 2) {&#13;
        return -1&#13;
      }&#13;
      indexSize = 2&#13;
      arrLength /= 2&#13;
      valLength /= 2&#13;
      byteOffset /= 2&#13;
    }&#13;
  }&#13;
&#13;
  function read (buf, i) {&#13;
    if (indexSize === 1) {&#13;
      return buf[i]&#13;
    } else {&#13;
      return buf.readUInt16BE(i * indexSize)&#13;
    }&#13;
  }&#13;
&#13;
  var foundIndex = -1&#13;
  for (var i = 0; byteOffset + i &lt; arrLength; i++) {&#13;
    if (read(arr, byteOffset + i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {&#13;
      if (foundIndex === -1) foundIndex = i&#13;
      if (i - foundIndex + 1 === valLength) return (byteOffset + foundIndex) * indexSize&#13;
    } else {&#13;
      if (foundIndex !== -1) i -= i - foundIndex&#13;
      foundIndex = -1&#13;
    }&#13;
  }&#13;
  return -1&#13;
}&#13;
&#13;
Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {&#13;
  if (typeof byteOffset === 'string') {&#13;
    encoding = byteOffset&#13;
    byteOffset = 0&#13;
  } else if (byteOffset &gt; 0x7fffffff) {&#13;
    byteOffset = 0x7fffffff&#13;
  } else if (byteOffset &lt; -0x80000000) {&#13;
    byteOffset = -0x80000000&#13;
  }&#13;
  byteOffset &gt;&gt;= 0&#13;
&#13;
  if (this.length === 0) return -1&#13;
  if (byteOffset &gt;= this.length) return -1&#13;
&#13;
  // Negative offsets start from the end of the buffer&#13;
  if (byteOffset &lt; 0) byteOffset = Math.max(this.length + byteOffset, 0)&#13;
&#13;
  if (typeof val === 'string') {&#13;
    val = Buffer.from(val, encoding)&#13;
  }&#13;
&#13;
  if (Buffer.isBuffer(val)) {&#13;
    // special case: looking for empty string/buffer always fails&#13;
    if (val.length === 0) {&#13;
      return -1&#13;
    }&#13;
    return arrayIndexOf(this, val, byteOffset, encoding)&#13;
  }&#13;
  if (typeof val === 'number') {&#13;
    if (Buffer.TYPED_ARRAY_SUPPORT &amp;&amp; Uint8Array.prototype.indexOf === 'function') {&#13;
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)&#13;
    }&#13;
    return arrayIndexOf(this, [ val ], byteOffset, encoding)&#13;
  }&#13;
&#13;
  throw new TypeError('val must be string, number or Buffer')&#13;
}&#13;
&#13;
Buffer.prototype.includes = function includes (val, byteOffset, encoding) {&#13;
  return this.indexOf(val, byteOffset, encoding) !== -1&#13;
}&#13;
&#13;
function hexWrite (buf, string, offset, length) {&#13;
  offset = Number(offset) || 0&#13;
  var remaining = buf.length - offset&#13;
  if (!length) {&#13;
    length = remaining&#13;
  } else {&#13;
    length = Number(length)&#13;
    if (length &gt; remaining) {&#13;
      length = remaining&#13;
    }&#13;
  }&#13;
&#13;
  // must be an even number of digits&#13;
  var strLen = string.length&#13;
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')&#13;
&#13;
  if (length &gt; strLen / 2) {&#13;
    length = strLen / 2&#13;
  }&#13;
  for (var i = 0; i &lt; length; i++) {&#13;
    var parsed = parseInt(string.substr(i * 2, 2), 16)&#13;
    if (isNaN(parsed)) return i&#13;
    buf[offset + i] = parsed&#13;
  }&#13;
  return i&#13;
}&#13;
&#13;
function utf8Write (buf, string, offset, length) {&#13;
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)&#13;
}&#13;
&#13;
function asciiWrite (buf, string, offset, length) {&#13;
  return blitBuffer(asciiToBytes(string), buf, offset, length)&#13;
}&#13;
&#13;
function binaryWrite (buf, string, offset, length) {&#13;
  return asciiWrite(buf, string, offset, length)&#13;
}&#13;
&#13;
function base64Write (buf, string, offset, length) {&#13;
  return blitBuffer(base64ToBytes(string), buf, offset, length)&#13;
}&#13;
&#13;
function ucs2Write (buf, string, offset, length) {&#13;
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)&#13;
}&#13;
&#13;
Buffer.prototype.write = function write (string, offset, length, encoding) {&#13;
  // Buffer#write(string)&#13;
  if (offset === undefined) {&#13;
    encoding = 'utf8'&#13;
    length = this.length&#13;
    offset = 0&#13;
  // Buffer#write(string, encoding)&#13;
  } else if (length === undefined &amp;&amp; typeof offset === 'string') {&#13;
    encoding = offset&#13;
    length = this.length&#13;
    offset = 0&#13;
  // Buffer#write(string, offset[, length][, encoding])&#13;
  } else if (isFinite(offset)) {&#13;
    offset = offset | 0&#13;
    if (isFinite(length)) {&#13;
      length = length | 0&#13;
      if (encoding === undefined) encoding = 'utf8'&#13;
    } else {&#13;
      encoding = length&#13;
      length = undefined&#13;
    }&#13;
  // legacy write(string, encoding, offset, length) - remove in v0.13&#13;
  } else {&#13;
    throw new Error(&#13;
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'&#13;
    )&#13;
  }&#13;
&#13;
  var remaining = this.length - offset&#13;
  if (length === undefined || length &gt; remaining) length = remaining&#13;
&#13;
  if ((string.length &gt; 0 &amp;&amp; (length &lt; 0 || offset &lt; 0)) || offset &gt; this.length) {&#13;
    throw new RangeError('Attempt to write outside buffer bounds')&#13;
  }&#13;
&#13;
  if (!encoding) encoding = 'utf8'&#13;
&#13;
  var loweredCase = false&#13;
  for (;;) {&#13;
    switch (encoding) {&#13;
      case 'hex':&#13;
        return hexWrite(this, string, offset, length)&#13;
&#13;
      case 'utf8':&#13;
      case 'utf-8':&#13;
        return utf8Write(this, string, offset, length)&#13;
&#13;
      case 'ascii':&#13;
        return asciiWrite(this, string, offset, length)&#13;
&#13;
      case 'binary':&#13;
        return binaryWrite(this, string, offset, length)&#13;
&#13;
      case 'base64':&#13;
        // Warning: maxLength not taken into account in base64Write&#13;
        return base64Write(this, string, offset, length)&#13;
&#13;
      case 'ucs2':&#13;
      case 'ucs-2':&#13;
      case 'utf16le':&#13;
      case 'utf-16le':&#13;
        return ucs2Write(this, string, offset, length)&#13;
&#13;
      default:&#13;
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)&#13;
        encoding = ('' + encoding).toLowerCase()&#13;
        loweredCase = true&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
Buffer.prototype.toJSON = function toJSON () {&#13;
  return {&#13;
    type: 'Buffer',&#13;
    data: Array.prototype.slice.call(this._arr || this, 0)&#13;
  }&#13;
}&#13;
&#13;
function base64Slice (buf, start, end) {&#13;
  if (start === 0 &amp;&amp; end === buf.length) {&#13;
    return base64.fromByteArray(buf)&#13;
  } else {&#13;
    return base64.fromByteArray(buf.slice(start, end))&#13;
  }&#13;
}&#13;
&#13;
function utf8Slice (buf, start, end) {&#13;
  end = Math.min(buf.length, end)&#13;
  var res = []&#13;
&#13;
  var i = start&#13;
  while (i &lt; end) {&#13;
    var firstByte = buf[i]&#13;
    var codePoint = null&#13;
    var bytesPerSequence = (firstByte &gt; 0xEF) ? 4&#13;
      : (firstByte &gt; 0xDF) ? 3&#13;
      : (firstByte &gt; 0xBF) ? 2&#13;
      : 1&#13;
&#13;
    if (i + bytesPerSequence &lt;= end) {&#13;
      var secondByte, thirdByte, fourthByte, tempCodePoint&#13;
&#13;
      switch (bytesPerSequence) {&#13;
        case 1:&#13;
          if (firstByte &lt; 0x80) {&#13;
            codePoint = firstByte&#13;
          }&#13;
          break&#13;
        case 2:&#13;
          secondByte = buf[i + 1]&#13;
          if ((secondByte &amp; 0xC0) === 0x80) {&#13;
            tempCodePoint = (firstByte &amp; 0x1F) &lt;&lt; 0x6 | (secondByte &amp; 0x3F)&#13;
            if (tempCodePoint &gt; 0x7F) {&#13;
              codePoint = tempCodePoint&#13;
            }&#13;
          }&#13;
          break&#13;
        case 3:&#13;
          secondByte = buf[i + 1]&#13;
          thirdByte = buf[i + 2]&#13;
          if ((secondByte &amp; 0xC0) === 0x80 &amp;&amp; (thirdByte &amp; 0xC0) === 0x80) {&#13;
            tempCodePoint = (firstByte &amp; 0xF) &lt;&lt; 0xC | (secondByte &amp; 0x3F) &lt;&lt; 0x6 | (thirdByte &amp; 0x3F)&#13;
            if (tempCodePoint &gt; 0x7FF &amp;&amp; (tempCodePoint &lt; 0xD800 || tempCodePoint &gt; 0xDFFF)) {&#13;
              codePoint = tempCodePoint&#13;
            }&#13;
          }&#13;
          break&#13;
        case 4:&#13;
          secondByte = buf[i + 1]&#13;
          thirdByte = buf[i + 2]&#13;
          fourthByte = buf[i + 3]&#13;
          if ((secondByte &amp; 0xC0) === 0x80 &amp;&amp; (thirdByte &amp; 0xC0) === 0x80 &amp;&amp; (fourthByte &amp; 0xC0) === 0x80) {&#13;
            tempCodePoint = (firstByte &amp; 0xF) &lt;&lt; 0x12 | (secondByte &amp; 0x3F) &lt;&lt; 0xC | (thirdByte &amp; 0x3F) &lt;&lt; 0x6 | (fourthByte &amp; 0x3F)&#13;
            if (tempCodePoint &gt; 0xFFFF &amp;&amp; tempCodePoint &lt; 0x110000) {&#13;
              codePoint = tempCodePoint&#13;
            }&#13;
          }&#13;
      }&#13;
    }&#13;
&#13;
    if (codePoint === null) {&#13;
      // we did not generate a valid codePoint so insert a&#13;
      // replacement char (U+FFFD) and advance only 1 byte&#13;
      codePoint = 0xFFFD&#13;
      bytesPerSequence = 1&#13;
    } else if (codePoint &gt; 0xFFFF) {&#13;
      // encode to utf16 (surrogate pair dance)&#13;
      codePoint -= 0x10000&#13;
      res.push(codePoint &gt;&gt;&gt; 10 &amp; 0x3FF | 0xD800)&#13;
      codePoint = 0xDC00 | codePoint &amp; 0x3FF&#13;
    }&#13;
&#13;
    res.push(codePoint)&#13;
    i += bytesPerSequence&#13;
  }&#13;
&#13;
  return decodeCodePointsArray(res)&#13;
}&#13;
&#13;
// Based on http://stackoverflow.com/a/22747272/680742, the browser with&#13;
// the lowest limit is Chrome, with 0x10000 args.&#13;
// We go 1 magnitude less, for safety&#13;
var MAX_ARGUMENTS_LENGTH = 0x1000&#13;
&#13;
function decodeCodePointsArray (codePoints) {&#13;
  var len = codePoints.length&#13;
  if (len &lt;= MAX_ARGUMENTS_LENGTH) {&#13;
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()&#13;
  }&#13;
&#13;
  // Decode in chunks to avoid "call stack size exceeded".&#13;
  var res = ''&#13;
  var i = 0&#13;
  while (i &lt; len) {&#13;
    res += String.fromCharCode.apply(&#13;
      String,&#13;
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)&#13;
    )&#13;
  }&#13;
  return res&#13;
}&#13;
&#13;
function asciiSlice (buf, start, end) {&#13;
  var ret = ''&#13;
  end = Math.min(buf.length, end)&#13;
&#13;
  for (var i = start; i &lt; end; i++) {&#13;
    ret += String.fromCharCode(buf[i] &amp; 0x7F)&#13;
  }&#13;
  return ret&#13;
}&#13;
&#13;
function binarySlice (buf, start, end) {&#13;
  var ret = ''&#13;
  end = Math.min(buf.length, end)&#13;
&#13;
  for (var i = start; i &lt; end; i++) {&#13;
    ret += String.fromCharCode(buf[i])&#13;
  }&#13;
  return ret&#13;
}&#13;
&#13;
function hexSlice (buf, start, end) {&#13;
  var len = buf.length&#13;
&#13;
  if (!start || start &lt; 0) start = 0&#13;
  if (!end || end &lt; 0 || end &gt; len) end = len&#13;
&#13;
  var out = ''&#13;
  for (var i = start; i &lt; end; i++) {&#13;
    out += toHex(buf[i])&#13;
  }&#13;
  return out&#13;
}&#13;
&#13;
function utf16leSlice (buf, start, end) {&#13;
  var bytes = buf.slice(start, end)&#13;
  var res = ''&#13;
  for (var i = 0; i &lt; bytes.length; i += 2) {&#13;
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)&#13;
  }&#13;
  return res&#13;
}&#13;
&#13;
Buffer.prototype.slice = function slice (start, end) {&#13;
  var len = this.length&#13;
  start = ~~start&#13;
  end = end === undefined ? len : ~~end&#13;
&#13;
  if (start &lt; 0) {&#13;
    start += len&#13;
    if (start &lt; 0) start = 0&#13;
  } else if (start &gt; len) {&#13;
    start = len&#13;
  }&#13;
&#13;
  if (end &lt; 0) {&#13;
    end += len&#13;
    if (end &lt; 0) end = 0&#13;
  } else if (end &gt; len) {&#13;
    end = len&#13;
  }&#13;
&#13;
  if (end &lt; start) end = start&#13;
&#13;
  var newBuf&#13;
  if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    newBuf = this.subarray(start, end)&#13;
    newBuf.__proto__ = Buffer.prototype&#13;
  } else {&#13;
    var sliceLen = end - start&#13;
    newBuf = new Buffer(sliceLen, undefined)&#13;
    for (var i = 0; i &lt; sliceLen; i++) {&#13;
      newBuf[i] = this[i + start]&#13;
    }&#13;
  }&#13;
&#13;
  return newBuf&#13;
}&#13;
&#13;
/*&#13;
 * Need to make sure that buffer isn't trying to write out of bounds.&#13;
 */&#13;
function checkOffset (offset, ext, length) {&#13;
  if ((offset % 1) !== 0 || offset &lt; 0) throw new RangeError('offset is not uint')&#13;
  if (offset + ext &gt; length) throw new RangeError('Trying to access beyond buffer length')&#13;
}&#13;
&#13;
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {&#13;
  offset = offset | 0&#13;
  byteLength = byteLength | 0&#13;
  if (!noAssert) checkOffset(offset, byteLength, this.length)&#13;
&#13;
  var val = this[offset]&#13;
  var mul = 1&#13;
  var i = 0&#13;
  while (++i &lt; byteLength &amp;&amp; (mul *= 0x100)) {&#13;
    val += this[offset + i] * mul&#13;
  }&#13;
&#13;
  return val&#13;
}&#13;
&#13;
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {&#13;
  offset = offset | 0&#13;
  byteLength = byteLength | 0&#13;
  if (!noAssert) {&#13;
    checkOffset(offset, byteLength, this.length)&#13;
  }&#13;
&#13;
  var val = this[offset + --byteLength]&#13;
  var mul = 1&#13;
  while (byteLength &gt; 0 &amp;&amp; (mul *= 0x100)) {&#13;
    val += this[offset + --byteLength] * mul&#13;
  }&#13;
&#13;
  return val&#13;
}&#13;
&#13;
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 1, this.length)&#13;
  return this[offset]&#13;
}&#13;
&#13;
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 2, this.length)&#13;
  return this[offset] | (this[offset + 1] &lt;&lt; 8)&#13;
}&#13;
&#13;
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 2, this.length)&#13;
  return (this[offset] &lt;&lt; 8) | this[offset + 1]&#13;
}&#13;
&#13;
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 4, this.length)&#13;
&#13;
  return ((this[offset]) |&#13;
      (this[offset + 1] &lt;&lt; 8) |&#13;
      (this[offset + 2] &lt;&lt; 16)) +&#13;
      (this[offset + 3] * 0x1000000)&#13;
}&#13;
&#13;
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 4, this.length)&#13;
&#13;
  return (this[offset] * 0x1000000) +&#13;
    ((this[offset + 1] &lt;&lt; 16) |&#13;
    (this[offset + 2] &lt;&lt; 8) |&#13;
    this[offset + 3])&#13;
}&#13;
&#13;
Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {&#13;
  offset = offset | 0&#13;
  byteLength = byteLength | 0&#13;
  if (!noAssert) checkOffset(offset, byteLength, this.length)&#13;
&#13;
  var val = this[offset]&#13;
  var mul = 1&#13;
  var i = 0&#13;
  while (++i &lt; byteLength &amp;&amp; (mul *= 0x100)) {&#13;
    val += this[offset + i] * mul&#13;
  }&#13;
  mul *= 0x80&#13;
&#13;
  if (val &gt;= mul) val -= Math.pow(2, 8 * byteLength)&#13;
&#13;
  return val&#13;
}&#13;
&#13;
Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {&#13;
  offset = offset | 0&#13;
  byteLength = byteLength | 0&#13;
  if (!noAssert) checkOffset(offset, byteLength, this.length)&#13;
&#13;
  var i = byteLength&#13;
  var mul = 1&#13;
  var val = this[offset + --i]&#13;
  while (i &gt; 0 &amp;&amp; (mul *= 0x100)) {&#13;
    val += this[offset + --i] * mul&#13;
  }&#13;
  mul *= 0x80&#13;
&#13;
  if (val &gt;= mul) val -= Math.pow(2, 8 * byteLength)&#13;
&#13;
  return val&#13;
}&#13;
&#13;
Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 1, this.length)&#13;
  if (!(this[offset] &amp; 0x80)) return (this[offset])&#13;
  return ((0xff - this[offset] + 1) * -1)&#13;
}&#13;
&#13;
Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 2, this.length)&#13;
  var val = this[offset] | (this[offset + 1] &lt;&lt; 8)&#13;
  return (val &amp; 0x8000) ? val | 0xFFFF0000 : val&#13;
}&#13;
&#13;
Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 2, this.length)&#13;
  var val = this[offset + 1] | (this[offset] &lt;&lt; 8)&#13;
  return (val &amp; 0x8000) ? val | 0xFFFF0000 : val&#13;
}&#13;
&#13;
Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 4, this.length)&#13;
&#13;
  return (this[offset]) |&#13;
    (this[offset + 1] &lt;&lt; 8) |&#13;
    (this[offset + 2] &lt;&lt; 16) |&#13;
    (this[offset + 3] &lt;&lt; 24)&#13;
}&#13;
&#13;
Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 4, this.length)&#13;
&#13;
  return (this[offset] &lt;&lt; 24) |&#13;
    (this[offset + 1] &lt;&lt; 16) |&#13;
    (this[offset + 2] &lt;&lt; 8) |&#13;
    (this[offset + 3])&#13;
}&#13;
&#13;
Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 4, this.length)&#13;
  return ieee754.read(this, offset, true, 23, 4)&#13;
}&#13;
&#13;
Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 4, this.length)&#13;
  return ieee754.read(this, offset, false, 23, 4)&#13;
}&#13;
&#13;
Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 8, this.length)&#13;
  return ieee754.read(this, offset, true, 52, 8)&#13;
}&#13;
&#13;
Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {&#13;
  if (!noAssert) checkOffset(offset, 8, this.length)&#13;
  return ieee754.read(this, offset, false, 52, 8)&#13;
}&#13;
&#13;
function checkInt (buf, value, offset, ext, max, min) {&#13;
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')&#13;
  if (value &gt; max || value &lt; min) throw new RangeError('"value" argument is out of bounds')&#13;
  if (offset + ext &gt; buf.length) throw new RangeError('Index out of range')&#13;
}&#13;
&#13;
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  byteLength = byteLength | 0&#13;
  if (!noAssert) {&#13;
    var maxBytes = Math.pow(2, 8 * byteLength) - 1&#13;
    checkInt(this, value, offset, byteLength, maxBytes, 0)&#13;
  }&#13;
&#13;
  var mul = 1&#13;
  var i = 0&#13;
  this[offset] = value &amp; 0xFF&#13;
  while (++i &lt; byteLength &amp;&amp; (mul *= 0x100)) {&#13;
    this[offset + i] = (value / mul) &amp; 0xFF&#13;
  }&#13;
&#13;
  return offset + byteLength&#13;
}&#13;
&#13;
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  byteLength = byteLength | 0&#13;
  if (!noAssert) {&#13;
    var maxBytes = Math.pow(2, 8 * byteLength) - 1&#13;
    checkInt(this, value, offset, byteLength, maxBytes, 0)&#13;
  }&#13;
&#13;
  var i = byteLength - 1&#13;
  var mul = 1&#13;
  this[offset + i] = value &amp; 0xFF&#13;
  while (--i &gt;= 0 &amp;&amp; (mul *= 0x100)) {&#13;
    this[offset + i] = (value / mul) &amp; 0xFF&#13;
  }&#13;
&#13;
  return offset + byteLength&#13;
}&#13;
&#13;
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)&#13;
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)&#13;
  this[offset] = (value &amp; 0xff)&#13;
  return offset + 1&#13;
}&#13;
&#13;
function objectWriteUInt16 (buf, value, offset, littleEndian) {&#13;
  if (value &lt; 0) value = 0xffff + value + 1&#13;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i &lt; j; i++) {&#13;
    buf[offset + i] = (value &amp; (0xff &lt;&lt; (8 * (littleEndian ? i : 1 - i)))) &gt;&gt;&gt;&#13;
      (littleEndian ? i : 1 - i) * 8&#13;
  }&#13;
}&#13;
&#13;
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)&#13;
  if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    this[offset] = (value &amp; 0xff)&#13;
    this[offset + 1] = (value &gt;&gt;&gt; 8)&#13;
  } else {&#13;
    objectWriteUInt16(this, value, offset, true)&#13;
  }&#13;
  return offset + 2&#13;
}&#13;
&#13;
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)&#13;
  if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    this[offset] = (value &gt;&gt;&gt; 8)&#13;
    this[offset + 1] = (value &amp; 0xff)&#13;
  } else {&#13;
    objectWriteUInt16(this, value, offset, false)&#13;
  }&#13;
  return offset + 2&#13;
}&#13;
&#13;
function objectWriteUInt32 (buf, value, offset, littleEndian) {&#13;
  if (value &lt; 0) value = 0xffffffff + value + 1&#13;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i &lt; j; i++) {&#13;
    buf[offset + i] = (value &gt;&gt;&gt; (littleEndian ? i : 3 - i) * 8) &amp; 0xff&#13;
  }&#13;
}&#13;
&#13;
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)&#13;
  if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    this[offset + 3] = (value &gt;&gt;&gt; 24)&#13;
    this[offset + 2] = (value &gt;&gt;&gt; 16)&#13;
    this[offset + 1] = (value &gt;&gt;&gt; 8)&#13;
    this[offset] = (value &amp; 0xff)&#13;
  } else {&#13;
    objectWriteUInt32(this, value, offset, true)&#13;
  }&#13;
  return offset + 4&#13;
}&#13;
&#13;
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)&#13;
  if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    this[offset] = (value &gt;&gt;&gt; 24)&#13;
    this[offset + 1] = (value &gt;&gt;&gt; 16)&#13;
    this[offset + 2] = (value &gt;&gt;&gt; 8)&#13;
    this[offset + 3] = (value &amp; 0xff)&#13;
  } else {&#13;
    objectWriteUInt32(this, value, offset, false)&#13;
  }&#13;
  return offset + 4&#13;
}&#13;
&#13;
Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  if (!noAssert) {&#13;
    var limit = Math.pow(2, 8 * byteLength - 1)&#13;
&#13;
    checkInt(this, value, offset, byteLength, limit - 1, -limit)&#13;
  }&#13;
&#13;
  var i = 0&#13;
  var mul = 1&#13;
  var sub = 0&#13;
  this[offset] = value &amp; 0xFF&#13;
  while (++i &lt; byteLength &amp;&amp; (mul *= 0x100)) {&#13;
    if (value &lt; 0 &amp;&amp; sub === 0 &amp;&amp; this[offset + i - 1] !== 0) {&#13;
      sub = 1&#13;
    }&#13;
    this[offset + i] = ((value / mul) &gt;&gt; 0) - sub &amp; 0xFF&#13;
  }&#13;
&#13;
  return offset + byteLength&#13;
}&#13;
&#13;
Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  if (!noAssert) {&#13;
    var limit = Math.pow(2, 8 * byteLength - 1)&#13;
&#13;
    checkInt(this, value, offset, byteLength, limit - 1, -limit)&#13;
  }&#13;
&#13;
  var i = byteLength - 1&#13;
  var mul = 1&#13;
  var sub = 0&#13;
  this[offset + i] = value &amp; 0xFF&#13;
  while (--i &gt;= 0 &amp;&amp; (mul *= 0x100)) {&#13;
    if (value &lt; 0 &amp;&amp; sub === 0 &amp;&amp; this[offset + i + 1] !== 0) {&#13;
      sub = 1&#13;
    }&#13;
    this[offset + i] = ((value / mul) &gt;&gt; 0) - sub &amp; 0xFF&#13;
  }&#13;
&#13;
  return offset + byteLength&#13;
}&#13;
&#13;
Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)&#13;
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)&#13;
  if (value &lt; 0) value = 0xff + value + 1&#13;
  this[offset] = (value &amp; 0xff)&#13;
  return offset + 1&#13;
}&#13;
&#13;
Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)&#13;
  if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    this[offset] = (value &amp; 0xff)&#13;
    this[offset + 1] = (value &gt;&gt;&gt; 8)&#13;
  } else {&#13;
    objectWriteUInt16(this, value, offset, true)&#13;
  }&#13;
  return offset + 2&#13;
}&#13;
&#13;
Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)&#13;
  if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    this[offset] = (value &gt;&gt;&gt; 8)&#13;
    this[offset + 1] = (value &amp; 0xff)&#13;
  } else {&#13;
    objectWriteUInt16(this, value, offset, false)&#13;
  }&#13;
  return offset + 2&#13;
}&#13;
&#13;
Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)&#13;
  if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    this[offset] = (value &amp; 0xff)&#13;
    this[offset + 1] = (value &gt;&gt;&gt; 8)&#13;
    this[offset + 2] = (value &gt;&gt;&gt; 16)&#13;
    this[offset + 3] = (value &gt;&gt;&gt; 24)&#13;
  } else {&#13;
    objectWriteUInt32(this, value, offset, true)&#13;
  }&#13;
  return offset + 4&#13;
}&#13;
&#13;
Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {&#13;
  value = +value&#13;
  offset = offset | 0&#13;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)&#13;
  if (value &lt; 0) value = 0xffffffff + value + 1&#13;
  if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    this[offset] = (value &gt;&gt;&gt; 24)&#13;
    this[offset + 1] = (value &gt;&gt;&gt; 16)&#13;
    this[offset + 2] = (value &gt;&gt;&gt; 8)&#13;
    this[offset + 3] = (value &amp; 0xff)&#13;
  } else {&#13;
    objectWriteUInt32(this, value, offset, false)&#13;
  }&#13;
  return offset + 4&#13;
}&#13;
&#13;
function checkIEEE754 (buf, value, offset, ext, max, min) {&#13;
  if (offset + ext &gt; buf.length) throw new RangeError('Index out of range')&#13;
  if (offset &lt; 0) throw new RangeError('Index out of range')&#13;
}&#13;
&#13;
function writeFloat (buf, value, offset, littleEndian, noAssert) {&#13;
  if (!noAssert) {&#13;
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)&#13;
  }&#13;
  ieee754.write(buf, value, offset, littleEndian, 23, 4)&#13;
  return offset + 4&#13;
}&#13;
&#13;
Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {&#13;
  return writeFloat(this, value, offset, true, noAssert)&#13;
}&#13;
&#13;
Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {&#13;
  return writeFloat(this, value, offset, false, noAssert)&#13;
}&#13;
&#13;
function writeDouble (buf, value, offset, littleEndian, noAssert) {&#13;
  if (!noAssert) {&#13;
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)&#13;
  }&#13;
  ieee754.write(buf, value, offset, littleEndian, 52, 8)&#13;
  return offset + 8&#13;
}&#13;
&#13;
Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {&#13;
  return writeDouble(this, value, offset, true, noAssert)&#13;
}&#13;
&#13;
Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {&#13;
  return writeDouble(this, value, offset, false, noAssert)&#13;
}&#13;
&#13;
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)&#13;
Buffer.prototype.copy = function copy (target, targetStart, start, end) {&#13;
  if (!start) start = 0&#13;
  if (!end &amp;&amp; end !== 0) end = this.length&#13;
  if (targetStart &gt;= target.length) targetStart = target.length&#13;
  if (!targetStart) targetStart = 0&#13;
  if (end &gt; 0 &amp;&amp; end &lt; start) end = start&#13;
&#13;
  // Copy 0 bytes; we're done&#13;
  if (end === start) return 0&#13;
  if (target.length === 0 || this.length === 0) return 0&#13;
&#13;
  // Fatal error conditions&#13;
  if (targetStart &lt; 0) {&#13;
    throw new RangeError('targetStart out of bounds')&#13;
  }&#13;
  if (start &lt; 0 || start &gt;= this.length) throw new RangeError('sourceStart out of bounds')&#13;
  if (end &lt; 0) throw new RangeError('sourceEnd out of bounds')&#13;
&#13;
  // Are we oob?&#13;
  if (end &gt; this.length) end = this.length&#13;
  if (target.length - targetStart &lt; end - start) {&#13;
    end = target.length - targetStart + start&#13;
  }&#13;
&#13;
  var len = end - start&#13;
  var i&#13;
&#13;
  if (this === target &amp;&amp; start &lt; targetStart &amp;&amp; targetStart &lt; end) {&#13;
    // descending copy from end&#13;
    for (i = len - 1; i &gt;= 0; i--) {&#13;
      target[i + targetStart] = this[i + start]&#13;
    }&#13;
  } else if (len &lt; 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    // ascending copy from start&#13;
    for (i = 0; i &lt; len; i++) {&#13;
      target[i + targetStart] = this[i + start]&#13;
    }&#13;
  } else {&#13;
    Uint8Array.prototype.set.call(&#13;
      target,&#13;
      this.subarray(start, start + len),&#13;
      targetStart&#13;
    )&#13;
  }&#13;
&#13;
  return len&#13;
}&#13;
&#13;
// Usage:&#13;
//    buffer.fill(number[, offset[, end]])&#13;
//    buffer.fill(buffer[, offset[, end]])&#13;
//    buffer.fill(string[, offset[, end]][, encoding])&#13;
Buffer.prototype.fill = function fill (val, start, end, encoding) {&#13;
  // Handle string cases:&#13;
  if (typeof val === 'string') {&#13;
    if (typeof start === 'string') {&#13;
      encoding = start&#13;
      start = 0&#13;
      end = this.length&#13;
    } else if (typeof end === 'string') {&#13;
      encoding = end&#13;
      end = this.length&#13;
    }&#13;
    if (val.length === 1) {&#13;
      var code = val.charCodeAt(0)&#13;
      if (code &lt; 256) {&#13;
        val = code&#13;
      }&#13;
    }&#13;
    if (encoding !== undefined &amp;&amp; typeof encoding !== 'string') {&#13;
      throw new TypeError('encoding must be a string')&#13;
    }&#13;
    if (typeof encoding === 'string' &amp;&amp; !Buffer.isEncoding(encoding)) {&#13;
      throw new TypeError('Unknown encoding: ' + encoding)&#13;
    }&#13;
  } else if (typeof val === 'number') {&#13;
    val = val &amp; 255&#13;
  }&#13;
&#13;
  // Invalid ranges are not set to a default, so can range check early.&#13;
  if (start &lt; 0 || this.length &lt; start || this.length &lt; end) {&#13;
    throw new RangeError('Out of range index')&#13;
  }&#13;
&#13;
  if (end &lt;= start) {&#13;
    return this&#13;
  }&#13;
&#13;
  start = start &gt;&gt;&gt; 0&#13;
  end = end === undefined ? this.length : end &gt;&gt;&gt; 0&#13;
&#13;
  if (!val) val = 0&#13;
&#13;
  var i&#13;
  if (typeof val === 'number') {&#13;
    for (i = start; i &lt; end; i++) {&#13;
      this[i] = val&#13;
    }&#13;
  } else {&#13;
    var bytes = Buffer.isBuffer(val)&#13;
      ? val&#13;
      : utf8ToBytes(new Buffer(val, encoding).toString())&#13;
    var len = bytes.length&#13;
    for (i = 0; i &lt; end - start; i++) {&#13;
      this[i + start] = bytes[i % len]&#13;
    }&#13;
  }&#13;
&#13;
  return this&#13;
}&#13;
&#13;
// HELPER FUNCTIONS&#13;
// ================&#13;
&#13;
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g&#13;
&#13;
function base64clean (str) {&#13;
  // Node strips out invalid characters like \n and \t from the string, base64-js does not&#13;
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')&#13;
  // Node converts strings with length &lt; 2 to ''&#13;
  if (str.length &lt; 2) return ''&#13;
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not&#13;
  while (str.length % 4 !== 0) {&#13;
    str = str + '='&#13;
  }&#13;
  return str&#13;
}&#13;
&#13;
function stringtrim (str) {&#13;
  if (str.trim) return str.trim()&#13;
  return str.replace(/^\s+|\s+$/g, '')&#13;
}&#13;
&#13;
function toHex (n) {&#13;
  if (n &lt; 16) return '0' + n.toString(16)&#13;
  return n.toString(16)&#13;
}&#13;
&#13;
function utf8ToBytes (string, units) {&#13;
  units = units || Infinity&#13;
  var codePoint&#13;
  var length = string.length&#13;
  var leadSurrogate = null&#13;
  var bytes = []&#13;
&#13;
  for (var i = 0; i &lt; length; i++) {&#13;
    codePoint = string.charCodeAt(i)&#13;
&#13;
    // is surrogate component&#13;
    if (codePoint &gt; 0xD7FF &amp;&amp; codePoint &lt; 0xE000) {&#13;
      // last char was a lead&#13;
      if (!leadSurrogate) {&#13;
        // no lead yet&#13;
        if (codePoint &gt; 0xDBFF) {&#13;
          // unexpected trail&#13;
          if ((units -= 3) &gt; -1) bytes.push(0xEF, 0xBF, 0xBD)&#13;
          continue&#13;
        } else if (i + 1 === length) {&#13;
          // unpaired lead&#13;
          if ((units -= 3) &gt; -1) bytes.push(0xEF, 0xBF, 0xBD)&#13;
          continue&#13;
        }&#13;
&#13;
        // valid lead&#13;
        leadSurrogate = codePoint&#13;
&#13;
        continue&#13;
      }&#13;
&#13;
      // 2 leads in a row&#13;
      if (codePoint &lt; 0xDC00) {&#13;
        if ((units -= 3) &gt; -1) bytes.push(0xEF, 0xBF, 0xBD)&#13;
        leadSurrogate = codePoint&#13;
        continue&#13;
      }&#13;
&#13;
      // valid surrogate pair&#13;
      codePoint = (leadSurrogate - 0xD800 &lt;&lt; 10 | codePoint - 0xDC00) + 0x10000&#13;
    } else if (leadSurrogate) {&#13;
      // valid bmp char, but last char was a lead&#13;
      if ((units -= 3) &gt; -1) bytes.push(0xEF, 0xBF, 0xBD)&#13;
    }&#13;
&#13;
    leadSurrogate = null&#13;
&#13;
    // encode utf8&#13;
    if (codePoint &lt; 0x80) {&#13;
      if ((units -= 1) &lt; 0) break&#13;
      bytes.push(codePoint)&#13;
    } else if (codePoint &lt; 0x800) {&#13;
      if ((units -= 2) &lt; 0) break&#13;
      bytes.push(&#13;
        codePoint &gt;&gt; 0x6 | 0xC0,&#13;
        codePoint &amp; 0x3F | 0x80&#13;
      )&#13;
    } else if (codePoint &lt; 0x10000) {&#13;
      if ((units -= 3) &lt; 0) break&#13;
      bytes.push(&#13;
        codePoint &gt;&gt; 0xC | 0xE0,&#13;
        codePoint &gt;&gt; 0x6 &amp; 0x3F | 0x80,&#13;
        codePoint &amp; 0x3F | 0x80&#13;
      )&#13;
    } else if (codePoint &lt; 0x110000) {&#13;
      if ((units -= 4) &lt; 0) break&#13;
      bytes.push(&#13;
        codePoint &gt;&gt; 0x12 | 0xF0,&#13;
        codePoint &gt;&gt; 0xC &amp; 0x3F | 0x80,&#13;
        codePoint &gt;&gt; 0x6 &amp; 0x3F | 0x80,&#13;
        codePoint &amp; 0x3F | 0x80&#13;
      )&#13;
    } else {&#13;
      throw new Error('Invalid code point')&#13;
    }&#13;
  }&#13;
&#13;
  return bytes&#13;
}&#13;
&#13;
function asciiToBytes (str) {&#13;
  var byteArray = []&#13;
  for (var i = 0; i &lt; str.length; i++) {&#13;
    // Node's code seems to be doing this and not &amp; 0x7F..&#13;
    byteArray.push(str.charCodeAt(i) &amp; 0xFF)&#13;
  }&#13;
  return byteArray&#13;
}&#13;
&#13;
function utf16leToBytes (str, units) {&#13;
  var c, hi, lo&#13;
  var byteArray = []&#13;
  for (var i = 0; i &lt; str.length; i++) {&#13;
    if ((units -= 2) &lt; 0) break&#13;
&#13;
    c = str.charCodeAt(i)&#13;
    hi = c &gt;&gt; 8&#13;
    lo = c % 256&#13;
    byteArray.push(lo)&#13;
    byteArray.push(hi)&#13;
  }&#13;
&#13;
  return byteArray&#13;
}&#13;
&#13;
function base64ToBytes (str) {&#13;
  return base64.toByteArray(base64clean(str))&#13;
}&#13;
&#13;
function blitBuffer (src, dst, offset, length) {&#13;
  for (var i = 0; i &lt; length; i++) {&#13;
    if ((i + offset &gt;= dst.length) || (i &gt;= src.length)) break&#13;
    dst[i + offset] = src[i]&#13;
  }&#13;
  return i&#13;
}&#13;
&#13;
function isnan (val) {&#13;
  return val !== val // eslint-disable-line no-self-compare&#13;
}&#13;
&#13;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})&#13;
},{"base64-js":1,"ieee754":15,"isarray":16}],4:[function(require,module,exports){&#13;
// Use strict mode (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)&#13;
"use strict";&#13;
&#13;
&#13;
// Requires&#13;
var Typo = require("typo-js");&#13;
&#13;
&#13;
// Create function&#13;
function CodeMirrorSpellChecker(options) {&#13;
	// Initialize&#13;
	options = options || {};&#13;
&#13;
&#13;
	// Verify&#13;
	if(typeof options.codeMirrorInstance !== "function" || typeof options.codeMirrorInstance.defineMode !== "function") {&#13;
		console.log("CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`");&#13;
		return;&#13;
	}&#13;
&#13;
&#13;
	// Because some browsers don't support this functionality yet&#13;
	if(!String.prototype.includes) {&#13;
		String.prototype.includes = function() {&#13;
			"use strict";&#13;
			return String.prototype.indexOf.apply(this, arguments) !== -1;&#13;
		};&#13;
	}&#13;
&#13;
&#13;
	// Define the new mode&#13;
	options.codeMirrorInstance.defineMode("spell-checker", function(config) {&#13;
		// Load AFF/DIC data&#13;
		if(!CodeMirrorSpellChecker.aff_loading) {&#13;
			CodeMirrorSpellChecker.aff_loading = true;&#13;
			var xhr_aff = new XMLHttpRequest();&#13;
			xhr_aff.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff", true);&#13;
			xhr_aff.onload = function() {&#13;
				if(xhr_aff.readyState === 4 &amp;&amp; xhr_aff.status === 200) {&#13;
					CodeMirrorSpellChecker.aff_data = xhr_aff.responseText;&#13;
					CodeMirrorSpellChecker.num_loaded++;&#13;
&#13;
					if(CodeMirrorSpellChecker.num_loaded == 2) {&#13;
						CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {&#13;
							platform: "any"&#13;
						});&#13;
					}&#13;
				}&#13;
			};&#13;
			xhr_aff.send(null);&#13;
		}&#13;
&#13;
		if(!CodeMirrorSpellChecker.dic_loading) {&#13;
			CodeMirrorSpellChecker.dic_loading = true;&#13;
			var xhr_dic = new XMLHttpRequest();&#13;
			xhr_dic.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic", true);&#13;
			xhr_dic.onload = function() {&#13;
				if(xhr_dic.readyState === 4 &amp;&amp; xhr_dic.status === 200) {&#13;
					CodeMirrorSpellChecker.dic_data = xhr_dic.responseText;&#13;
					CodeMirrorSpellChecker.num_loaded++;&#13;
&#13;
					if(CodeMirrorSpellChecker.num_loaded == 2) {&#13;
						CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {&#13;
							platform: "any"&#13;
						});&#13;
					}&#13;
				}&#13;
			};&#13;
			xhr_dic.send(null);&#13;
		}&#13;
&#13;
&#13;
		// Define what separates a word&#13;
		var rx_word = "!\"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~ ";&#13;
&#13;
&#13;
		// Create the overlay and such&#13;
		var overlay = {&#13;
			token: function(stream) {&#13;
				var ch = stream.peek();&#13;
				var word = "";&#13;
&#13;
				if(rx_word.includes(ch)) {&#13;
					stream.next();&#13;
					return null;&#13;
				}&#13;
&#13;
				while((ch = stream.peek()) != null &amp;&amp; !rx_word.includes(ch)) {&#13;
					word += ch;&#13;
					stream.next();&#13;
				}&#13;
&#13;
				if(CodeMirrorSpellChecker.typo &amp;&amp; !CodeMirrorSpellChecker.typo.check(word))&#13;
					return "spell-error"; // CSS class: cm-spell-error&#13;
&#13;
				return null;&#13;
			}&#13;
		};&#13;
&#13;
		var mode = options.codeMirrorInstance.getMode(&#13;
			config, config.backdrop || "text/plain"&#13;
		);&#13;
&#13;
		return options.codeMirrorInstance.overlayMode(mode, overlay, true);&#13;
	});&#13;
}&#13;
&#13;
&#13;
// Initialize data globally to reduce memory consumption&#13;
CodeMirrorSpellChecker.num_loaded = 0;&#13;
CodeMirrorSpellChecker.aff_loading = false;&#13;
CodeMirrorSpellChecker.dic_loading = false;&#13;
CodeMirrorSpellChecker.aff_data = "";&#13;
CodeMirrorSpellChecker.dic_data = "";&#13;
CodeMirrorSpellChecker.typo;&#13;
&#13;
&#13;
// Export&#13;
module.exports = CodeMirrorSpellChecker;&#13;
},{"typo-js":18}],5:[function(require,module,exports){&#13;
// CodeMirror, copyright (c) by Marijn Haverbeke and others&#13;
// Distributed under an MIT license: http://codemirror.net/LICENSE&#13;
&#13;
(function(mod) {&#13;
  if (typeof exports == "object" &amp;&amp; typeof module == "object") // CommonJS&#13;
    mod(require("../../lib/codemirror"));&#13;
  else if (typeof define == "function" &amp;&amp; define.amd) // AMD&#13;
    define(["../../lib/codemirror"], mod);&#13;
  else // Plain browser env&#13;
    mod(CodeMirror);&#13;
})(function(CodeMirror) {&#13;
  "use strict";&#13;
&#13;
  CodeMirror.defineOption("fullScreen", false, function(cm, val, old) {&#13;
    if (old == CodeMirror.Init) old = false;&#13;
    if (!old == !val) return;&#13;
    if (val) setFullscreen(cm);&#13;
    else setNormal(cm);&#13;
  });&#13;
&#13;
  function setFullscreen(cm) {&#13;
    var wrap = cm.getWrapperElement();&#13;
    cm.state.fullScreenRestore = {scrollTop: window.pageYOffset, scrollLeft: window.pageXOffset,&#13;
                                  width: wrap.style.width, height: wrap.style.height};&#13;
    wrap.style.width = "";&#13;
    wrap.style.height = "auto";&#13;
    wrap.className += " CodeMirror-fullscreen";&#13;
    document.documentElement.style.overflow = "hidden";&#13;
    cm.refresh();&#13;
  }&#13;
&#13;
  function setNormal(cm) {&#13;
    var wrap = cm.getWrapperElement();&#13;
    wrap.className = wrap.className.replace(/\s*CodeMirror-fullscreen\b/, "");&#13;
    document.documentElement.style.overflow = "";&#13;
    var info = cm.state.fullScreenRestore;&#13;
    wrap.style.width = info.width; wrap.style.height = info.height;&#13;
    window.scrollTo(info.scrollLeft, info.scrollTop);&#13;
    cm.refresh();&#13;
  }&#13;
});&#13;
&#13;
},{"../../lib/codemirror":10}],6:[function(require,module,exports){&#13;
// CodeMirror, copyright (c) by Marijn Haverbeke and others&#13;
// Distributed under an MIT license: http://codemirror.net/LICENSE&#13;
&#13;
(function(mod) {&#13;
  if (typeof exports == "object" &amp;&amp; typeof module == "object") // CommonJS&#13;
    mod(require("../../lib/codemirror"));&#13;
  else if (typeof define == "function" &amp;&amp; define.amd) // AMD&#13;
    define(["../../lib/codemirror"], mod);&#13;
  else // Plain browser env&#13;
    mod(CodeMirror);&#13;
})(function(CodeMirror) {&#13;
  CodeMirror.defineOption("placeholder", "", function(cm, val, old) {&#13;
    var prev = old &amp;&amp; old != CodeMirror.Init;&#13;
    if (val &amp;&amp; !prev) {&#13;
      cm.on("blur", onBlur);&#13;
      cm.on("change", onChange);&#13;
      cm.on("swapDoc", onChange);&#13;
      onChange(cm);&#13;
    } else if (!val &amp;&amp; prev) {&#13;
      cm.off("blur", onBlur);&#13;
      cm.off("change", onChange);&#13;
      cm.off("swapDoc", onChange);&#13;
      clearPlaceholder(cm);&#13;
      var wrapper = cm.getWrapperElement();&#13;
      wrapper.className = wrapper.className.replace(" CodeMirror-empty", "");&#13;
    }&#13;
&#13;
    if (val &amp;&amp; !cm.hasFocus()) onBlur(cm);&#13;
  });&#13;
&#13;
  function clearPlaceholder(cm) {&#13;
    if (cm.state.placeholder) {&#13;
      cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);&#13;
      cm.state.placeholder = null;&#13;
    }&#13;
  }&#13;
  function setPlaceholder(cm) {&#13;
    clearPlaceholder(cm);&#13;
    var elt = cm.state.placeholder = document.createElement("pre");&#13;
    elt.style.cssText = "height: 0; overflow: visible";&#13;
    elt.className = "CodeMirror-placeholder";&#13;
    var placeHolder = cm.getOption("placeholder")&#13;
    if (typeof placeHolder == "string") placeHolder = document.createTextNode(placeHolder)&#13;
    elt.appendChild(placeHolder)&#13;
    cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);&#13;
  }&#13;
&#13;
  function onBlur(cm) {&#13;
    if (isEmpty(cm)) setPlaceholder(cm);&#13;
  }&#13;
  function onChange(cm) {&#13;
    var wrapper = cm.getWrapperElement(), empty = isEmpty(cm);&#13;
    wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : "");&#13;
&#13;
    if (empty) setPlaceholder(cm);&#13;
    else clearPlaceholder(cm);&#13;
  }&#13;
&#13;
  function isEmpty(cm) {&#13;
    return (cm.lineCount() === 1) &amp;&amp; (cm.getLine(0) === "");&#13;
  }&#13;
});&#13;
&#13;
},{"../../lib/codemirror":10}],7:[function(require,module,exports){&#13;
// CodeMirror, copyright (c) by Marijn Haverbeke and others&#13;
// Distributed under an MIT license: http://codemirror.net/LICENSE&#13;
&#13;
(function(mod) {&#13;
  if (typeof exports == "object" &amp;&amp; typeof module == "object") // CommonJS&#13;
    mod(require("../../lib/codemirror"));&#13;
  else if (typeof define == "function" &amp;&amp; define.amd) // AMD&#13;
    define(["../../lib/codemirror"], mod);&#13;
  else // Plain browser env&#13;
    mod(CodeMirror);&#13;
})(function(CodeMirror) {&#13;
  "use strict";&#13;
&#13;
  var listRE = /^(\s*)(&gt;[&gt; ]*|[*+-]\s|(\d+)([.)]))(\s*)/,&#13;
      emptyListRE = /^(\s*)(&gt;[&gt; ]*|[*+-]|(\d+)[.)])(\s*)$/,&#13;
      unorderedListRE = /[*+-]\s/;&#13;
&#13;
  CodeMirror.commands.newlineAndIndentContinueMarkdownList = function(cm) {&#13;
    if (cm.getOption("disableInput")) return CodeMirror.Pass;&#13;
    var ranges = cm.listSelections(), replacements = [];&#13;
    for (var i = 0; i &lt; ranges.length; i++) {&#13;
      var pos = ranges[i].head;&#13;
      var eolState = cm.getStateAfter(pos.line);&#13;
      var inList = eolState.list !== false;&#13;
      var inQuote = eolState.quote !== 0;&#13;
&#13;
      var line = cm.getLine(pos.line), match = listRE.exec(line);&#13;
      if (!ranges[i].empty() || (!inList &amp;&amp; !inQuote) || !match) {&#13;
        cm.execCommand("newlineAndIndent");&#13;
        return;&#13;
      }&#13;
      if (emptyListRE.test(line)) {&#13;
        cm.replaceRange("", {&#13;
          line: pos.line, ch: 0&#13;
        }, {&#13;
          line: pos.line, ch: pos.ch + 1&#13;
        });&#13;
        replacements[i] = "\n";&#13;
      } else {&#13;
        var indent = match[1], after = match[5];&#13;
        var bullet = unorderedListRE.test(match[2]) || match[2].indexOf("&gt;") &gt;= 0&#13;
          ? match[2]&#13;
          : (parseInt(match[3], 10) + 1) + match[4];&#13;
&#13;
        replacements[i] = "\n" + indent + bullet + after;&#13;
      }&#13;
    }&#13;
&#13;
    cm.replaceSelections(replacements);&#13;
  };&#13;
});&#13;
&#13;
},{"../../lib/codemirror":10}],8:[function(require,module,exports){&#13;
// CodeMirror, copyright (c) by Marijn Haverbeke and others&#13;
// Distributed under an MIT license: http://codemirror.net/LICENSE&#13;
&#13;
// Utility function that allows modes to be combined. The mode given&#13;
// as the base argument takes care of most of the normal mode&#13;
// functionality, but a second (typically simple) mode is used, which&#13;
// can override the style of text. Both modes get to parse all of the&#13;
// text, but when both assign a non-null style to a piece of code, the&#13;
// overlay wins, unless the combine argument was true and not overridden,&#13;
// or state.overlay.combineTokens was true, in which case the styles are&#13;
// combined.&#13;
&#13;
(function(mod) {&#13;
  if (typeof exports == "object" &amp;&amp; typeof module == "object") // CommonJS&#13;
    mod(require("../../lib/codemirror"));&#13;
  else if (typeof define == "function" &amp;&amp; define.amd) // AMD&#13;
    define(["../../lib/codemirror"], mod);&#13;
  else // Plain browser env&#13;
    mod(CodeMirror);&#13;
})(function(CodeMirror) {&#13;
"use strict";&#13;
&#13;
CodeMirror.overlayMode = function(base, overlay, combine) {&#13;
  return {&#13;
    startState: function() {&#13;
      return {&#13;
        base: CodeMirror.startState(base),&#13;
        overlay: CodeMirror.startState(overlay),&#13;
        basePos: 0, baseCur: null,&#13;
        overlayPos: 0, overlayCur: null,&#13;
        streamSeen: null&#13;
      };&#13;
    },&#13;
    copyState: function(state) {&#13;
      return {&#13;
        base: CodeMirror.copyState(base, state.base),&#13;
        overlay: CodeMirror.copyState(overlay, state.overlay),&#13;
        basePos: state.basePos, baseCur: null,&#13;
        overlayPos: state.overlayPos, overlayCur: null&#13;
      };&#13;
    },&#13;
&#13;
    token: function(stream, state) {&#13;
      if (stream != state.streamSeen ||&#13;
          Math.min(state.basePos, state.overlayPos) &lt; stream.start) {&#13;
        state.streamSeen = stream;&#13;
        state.basePos = state.overlayPos = stream.start;&#13;
      }&#13;
&#13;
      if (stream.start == state.basePos) {&#13;
        state.baseCur = base.token(stream, state.base);&#13;
        state.basePos = stream.pos;&#13;
      }&#13;
      if (stream.start == state.overlayPos) {&#13;
        stream.pos = stream.start;&#13;
        state.overlayCur = overlay.token(stream, state.overlay);&#13;
        state.overlayPos = stream.pos;&#13;
      }&#13;
      stream.pos = Math.min(state.basePos, state.overlayPos);&#13;
&#13;
      // state.overlay.combineTokens always takes precedence over combine,&#13;
      // unless set to null&#13;
      if (state.overlayCur == null) return state.baseCur;&#13;
      else if (state.baseCur != null &amp;&amp;&#13;
               state.overlay.combineTokens ||&#13;
               combine &amp;&amp; state.overlay.combineTokens == null)&#13;
        return state.baseCur + " " + state.overlayCur;&#13;
      else return state.overlayCur;&#13;
    },&#13;
&#13;
    indent: base.indent &amp;&amp; function(state, textAfter) {&#13;
      return base.indent(state.base, textAfter);&#13;
    },&#13;
    electricChars: base.electricChars,&#13;
&#13;
    innerMode: function(state) { return {state: state.base, mode: base}; },&#13;
&#13;
    blankLine: function(state) {&#13;
      if (base.blankLine) base.blankLine(state.base);&#13;
      if (overlay.blankLine) overlay.blankLine(state.overlay);&#13;
    }&#13;
  };&#13;
};&#13;
&#13;
});&#13;
&#13;
},{"../../lib/codemirror":10}],9:[function(require,module,exports){&#13;
// CodeMirror, copyright (c) by Marijn Haverbeke and others&#13;
// Distributed under an MIT license: http://codemirror.net/LICENSE&#13;
&#13;
// Because sometimes you need to mark the selected *text*.&#13;
//&#13;
// Adds an option 'styleSelectedText' which, when enabled, gives&#13;
// selected text the CSS class given as option value, or&#13;
// "CodeMirror-selectedtext" when the value is not a string.&#13;
&#13;
(function(mod) {&#13;
  if (typeof exports == "object" &amp;&amp; typeof module == "object") // CommonJS&#13;
    mod(require("../../lib/codemirror"));&#13;
  else if (typeof define == "function" &amp;&amp; define.amd) // AMD&#13;
    define(["../../lib/codemirror"], mod);&#13;
  else // Plain browser env&#13;
    mod(CodeMirror);&#13;
})(function(CodeMirror) {&#13;
  "use strict";&#13;
&#13;
  CodeMirror.defineOption("styleSelectedText", false, function(cm, val, old) {&#13;
    var prev = old &amp;&amp; old != CodeMirror.Init;&#13;
    if (val &amp;&amp; !prev) {&#13;
      cm.state.markedSelection = [];&#13;
      cm.state.markedSelectionStyle = typeof val == "string" ? val : "CodeMirror-selectedtext";&#13;
      reset(cm);&#13;
      cm.on("cursorActivity", onCursorActivity);&#13;
      cm.on("change", onChange);&#13;
    } else if (!val &amp;&amp; prev) {&#13;
      cm.off("cursorActivity", onCursorActivity);&#13;
      cm.off("change", onChange);&#13;
      clear(cm);&#13;
      cm.state.markedSelection = cm.state.markedSelectionStyle = null;&#13;
    }&#13;
  });&#13;
&#13;
  function onCursorActivity(cm) {&#13;
    cm.operation(function() { update(cm); });&#13;
  }&#13;
&#13;
  function onChange(cm) {&#13;
    if (cm.state.markedSelection.length)&#13;
      cm.operation(function() { clear(cm); });&#13;
  }&#13;
&#13;
  var CHUNK_SIZE = 8;&#13;
  var Pos = CodeMirror.Pos;&#13;
  var cmp = CodeMirror.cmpPos;&#13;
&#13;
  function coverRange(cm, from, to, addAt) {&#13;
    if (cmp(from, to) == 0) return;&#13;
    var array = cm.state.markedSelection;&#13;
    var cls = cm.state.markedSelectionStyle;&#13;
    for (var line = from.line;;) {&#13;
      var start = line == from.line ? from : Pos(line, 0);&#13;
      var endLine = line + CHUNK_SIZE, atEnd = endLine &gt;= to.line;&#13;
      var end = atEnd ? to : Pos(endLine, 0);&#13;
      var mark = cm.markText(start, end, {className: cls});&#13;
      if (addAt == null) array.push(mark);&#13;
      else array.splice(addAt++, 0, mark);&#13;
      if (atEnd) break;&#13;
      line = endLine;&#13;
    }&#13;
  }&#13;
&#13;
  function clear(cm) {&#13;
    var array = cm.state.markedSelection;&#13;
    for (var i = 0; i &lt; array.length; ++i) array[i].clear();&#13;
    array.length = 0;&#13;
  }&#13;
&#13;
  function reset(cm) {&#13;
    clear(cm);&#13;
    var ranges = cm.listSelections();&#13;
    for (var i = 0; i &lt; ranges.length; i++)&#13;
      coverRange(cm, ranges[i].from(), ranges[i].to());&#13;
  }&#13;
&#13;
  function update(cm) {&#13;
    if (!cm.somethingSelected()) return clear(cm);&#13;
    if (cm.listSelections().length &gt; 1) return reset(cm);&#13;
&#13;
    var from = cm.getCursor("start"), to = cm.getCursor("end");&#13;
&#13;
    var array = cm.state.markedSelection;&#13;
    if (!array.length) return coverRange(cm, from, to);&#13;
&#13;
    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();&#13;
    if (!coverStart || !coverEnd || to.line - from.line &lt; CHUNK_SIZE ||&#13;
        cmp(from, coverEnd.to) &gt;= 0 || cmp(to, coverStart.from) &lt;= 0)&#13;
      return reset(cm);&#13;
&#13;
    while (cmp(from, coverStart.from) &gt; 0) {&#13;
      array.shift().clear();&#13;
      coverStart = array[0].find();&#13;
    }&#13;
    if (cmp(from, coverStart.from) &lt; 0) {&#13;
      if (coverStart.to.line - from.line &lt; CHUNK_SIZE) {&#13;
        array.shift().clear();&#13;
        coverRange(cm, from, coverStart.to, 0);&#13;
      } else {&#13;
        coverRange(cm, from, coverStart.from, 0);&#13;
      }&#13;
    }&#13;
&#13;
    while (cmp(to, coverEnd.to) &lt; 0) {&#13;
      array.pop().clear();&#13;
      coverEnd = array[array.length - 1].find();&#13;
    }&#13;
    if (cmp(to, coverEnd.to) &gt; 0) {&#13;
      if (to.line - coverEnd.from.line &lt; CHUNK_SIZE) {&#13;
        array.pop().clear();&#13;
        coverRange(cm, coverEnd.from, to);&#13;
      } else {&#13;
        coverRange(cm, coverEnd.to, to);&#13;
      }&#13;
    }&#13;
  }&#13;
});&#13;
&#13;
},{"../../lib/codemirror":10}],10:[function(require,module,exports){&#13;
// CodeMirror, copyright (c) by Marijn Haverbeke and others&#13;
// Distributed under an MIT license: http://codemirror.net/LICENSE&#13;
&#13;
// This is CodeMirror (http://codemirror.net), a code editor&#13;
// implemented in JavaScript on top of the browser's DOM.&#13;
//&#13;
// You can find some technical background for some of the code below&#13;
// at http://marijnhaverbeke.nl/blog/#cm-internals .&#13;
&#13;
(function(mod) {&#13;
  if (typeof exports == "object" &amp;&amp; typeof module == "object") // CommonJS&#13;
    module.exports = mod();&#13;
  else if (typeof define == "function" &amp;&amp; define.amd) // AMD&#13;
    return define([], mod);&#13;
  else // Plain browser env&#13;
    (this || window).CodeMirror = mod();&#13;
})(function() {&#13;
  "use strict";&#13;
&#13;
  // BROWSER SNIFFING&#13;
&#13;
  // Kludges for bugs and behavior differences that can't be feature&#13;
  // detected are enabled based on userAgent etc sniffing.&#13;
  var userAgent = navigator.userAgent;&#13;
  var platform = navigator.platform;&#13;
&#13;
  var gecko = /gecko\/\d/i.test(userAgent);&#13;
  var ie_upto10 = /MSIE \d/.test(userAgent);&#13;
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);&#13;
  var ie = ie_upto10 || ie_11up;&#13;
  var ie_version = ie &amp;&amp; (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);&#13;
  var webkit = /WebKit\//.test(userAgent);&#13;
  var qtwebkit = webkit &amp;&amp; /Qt\/\d+\.\d+/.test(userAgent);&#13;
  var chrome = /Chrome\//.test(userAgent);&#13;
  var presto = /Opera\//.test(userAgent);&#13;
  var safari = /Apple Computer/.test(navigator.vendor);&#13;
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);&#13;
  var phantom = /PhantomJS/.test(userAgent);&#13;
&#13;
  var ios = /AppleWebKit/.test(userAgent) &amp;&amp; /Mobile\/\w+/.test(userAgent);&#13;
  // This is woefully incomplete. Suggestions for alternative methods welcome.&#13;
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);&#13;
  var mac = ios || /Mac/.test(platform);&#13;
  var chromeOS = /\bCrOS\b/.test(userAgent);&#13;
  var windows = /win/i.test(platform);&#13;
&#13;
  var presto_version = presto &amp;&amp; userAgent.match(/Version\/(\d*\.\d*)/);&#13;
  if (presto_version) presto_version = Number(presto_version[1]);&#13;
  if (presto_version &amp;&amp; presto_version &gt;= 15) { presto = false; webkit = true; }&#13;
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X&#13;
  var flipCtrlCmd = mac &amp;&amp; (qtwebkit || presto &amp;&amp; (presto_version == null || presto_version &lt; 12.11));&#13;
  var captureRightClick = gecko || (ie &amp;&amp; ie_version &gt;= 9);&#13;
&#13;
  // Optimize some code when these features are not used.&#13;
  var sawReadOnlySpans = false, sawCollapsedSpans = false;&#13;
&#13;
  // EDITOR CONSTRUCTOR&#13;
&#13;
  // A CodeMirror instance represents an editor. This is the object&#13;
  // that user code is usually dealing with.&#13;
&#13;
  function CodeMirror(place, options) {&#13;
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);&#13;
&#13;
    this.options = options = options ? copyObj(options) : {};&#13;
    // Determine effective options based on given values and defaults.&#13;
    copyObj(defaults, options, false);&#13;
    setGuttersForLineNumbers(options);&#13;
&#13;
    var doc = options.value;&#13;
    if (typeof doc == "string") doc = new Doc(doc, options.mode, null, options.lineSeparator);&#13;
    this.doc = doc;&#13;
&#13;
    var input = new CodeMirror.inputStyles[options.inputStyle](this);&#13;
    var display = this.display = new Display(place, doc, input);&#13;
    display.wrapper.CodeMirror = this;&#13;
    updateGutters(this);&#13;
    themeChanged(this);&#13;
    if (options.lineWrapping)&#13;
      this.display.wrapper.className += " CodeMirror-wrap";&#13;
    if (options.autofocus &amp;&amp; !mobile) display.input.focus();&#13;
    initScrollbars(this);&#13;
&#13;
    this.state = {&#13;
      keyMaps: [],  // stores maps added by addKeyMap&#13;
      overlays: [], // highlighting overlays, as added by addOverlay&#13;
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info&#13;
      overwrite: false,&#13;
      delayingBlurEvent: false,&#13;
      focused: false,&#13;
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode&#13;
      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll&#13;
      selectingText: false,&#13;
      draggingText: false,&#13;
      highlight: new Delayed(), // stores highlight worker timeout&#13;
      keySeq: null,  // Unfinished key sequence&#13;
      specialChars: null&#13;
    };&#13;
&#13;
    var cm = this;&#13;
&#13;
    // Override magic textarea content restore that IE sometimes does&#13;
    // on our hidden textarea on reload&#13;
    if (ie &amp;&amp; ie_version &lt; 11) setTimeout(function() { cm.display.input.reset(true); }, 20);&#13;
&#13;
    registerEventHandlers(this);&#13;
    ensureGlobalHandlers();&#13;
&#13;
    startOperation(this);&#13;
    this.curOp.forceUpdate = true;&#13;
    attachDoc(this, doc);&#13;
&#13;
    if ((options.autofocus &amp;&amp; !mobile) || cm.hasFocus())&#13;
      setTimeout(bind(onFocus, this), 20);&#13;
    else&#13;
      onBlur(this);&#13;
&#13;
    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))&#13;
      optionHandlers[opt](this, options[opt], Init);&#13;
    maybeUpdateLineNumberWidth(this);&#13;
    if (options.finishInit) options.finishInit(this);&#13;
    for (var i = 0; i &lt; initHooks.length; ++i) initHooks[i](this);&#13;
    endOperation(this);&#13;
    // Suppress optimizelegibility in Webkit, since it breaks text&#13;
    // measuring on line wrapping boundaries.&#13;
    if (webkit &amp;&amp; options.lineWrapping &amp;&amp;&#13;
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")&#13;
      display.lineDiv.style.textRendering = "auto";&#13;
  }&#13;
&#13;
  // DISPLAY CONSTRUCTOR&#13;
&#13;
  // The display handles the DOM integration, both for input reading&#13;
  // and content drawing. It holds references to DOM nodes and&#13;
  // display-related state.&#13;
&#13;
  function Display(place, doc, input) {&#13;
    var d = this;&#13;
    this.input = input;&#13;
&#13;
    // Covers bottom-right square when both scrollbars are present.&#13;
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");&#13;
    d.scrollbarFiller.setAttribute("cm-not-content", "true");&#13;
    // Covers bottom of gutter when coverGutterNextToScrollbar is on&#13;
    // and h scrollbar is present.&#13;
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");&#13;
    d.gutterFiller.setAttribute("cm-not-content", "true");&#13;
    // Will contain the actual code, positioned to cover the viewport.&#13;
    d.lineDiv = elt("div", null, "CodeMirror-code");&#13;
    // Elements are added to these to represent selection and cursors.&#13;
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");&#13;
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");&#13;
    // A visibility: hidden element used to find the size of things.&#13;
    d.measure = elt("div", null, "CodeMirror-measure");&#13;
    // When lines outside of the viewport are measured, they are drawn in this.&#13;
    d.lineMeasure = elt("div", null, "CodeMirror-measure");&#13;
    // Wraps everything that needs to exist inside the vertically-padded coordinate system&#13;
    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],&#13;
                      null, "position: relative; outline: none");&#13;
    // Moved around its parent to cover visible view.&#13;
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");&#13;
    // Set to the height of the document, allowing scrolling.&#13;
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");&#13;
    d.sizerWidth = null;&#13;
    // Behavior of elts with overflow: auto and padding is&#13;
    // inconsistent across browsers. This is used to ensure the&#13;
    // scrollable area is big enough.&#13;
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");&#13;
    // Will contain the gutters, if any.&#13;
    d.gutters = elt("div", null, "CodeMirror-gutters");&#13;
    d.lineGutter = null;&#13;
    // Actual scrollable element.&#13;
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");&#13;
    d.scroller.setAttribute("tabIndex", "-1");&#13;
    // The element in which the editor lives.&#13;
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");&#13;
&#13;
    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)&#13;
    if (ie &amp;&amp; ie_version &lt; 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }&#13;
    if (!webkit &amp;&amp; !(gecko &amp;&amp; mobile)) d.scroller.draggable = true;&#13;
&#13;
    if (place) {&#13;
      if (place.appendChild) place.appendChild(d.wrapper);&#13;
      else place(d.wrapper);&#13;
    }&#13;
&#13;
    // Current rendered range (may be bigger than the view window).&#13;
    d.viewFrom = d.viewTo = doc.first;&#13;
    d.reportedViewFrom = d.reportedViewTo = doc.first;&#13;
    // Information about the rendered lines.&#13;
    d.view = [];&#13;
    d.renderedView = null;&#13;
    // Holds info about a single rendered line when it was rendered&#13;
    // for measurement, while not in view.&#13;
    d.externalMeasured = null;&#13;
    // Empty space (in pixels) above the view&#13;
    d.viewOffset = 0;&#13;
    d.lastWrapHeight = d.lastWrapWidth = 0;&#13;
    d.updateLineNumbers = null;&#13;
&#13;
    d.nativeBarWidth = d.barHeight = d.barWidth = 0;&#13;
    d.scrollbarsClipped = false;&#13;
&#13;
    // Used to only resize the line number gutter when necessary (when&#13;
    // the amount of lines crosses a boundary that makes its width change)&#13;
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;&#13;
    // Set to true when a non-horizontal-scrolling line widget is&#13;
    // added. As an optimization, line widget aligning is skipped when&#13;
    // this is false.&#13;
    d.alignWidgets = false;&#13;
&#13;
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;&#13;
&#13;
    // Tracks the maximum line length so that the horizontal scrollbar&#13;
    // can be kept static when scrolling.&#13;
    d.maxLine = null;&#13;
    d.maxLineLength = 0;&#13;
    d.maxLineChanged = false;&#13;
&#13;
    // Used for measuring wheel scrolling granularity&#13;
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;&#13;
&#13;
    // True when shift is held down.&#13;
    d.shift = false;&#13;
&#13;
    // Used to track whether anything happened since the context menu&#13;
    // was opened.&#13;
    d.selForContextMenu = null;&#13;
&#13;
    d.activeTouch = null;&#13;
&#13;
    input.init(d);&#13;
  }&#13;
&#13;
  // STATE UPDATES&#13;
&#13;
  // Used to get the editor into a consistent state again when options change.&#13;
&#13;
  function loadMode(cm) {&#13;
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);&#13;
    resetModeState(cm);&#13;
  }&#13;
&#13;
  function resetModeState(cm) {&#13;
    cm.doc.iter(function(line) {&#13;
      if (line.stateAfter) line.stateAfter = null;&#13;
      if (line.styles) line.styles = null;&#13;
    });&#13;
    cm.doc.frontier = cm.doc.first;&#13;
    startWorker(cm, 100);&#13;
    cm.state.modeGen++;&#13;
    if (cm.curOp) regChange(cm);&#13;
  }&#13;
&#13;
  function wrappingChanged(cm) {&#13;
    if (cm.options.lineWrapping) {&#13;
      addClass(cm.display.wrapper, "CodeMirror-wrap");&#13;
      cm.display.sizer.style.minWidth = "";&#13;
      cm.display.sizerWidth = null;&#13;
    } else {&#13;
      rmClass(cm.display.wrapper, "CodeMirror-wrap");&#13;
      findMaxLine(cm);&#13;
    }&#13;
    estimateLineHeights(cm);&#13;
    regChange(cm);&#13;
    clearCaches(cm);&#13;
    setTimeout(function(){updateScrollbars(cm);}, 100);&#13;
  }&#13;
&#13;
  // Returns a function that estimates the height of a line, to use as&#13;
  // first approximation until the line becomes visible (and is thus&#13;
  // properly measurable).&#13;
  function estimateHeight(cm) {&#13;
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;&#13;
    var perLine = wrapping &amp;&amp; Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);&#13;
    return function(line) {&#13;
      if (lineIsHidden(cm.doc, line)) return 0;&#13;
&#13;
      var widgetsHeight = 0;&#13;
      if (line.widgets) for (var i = 0; i &lt; line.widgets.length; i++) {&#13;
        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;&#13;
      }&#13;
&#13;
      if (wrapping)&#13;
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;&#13;
      else&#13;
        return widgetsHeight + th;&#13;
    };&#13;
  }&#13;
&#13;
  function estimateLineHeights(cm) {&#13;
    var doc = cm.doc, est = estimateHeight(cm);&#13;
    doc.iter(function(line) {&#13;
      var estHeight = est(line);&#13;
      if (estHeight != line.height) updateLineHeight(line, estHeight);&#13;
    });&#13;
  }&#13;
&#13;
  function themeChanged(cm) {&#13;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +&#13;
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");&#13;
    clearCaches(cm);&#13;
  }&#13;
&#13;
  function guttersChanged(cm) {&#13;
    updateGutters(cm);&#13;
    regChange(cm);&#13;
    setTimeout(function(){alignHorizontally(cm);}, 20);&#13;
  }&#13;
&#13;
  // Rebuild the gutter elements, ensure the margin to the left of the&#13;
  // code matches their width.&#13;
  function updateGutters(cm) {&#13;
    var gutters = cm.display.gutters, specs = cm.options.gutters;&#13;
    removeChildren(gutters);&#13;
    for (var i = 0; i &lt; specs.length; ++i) {&#13;
      var gutterClass = specs[i];&#13;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));&#13;
      if (gutterClass == "CodeMirror-linenumbers") {&#13;
        cm.display.lineGutter = gElt;&#13;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";&#13;
      }&#13;
    }&#13;
    gutters.style.display = i ? "" : "none";&#13;
    updateGutterSpace(cm);&#13;
  }&#13;
&#13;
  function updateGutterSpace(cm) {&#13;
    var width = cm.display.gutters.offsetWidth;&#13;
    cm.display.sizer.style.marginLeft = width + "px";&#13;
  }&#13;
&#13;
  // Compute the character length of a line, taking into account&#13;
  // collapsed ranges (see markText) that might hide parts, and join&#13;
  // other lines onto it.&#13;
  function lineLength(line) {&#13;
    if (line.height == 0) return 0;&#13;
    var len = line.text.length, merged, cur = line;&#13;
    while (merged = collapsedSpanAtStart(cur)) {&#13;
      var found = merged.find(0, true);&#13;
      cur = found.from.line;&#13;
      len += found.from.ch - found.to.ch;&#13;
    }&#13;
    cur = line;&#13;
    while (merged = collapsedSpanAtEnd(cur)) {&#13;
      var found = merged.find(0, true);&#13;
      len -= cur.text.length - found.from.ch;&#13;
      cur = found.to.line;&#13;
      len += cur.text.length - found.to.ch;&#13;
    }&#13;
    return len;&#13;
  }&#13;
&#13;
  // Find the longest line in the document.&#13;
  function findMaxLine(cm) {&#13;
    var d = cm.display, doc = cm.doc;&#13;
    d.maxLine = getLine(doc, doc.first);&#13;
    d.maxLineLength = lineLength(d.maxLine);&#13;
    d.maxLineChanged = true;&#13;
    doc.iter(function(line) {&#13;
      var len = lineLength(line);&#13;
      if (len &gt; d.maxLineLength) {&#13;
        d.maxLineLength = len;&#13;
        d.maxLine = line;&#13;
      }&#13;
    });&#13;
  }&#13;
&#13;
  // Make sure the gutters options contains the element&#13;
  // "CodeMirror-linenumbers" when the lineNumbers option is true.&#13;
  function setGuttersForLineNumbers(options) {&#13;
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");&#13;
    if (found == -1 &amp;&amp; options.lineNumbers) {&#13;
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);&#13;
    } else if (found &gt; -1 &amp;&amp; !options.lineNumbers) {&#13;
      options.gutters = options.gutters.slice(0);&#13;
      options.gutters.splice(found, 1);&#13;
    }&#13;
  }&#13;
&#13;
  // SCROLLBARS&#13;
&#13;
  // Prepare DOM reads needed to update the scrollbars. Done in one&#13;
  // shot to minimize update/measure roundtrips.&#13;
  function measureForScrollbars(cm) {&#13;
    var d = cm.display, gutterW = d.gutters.offsetWidth;&#13;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));&#13;
    return {&#13;
      clientHeight: d.scroller.clientHeight,&#13;
      viewHeight: d.wrapper.clientHeight,&#13;
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,&#13;
      viewWidth: d.wrapper.clientWidth,&#13;
      barLeft: cm.options.fixedGutter ? gutterW : 0,&#13;
      docHeight: docH,&#13;
      scrollHeight: docH + scrollGap(cm) + d.barHeight,&#13;
      nativeBarWidth: d.nativeBarWidth,&#13;
      gutterWidth: gutterW&#13;
    };&#13;
  }&#13;
&#13;
  function NativeScrollbars(place, scroll, cm) {&#13;
    this.cm = cm;&#13;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");&#13;
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");&#13;
    place(vert); place(horiz);&#13;
&#13;
    on(vert, "scroll", function() {&#13;
      if (vert.clientHeight) scroll(vert.scrollTop, "vertical");&#13;
    });&#13;
    on(horiz, "scroll", function() {&#13;
      if (horiz.clientWidth) scroll(horiz.scrollLeft, "horizontal");&#13;
    });&#13;
&#13;
    this.checkedZeroWidth = false;&#13;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).&#13;
    if (ie &amp;&amp; ie_version &lt; 8) this.horiz.style.minHeight = this.vert.style.minWidth = "18px";&#13;
  }&#13;
&#13;
  NativeScrollbars.prototype = copyObj({&#13;
    update: function(measure) {&#13;
      var needsH = measure.scrollWidth &gt; measure.clientWidth + 1;&#13;
      var needsV = measure.scrollHeight &gt; measure.clientHeight + 1;&#13;
      var sWidth = measure.nativeBarWidth;&#13;
&#13;
      if (needsV) {&#13;
        this.vert.style.display = "block";&#13;
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";&#13;
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);&#13;
        // A bug in IE8 can cause this value to be negative, so guard it.&#13;
        this.vert.firstChild.style.height =&#13;
          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";&#13;
      } else {&#13;
        this.vert.style.display = "";&#13;
        this.vert.firstChild.style.height = "0";&#13;
      }&#13;
&#13;
      if (needsH) {&#13;
        this.horiz.style.display = "block";&#13;
        this.horiz.style.right = needsV ? sWidth + "px" : "0";&#13;
        this.horiz.style.left = measure.barLeft + "px";&#13;
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);&#13;
        this.horiz.firstChild.style.width =&#13;
          (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";&#13;
      } else {&#13;
        this.horiz.style.display = "";&#13;
        this.horiz.firstChild.style.width = "0";&#13;
      }&#13;
&#13;
      if (!this.checkedZeroWidth &amp;&amp; measure.clientHeight &gt; 0) {&#13;
        if (sWidth == 0) this.zeroWidthHack();&#13;
        this.checkedZeroWidth = true;&#13;
      }&#13;
&#13;
      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};&#13;
    },&#13;
    setScrollLeft: function(pos) {&#13;
      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;&#13;
      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);&#13;
    },&#13;
    setScrollTop: function(pos) {&#13;
      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;&#13;
      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);&#13;
    },&#13;
    zeroWidthHack: function() {&#13;
      var w = mac &amp;&amp; !mac_geMountainLion ? "12px" : "18px";&#13;
      this.horiz.style.height = this.vert.style.width = w;&#13;
      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";&#13;
      this.disableHoriz = new Delayed;&#13;
      this.disableVert = new Delayed;&#13;
    },&#13;
    enableZeroWidthBar: function(bar, delay) {&#13;
      bar.style.pointerEvents = "auto";&#13;
      function maybeDisable() {&#13;
        // To find out whether the scrollbar is still visible, we&#13;
        // check whether the element under the pixel in the bottom&#13;
        // left corner of the scrollbar box is the scrollbar box&#13;
        // itself (when the bar is still visible) or its filler child&#13;
        // (when the bar is hidden). If it is still visible, we keep&#13;
        // it enabled, if it's hidden, we disable pointer events.&#13;
        var box = bar.getBoundingClientRect();&#13;
        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);&#13;
        if (elt != bar) bar.style.pointerEvents = "none";&#13;
        else delay.set(1000, maybeDisable);&#13;
      }&#13;
      delay.set(1000, maybeDisable);&#13;
    },&#13;
    clear: function() {&#13;
      var parent = this.horiz.parentNode;&#13;
      parent.removeChild(this.horiz);&#13;
      parent.removeChild(this.vert);&#13;
    }&#13;
  }, NativeScrollbars.prototype);&#13;
&#13;
  function NullScrollbars() {}&#13;
&#13;
  NullScrollbars.prototype = copyObj({&#13;
    update: function() { return {bottom: 0, right: 0}; },&#13;
    setScrollLeft: function() {},&#13;
    setScrollTop: function() {},&#13;
    clear: function() {}&#13;
  }, NullScrollbars.prototype);&#13;
&#13;
  CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};&#13;
&#13;
  function initScrollbars(cm) {&#13;
    if (cm.display.scrollbars) {&#13;
      cm.display.scrollbars.clear();&#13;
      if (cm.display.scrollbars.addClass)&#13;
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);&#13;
    }&#13;
&#13;
    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {&#13;
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);&#13;
      // Prevent clicks in the scrollbars from killing focus&#13;
      on(node, "mousedown", function() {&#13;
        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);&#13;
      });&#13;
      node.setAttribute("cm-not-content", "true");&#13;
    }, function(pos, axis) {&#13;
      if (axis == "horizontal") setScrollLeft(cm, pos);&#13;
      else setScrollTop(cm, pos);&#13;
    }, cm);&#13;
    if (cm.display.scrollbars.addClass)&#13;
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);&#13;
  }&#13;
&#13;
  function updateScrollbars(cm, measure) {&#13;
    if (!measure) measure = measureForScrollbars(cm);&#13;
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;&#13;
    updateScrollbarsInner(cm, measure);&#13;
    for (var i = 0; i &lt; 4 &amp;&amp; startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {&#13;
      if (startWidth != cm.display.barWidth &amp;&amp; cm.options.lineWrapping)&#13;
        updateHeightsInViewport(cm);&#13;
      updateScrollbarsInner(cm, measureForScrollbars(cm));&#13;
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;&#13;
    }&#13;
  }&#13;
&#13;
  // Re-synchronize the fake scrollbars with the actual size of the&#13;
  // content.&#13;
  function updateScrollbarsInner(cm, measure) {&#13;
    var d = cm.display;&#13;
    var sizes = d.scrollbars.update(measure);&#13;
&#13;
    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";&#13;
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";&#13;
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent"&#13;
&#13;
    if (sizes.right &amp;&amp; sizes.bottom) {&#13;
      d.scrollbarFiller.style.display = "block";&#13;
      d.scrollbarFiller.style.height = sizes.bottom + "px";&#13;
      d.scrollbarFiller.style.width = sizes.right + "px";&#13;
    } else d.scrollbarFiller.style.display = "";&#13;
    if (sizes.bottom &amp;&amp; cm.options.coverGutterNextToScrollbar &amp;&amp; cm.options.fixedGutter) {&#13;
      d.gutterFiller.style.display = "block";&#13;
      d.gutterFiller.style.height = sizes.bottom + "px";&#13;
      d.gutterFiller.style.width = measure.gutterWidth + "px";&#13;
    } else d.gutterFiller.style.display = "";&#13;
  }&#13;
&#13;
  // Compute the lines that are visible in a given viewport (defaults&#13;
  // the the current scroll position). viewport may contain top,&#13;
  // height, and ensure (see op.scrollToPos) properties.&#13;
  function visibleLines(display, doc, viewport) {&#13;
    var top = viewport &amp;&amp; viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;&#13;
    top = Math.floor(top - paddingTop(display));&#13;
    var bottom = viewport &amp;&amp; viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;&#13;
&#13;
    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);&#13;
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and&#13;
    // forces those lines into the viewport (if possible).&#13;
    if (viewport &amp;&amp; viewport.ensure) {&#13;
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;&#13;
      if (ensureFrom &lt; from) {&#13;
        from = ensureFrom;&#13;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);&#13;
      } else if (Math.min(ensureTo, doc.lastLine()) &gt;= to) {&#13;
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);&#13;
        to = ensureTo;&#13;
      }&#13;
    }&#13;
    return {from: from, to: Math.max(to, from + 1)};&#13;
  }&#13;
&#13;
  // LINE NUMBERS&#13;
&#13;
  // Re-align line numbers and gutter marks to compensate for&#13;
  // horizontal scrolling.&#13;
  function alignHorizontally(cm) {&#13;
    var display = cm.display, view = display.view;&#13;
    if (!display.alignWidgets &amp;&amp; (!display.gutters.firstChild || !cm.options.fixedGutter)) return;&#13;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;&#13;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";&#13;
    for (var i = 0; i &lt; view.length; i++) if (!view[i].hidden) {&#13;
      if (cm.options.fixedGutter &amp;&amp; view[i].gutter)&#13;
        view[i].gutter.style.left = left;&#13;
      var align = view[i].alignable;&#13;
      if (align) for (var j = 0; j &lt; align.length; j++)&#13;
        align[j].style.left = left;&#13;
    }&#13;
    if (cm.options.fixedGutter)&#13;
      display.gutters.style.left = (comp + gutterW) + "px";&#13;
  }&#13;
&#13;
  // Used to ensure that the line number gutter is still the right&#13;
  // size for the current document size. Returns true when an update&#13;
  // is needed.&#13;
  function maybeUpdateLineNumberWidth(cm) {&#13;
    if (!cm.options.lineNumbers) return false;&#13;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;&#13;
    if (last.length != display.lineNumChars) {&#13;
      var test = display.measure.appendChild(elt("div", [elt("div", last)],&#13;
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));&#13;
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;&#13;
      display.lineGutter.style.width = "";&#13;
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;&#13;
      display.lineNumWidth = display.lineNumInnerWidth + padding;&#13;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;&#13;
      display.lineGutter.style.width = display.lineNumWidth + "px";&#13;
      updateGutterSpace(cm);&#13;
      return true;&#13;
    }&#13;
    return false;&#13;
  }&#13;
&#13;
  function lineNumberFor(options, i) {&#13;
    return String(options.lineNumberFormatter(i + options.firstLineNumber));&#13;
  }&#13;
&#13;
  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,&#13;
  // but using getBoundingClientRect to get a sub-pixel-accurate&#13;
  // result.&#13;
  function compensateForHScroll(display) {&#13;
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;&#13;
  }&#13;
&#13;
  // DISPLAY DRAWING&#13;
&#13;
  function DisplayUpdate(cm, viewport, force) {&#13;
    var display = cm.display;&#13;
&#13;
    this.viewport = viewport;&#13;
    // Store some values that we'll need later (but don't want to force a relayout for)&#13;
    this.visible = visibleLines(display, cm.doc, viewport);&#13;
    this.editorIsHidden = !display.wrapper.offsetWidth;&#13;
    this.wrapperHeight = display.wrapper.clientHeight;&#13;
    this.wrapperWidth = display.wrapper.clientWidth;&#13;
    this.oldDisplayWidth = displayWidth(cm);&#13;
    this.force = force;&#13;
    this.dims = getDimensions(cm);&#13;
    this.events = [];&#13;
  }&#13;
&#13;
  DisplayUpdate.prototype.signal = function(emitter, type) {&#13;
    if (hasHandler(emitter, type))&#13;
      this.events.push(arguments);&#13;
  };&#13;
  DisplayUpdate.prototype.finish = function() {&#13;
    for (var i = 0; i &lt; this.events.length; i++)&#13;
      signal.apply(null, this.events[i]);&#13;
  };&#13;
&#13;
  function maybeClipScrollbars(cm) {&#13;
    var display = cm.display;&#13;
    if (!display.scrollbarsClipped &amp;&amp; display.scroller.offsetWidth) {&#13;
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;&#13;
      display.heightForcer.style.height = scrollGap(cm) + "px";&#13;
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";&#13;
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";&#13;
      display.scrollbarsClipped = true;&#13;
    }&#13;
  }&#13;
&#13;
  // Does the actual updating of the line display. Bails out&#13;
  // (returning false) when there is nothing to be done and forced is&#13;
  // false.&#13;
  function updateDisplayIfNeeded(cm, update) {&#13;
    var display = cm.display, doc = cm.doc;&#13;
&#13;
    if (update.editorIsHidden) {&#13;
      resetView(cm);&#13;
      return false;&#13;
    }&#13;
&#13;
    // Bail out if the visible area is already rendered and nothing changed.&#13;
    if (!update.force &amp;&amp;&#13;
        update.visible.from &gt;= display.viewFrom &amp;&amp; update.visible.to &lt;= display.viewTo &amp;&amp;&#13;
        (display.updateLineNumbers == null || display.updateLineNumbers &gt;= display.viewTo) &amp;&amp;&#13;
        display.renderedView == display.view &amp;&amp; countDirtyView(cm) == 0)&#13;
      return false;&#13;
&#13;
    if (maybeUpdateLineNumberWidth(cm)) {&#13;
      resetView(cm);&#13;
      update.dims = getDimensions(cm);&#13;
    }&#13;
&#13;
    // Compute a suitable new viewport (from &amp; to)&#13;
    var end = doc.first + doc.size;&#13;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);&#13;
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);&#13;
    if (display.viewFrom &lt; from &amp;&amp; from - display.viewFrom &lt; 20) from = Math.max(doc.first, display.viewFrom);&#13;
    if (display.viewTo &gt; to &amp;&amp; display.viewTo - to &lt; 20) to = Math.min(end, display.viewTo);&#13;
    if (sawCollapsedSpans) {&#13;
      from = visualLineNo(cm.doc, from);&#13;
      to = visualLineEndNo(cm.doc, to);&#13;
    }&#13;
&#13;
    var different = from != display.viewFrom || to != display.viewTo ||&#13;
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;&#13;
    adjustView(cm, from, to);&#13;
&#13;
    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));&#13;
    // Position the mover div to align with the current scroll position&#13;
    cm.display.mover.style.top = display.viewOffset + "px";&#13;
&#13;
    var toUpdate = countDirtyView(cm);&#13;
    if (!different &amp;&amp; toUpdate == 0 &amp;&amp; !update.force &amp;&amp; display.renderedView == display.view &amp;&amp;&#13;
        (display.updateLineNumbers == null || display.updateLineNumbers &gt;= display.viewTo))&#13;
      return false;&#13;
&#13;
    // For big changes, we hide the enclosing element during the&#13;
    // update, since that speeds up the operations on most browsers.&#13;
    var focused = activeElt();&#13;
    if (toUpdate &gt; 4) display.lineDiv.style.display = "none";&#13;
    patchDisplay(cm, display.updateLineNumbers, update.dims);&#13;
    if (toUpdate &gt; 4) display.lineDiv.style.display = "";&#13;
    display.renderedView = display.view;&#13;
    // There might have been a widget with a focused element that got&#13;
    // hidden or updated, if so re-focus it.&#13;
    if (focused &amp;&amp; activeElt() != focused &amp;&amp; focused.offsetHeight) focused.focus();&#13;
&#13;
    // Prevent selection and cursors from interfering with the scroll&#13;
    // width and height.&#13;
    removeChildren(display.cursorDiv);&#13;
    removeChildren(display.selectionDiv);&#13;
    display.gutters.style.height = display.sizer.style.minHeight = 0;&#13;
&#13;
    if (different) {&#13;
      display.lastWrapHeight = update.wrapperHeight;&#13;
      display.lastWrapWidth = update.wrapperWidth;&#13;
      startWorker(cm, 400);&#13;
    }&#13;
&#13;
    display.updateLineNumbers = null;&#13;
&#13;
    return true;&#13;
  }&#13;
&#13;
  function postUpdateDisplay(cm, update) {&#13;
    var viewport = update.viewport;&#13;
&#13;
    for (var first = true;; first = false) {&#13;
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {&#13;
        // Clip forced viewport to actual scrollable area.&#13;
        if (viewport &amp;&amp; viewport.top != null)&#13;
          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};&#13;
        // Updated line heights might result in the drawn area not&#13;
        // actually covering the viewport. Keep looping until it does.&#13;
        update.visible = visibleLines(cm.display, cm.doc, viewport);&#13;
        if (update.visible.from &gt;= cm.display.viewFrom &amp;&amp; update.visible.to &lt;= cm.display.viewTo)&#13;
          break;&#13;
      }&#13;
      if (!updateDisplayIfNeeded(cm, update)) break;&#13;
      updateHeightsInViewport(cm);&#13;
      var barMeasure = measureForScrollbars(cm);&#13;
      updateSelection(cm);&#13;
      updateScrollbars(cm, barMeasure);&#13;
      setDocumentHeight(cm, barMeasure);&#13;
    }&#13;
&#13;
    update.signal(cm, "update", cm);&#13;
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {&#13;
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);&#13;
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;&#13;
    }&#13;
  }&#13;
&#13;
  function updateDisplaySimple(cm, viewport) {&#13;
    var update = new DisplayUpdate(cm, viewport);&#13;
    if (updateDisplayIfNeeded(cm, update)) {&#13;
      updateHeightsInViewport(cm);&#13;
      postUpdateDisplay(cm, update);&#13;
      var barMeasure = measureForScrollbars(cm);&#13;
      updateSelection(cm);&#13;
      updateScrollbars(cm, barMeasure);&#13;
      setDocumentHeight(cm, barMeasure);&#13;
      update.finish();&#13;
    }&#13;
  }&#13;
&#13;
  function setDocumentHeight(cm, measure) {&#13;
    cm.display.sizer.style.minHeight = measure.docHeight + "px";&#13;
    cm.display.heightForcer.style.top = measure.docHeight + "px";&#13;
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";&#13;
  }&#13;
&#13;
  // Read the actual heights of the rendered lines, and update their&#13;
  // stored heights to match.&#13;
  function updateHeightsInViewport(cm) {&#13;
    var display = cm.display;&#13;
    var prevBottom = display.lineDiv.offsetTop;&#13;
    for (var i = 0; i &lt; display.view.length; i++) {&#13;
      var cur = display.view[i], height;&#13;
      if (cur.hidden) continue;&#13;
      if (ie &amp;&amp; ie_version &lt; 8) {&#13;
        var bot = cur.node.offsetTop + cur.node.offsetHeight;&#13;
        height = bot - prevBottom;&#13;
        prevBottom = bot;&#13;
      } else {&#13;
        var box = cur.node.getBoundingClientRect();&#13;
        height = box.bottom - box.top;&#13;
      }&#13;
      var diff = cur.line.height - height;&#13;
      if (height &lt; 2) height = textHeight(display);&#13;
      if (diff &gt; .001 || diff &lt; -.001) {&#13;
        updateLineHeight(cur.line, height);&#13;
        updateWidgetHeight(cur.line);&#13;
        if (cur.rest) for (var j = 0; j &lt; cur.rest.length; j++)&#13;
          updateWidgetHeight(cur.rest[j]);&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  // Read and store the height of line widgets associated with the&#13;
  // given line.&#13;
  function updateWidgetHeight(line) {&#13;
    if (line.widgets) for (var i = 0; i &lt; line.widgets.length; ++i)&#13;
      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;&#13;
  }&#13;
&#13;
  // Do a bulk-read of the DOM positions and sizes needed to draw the&#13;
  // view, so that we don't interleave reading and writing to the DOM.&#13;
  function getDimensions(cm) {&#13;
    var d = cm.display, left = {}, width = {};&#13;
    var gutterLeft = d.gutters.clientLeft;&#13;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {&#13;
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;&#13;
      width[cm.options.gutters[i]] = n.clientWidth;&#13;
    }&#13;
    return {fixedPos: compensateForHScroll(d),&#13;
            gutterTotalWidth: d.gutters.offsetWidth,&#13;
            gutterLeft: left,&#13;
            gutterWidth: width,&#13;
            wrapperWidth: d.wrapper.clientWidth};&#13;
  }&#13;
&#13;
  // Sync the actual display DOM structure with display.view, removing&#13;
  // nodes for lines that are no longer in view, and creating the ones&#13;
  // that are not there yet, and updating the ones that are out of&#13;
  // date.&#13;
  function patchDisplay(cm, updateNumbersFrom, dims) {&#13;
    var display = cm.display, lineNumbers = cm.options.lineNumbers;&#13;
    var container = display.lineDiv, cur = container.firstChild;&#13;
&#13;
    function rm(node) {&#13;
      var next = node.nextSibling;&#13;
      // Works around a throw-scroll bug in OS X Webkit&#13;
      if (webkit &amp;&amp; mac &amp;&amp; cm.display.currentWheelTarget == node)&#13;
        node.style.display = "none";&#13;
      else&#13;
        node.parentNode.removeChild(node);&#13;
      return next;&#13;
    }&#13;
&#13;
    var view = display.view, lineN = display.viewFrom;&#13;
    // Loop over the elements in the view, syncing cur (the DOM nodes&#13;
    // in display.lineDiv) with the view as we go.&#13;
    for (var i = 0; i &lt; view.length; i++) {&#13;
      var lineView = view[i];&#13;
      if (lineView.hidden) {&#13;
      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet&#13;
        var node = buildLineElement(cm, lineView, lineN, dims);&#13;
        container.insertBefore(node, cur);&#13;
      } else { // Already drawn&#13;
        while (cur != lineView.node) cur = rm(cur);&#13;
        var updateNumber = lineNumbers &amp;&amp; updateNumbersFrom != null &amp;&amp;&#13;
          updateNumbersFrom &lt;= lineN &amp;&amp; lineView.lineNumber;&#13;
        if (lineView.changes) {&#13;
          if (indexOf(lineView.changes, "gutter") &gt; -1) updateNumber = false;&#13;
          updateLineForChanges(cm, lineView, lineN, dims);&#13;
        }&#13;
        if (updateNumber) {&#13;
          removeChildren(lineView.lineNumber);&#13;
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));&#13;
        }&#13;
        cur = lineView.node.nextSibling;&#13;
      }&#13;
      lineN += lineView.size;&#13;
    }&#13;
    while (cur) cur = rm(cur);&#13;
  }&#13;
&#13;
  // When an aspect of a line changes, a string is added to&#13;
  // lineView.changes. This updates the relevant part of the line's&#13;
  // DOM structure.&#13;
  function updateLineForChanges(cm, lineView, lineN, dims) {&#13;
    for (var j = 0; j &lt; lineView.changes.length; j++) {&#13;
      var type = lineView.changes[j];&#13;
      if (type == "text") updateLineText(cm, lineView);&#13;
      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);&#13;
      else if (type == "class") updateLineClasses(lineView);&#13;
      else if (type == "widget") updateLineWidgets(cm, lineView, dims);&#13;
    }&#13;
    lineView.changes = null;&#13;
  }&#13;
&#13;
  // Lines with gutter elements, widgets or a background class need to&#13;
  // be wrapped, and have the extra elements added to the wrapper div&#13;
  function ensureLineWrapped(lineView) {&#13;
    if (lineView.node == lineView.text) {&#13;
      lineView.node = elt("div", null, null, "position: relative");&#13;
      if (lineView.text.parentNode)&#13;
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);&#13;
      lineView.node.appendChild(lineView.text);&#13;
      if (ie &amp;&amp; ie_version &lt; 8) lineView.node.style.zIndex = 2;&#13;
    }&#13;
    return lineView.node;&#13;
  }&#13;
&#13;
  function updateLineBackground(lineView) {&#13;
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;&#13;
    if (cls) cls += " CodeMirror-linebackground";&#13;
    if (lineView.background) {&#13;
      if (cls) lineView.background.className = cls;&#13;
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }&#13;
    } else if (cls) {&#13;
      var wrap = ensureLineWrapped(lineView);&#13;
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);&#13;
    }&#13;
  }&#13;
&#13;
  // Wrapper around buildLineContent which will reuse the structure&#13;
  // in display.externalMeasured when possible.&#13;
  function getLineContent(cm, lineView) {&#13;
    var ext = cm.display.externalMeasured;&#13;
    if (ext &amp;&amp; ext.line == lineView.line) {&#13;
      cm.display.externalMeasured = null;&#13;
      lineView.measure = ext.measure;&#13;
      return ext.built;&#13;
    }&#13;
    return buildLineContent(cm, lineView);&#13;
  }&#13;
&#13;
  // Redraw the line's text. Interacts with the background and text&#13;
  // classes because the mode may output tokens that influence these&#13;
  // classes.&#13;
  function updateLineText(cm, lineView) {&#13;
    var cls = lineView.text.className;&#13;
    var built = getLineContent(cm, lineView);&#13;
    if (lineView.text == lineView.node) lineView.node = built.pre;&#13;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);&#13;
    lineView.text = built.pre;&#13;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {&#13;
      lineView.bgClass = built.bgClass;&#13;
      lineView.textClass = built.textClass;&#13;
      updateLineClasses(lineView);&#13;
    } else if (cls) {&#13;
      lineView.text.className = cls;&#13;
    }&#13;
  }&#13;
&#13;
  function updateLineClasses(lineView) {&#13;
    updateLineBackground(lineView);&#13;
    if (lineView.line.wrapClass)&#13;
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;&#13;
    else if (lineView.node != lineView.text)&#13;
      lineView.node.className = "";&#13;
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;&#13;
    lineView.text.className = textClass || "";&#13;
  }&#13;
&#13;
  function updateLineGutter(cm, lineView, lineN, dims) {&#13;
    if (lineView.gutter) {&#13;
      lineView.node.removeChild(lineView.gutter);&#13;
      lineView.gutter = null;&#13;
    }&#13;
    if (lineView.gutterBackground) {&#13;
      lineView.node.removeChild(lineView.gutterBackground);&#13;
      lineView.gutterBackground = null;&#13;
    }&#13;
    if (lineView.line.gutterClass) {&#13;
      var wrap = ensureLineWrapped(lineView);&#13;
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,&#13;
                                      "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +&#13;
                                      "px; width: " + dims.gutterTotalWidth + "px");&#13;
      wrap.insertBefore(lineView.gutterBackground, lineView.text);&#13;
    }&#13;
    var markers = lineView.line.gutterMarkers;&#13;
    if (cm.options.lineNumbers || markers) {&#13;
      var wrap = ensureLineWrapped(lineView);&#13;
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " +&#13;
                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");&#13;
      cm.display.input.setUneditable(gutterWrap);&#13;
      wrap.insertBefore(gutterWrap, lineView.text);&#13;
      if (lineView.line.gutterClass)&#13;
        gutterWrap.className += " " + lineView.line.gutterClass;&#13;
      if (cm.options.lineNumbers &amp;&amp; (!markers || !markers["CodeMirror-linenumbers"]))&#13;
        lineView.lineNumber = gutterWrap.appendChild(&#13;
          elt("div", lineNumberFor(cm.options, lineN),&#13;
              "CodeMirror-linenumber CodeMirror-gutter-elt",&#13;
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "&#13;
              + cm.display.lineNumInnerWidth + "px"));&#13;
      if (markers) for (var k = 0; k &lt; cm.options.gutters.length; ++k) {&#13;
        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) &amp;&amp; markers[id];&#13;
        if (found)&#13;
          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +&#13;
                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function updateLineWidgets(cm, lineView, dims) {&#13;
    if (lineView.alignable) lineView.alignable = null;&#13;
    for (var node = lineView.node.firstChild, next; node; node = next) {&#13;
      var next = node.nextSibling;&#13;
      if (node.className == "CodeMirror-linewidget")&#13;
        lineView.node.removeChild(node);&#13;
    }&#13;
    insertLineWidgets(cm, lineView, dims);&#13;
  }&#13;
&#13;
  // Build a line's DOM representation from scratch&#13;
  function buildLineElement(cm, lineView, lineN, dims) {&#13;
    var built = getLineContent(cm, lineView);&#13;
    lineView.text = lineView.node = built.pre;&#13;
    if (built.bgClass) lineView.bgClass = built.bgClass;&#13;
    if (built.textClass) lineView.textClass = built.textClass;&#13;
&#13;
    updateLineClasses(lineView);&#13;
    updateLineGutter(cm, lineView, lineN, dims);&#13;
    insertLineWidgets(cm, lineView, dims);&#13;
    return lineView.node;&#13;
  }&#13;
&#13;
  // A lineView may contain multiple logical lines (when merged by&#13;
  // collapsed spans). The widgets for all of them need to be drawn.&#13;
  function insertLineWidgets(cm, lineView, dims) {&#13;
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);&#13;
    if (lineView.rest) for (var i = 0; i &lt; lineView.rest.length; i++)&#13;
      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);&#13;
  }&#13;
&#13;
  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {&#13;
    if (!line.widgets) return;&#13;
    var wrap = ensureLineWrapped(lineView);&#13;
    for (var i = 0, ws = line.widgets; i &lt; ws.length; ++i) {&#13;
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");&#13;
      if (!widget.handleMouseEvents) node.setAttribute("cm-ignore-events", "true");&#13;
      positionLineWidget(widget, node, lineView, dims);&#13;
      cm.display.input.setUneditable(node);&#13;
      if (allowAbove &amp;&amp; widget.above)&#13;
        wrap.insertBefore(node, lineView.gutter || lineView.text);&#13;
      else&#13;
        wrap.appendChild(node);&#13;
      signalLater(widget, "redraw");&#13;
    }&#13;
  }&#13;
&#13;
  function positionLineWidget(widget, node, lineView, dims) {&#13;
    if (widget.noHScroll) {&#13;
      (lineView.alignable || (lineView.alignable = [])).push(node);&#13;
      var width = dims.wrapperWidth;&#13;
      node.style.left = dims.fixedPos + "px";&#13;
      if (!widget.coverGutter) {&#13;
        width -= dims.gutterTotalWidth;&#13;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";&#13;
      }&#13;
      node.style.width = width + "px";&#13;
    }&#13;
    if (widget.coverGutter) {&#13;
      node.style.zIndex = 5;&#13;
      node.style.position = "relative";&#13;
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";&#13;
    }&#13;
  }&#13;
&#13;
  // POSITION OBJECT&#13;
&#13;
  // A Pos instance represents a position within the text.&#13;
  var Pos = CodeMirror.Pos = function(line, ch) {&#13;
    if (!(this instanceof Pos)) return new Pos(line, ch);&#13;
    this.line = line; this.ch = ch;&#13;
  };&#13;
&#13;
  // Compare two positions, return 0 if they are the same, a negative&#13;
  // number when a is less, and a positive number otherwise.&#13;
  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };&#13;
&#13;
  function copyPos(x) {return Pos(x.line, x.ch);}&#13;
  function maxPos(a, b) { return cmp(a, b) &lt; 0 ? b : a; }&#13;
  function minPos(a, b) { return cmp(a, b) &lt; 0 ? a : b; }&#13;
&#13;
  // INPUT HANDLING&#13;
&#13;
  function ensureFocus(cm) {&#13;
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }&#13;
  }&#13;
&#13;
  // This will be set to a {lineWise: bool, text: [string]} object, so&#13;
  // that, when pasting, we know what kind of selections the copied&#13;
  // text was made out of.&#13;
  var lastCopied = null;&#13;
&#13;
  function applyTextInput(cm, inserted, deleted, sel, origin) {&#13;
    var doc = cm.doc;&#13;
    cm.display.shift = false;&#13;
    if (!sel) sel = doc.sel;&#13;
&#13;
    var paste = cm.state.pasteIncoming || origin == "paste";&#13;
    var textLines = doc.splitLines(inserted), multiPaste = null&#13;
    // When pasing N lines into N selections, insert one line per selection&#13;
    if (paste &amp;&amp; sel.ranges.length &gt; 1) {&#13;
      if (lastCopied &amp;&amp; lastCopied.text.join("\n") == inserted) {&#13;
        if (sel.ranges.length % lastCopied.text.length == 0) {&#13;
          multiPaste = [];&#13;
          for (var i = 0; i &lt; lastCopied.text.length; i++)&#13;
            multiPaste.push(doc.splitLines(lastCopied.text[i]));&#13;
        }&#13;
      } else if (textLines.length == sel.ranges.length) {&#13;
        multiPaste = map(textLines, function(l) { return [l]; });&#13;
      }&#13;
    }&#13;
&#13;
    // Normal behavior is to insert the new text into every selection&#13;
    for (var i = sel.ranges.length - 1; i &gt;= 0; i--) {&#13;
      var range = sel.ranges[i];&#13;
      var from = range.from(), to = range.to();&#13;
      if (range.empty()) {&#13;
        if (deleted &amp;&amp; deleted &gt; 0) // Handle deletion&#13;
          from = Pos(from.line, from.ch - deleted);&#13;
        else if (cm.state.overwrite &amp;&amp; !paste) // Handle overwrite&#13;
          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));&#13;
        else if (lastCopied &amp;&amp; lastCopied.lineWise &amp;&amp; lastCopied.text.join("\n") == inserted)&#13;
          from = to = Pos(from.line, 0)&#13;
      }&#13;
      var updateInput = cm.curOp.updateInput;&#13;
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,&#13;
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};&#13;
      makeChange(cm.doc, changeEvent);&#13;
      signalLater(cm, "inputRead", cm, changeEvent);&#13;
    }&#13;
    if (inserted &amp;&amp; !paste)&#13;
      triggerElectric(cm, inserted);&#13;
&#13;
    ensureCursorVisible(cm);&#13;
    cm.curOp.updateInput = updateInput;&#13;
    cm.curOp.typing = true;&#13;
    cm.state.pasteIncoming = cm.state.cutIncoming = false;&#13;
  }&#13;
&#13;
  function handlePaste(e, cm) {&#13;
    var pasted = e.clipboardData &amp;&amp; e.clipboardData.getData("text/plain");&#13;
    if (pasted) {&#13;
      e.preventDefault();&#13;
      if (!cm.isReadOnly() &amp;&amp; !cm.options.disableInput)&#13;
        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, "paste"); });&#13;
      return true;&#13;
    }&#13;
  }&#13;
&#13;
  function triggerElectric(cm, inserted) {&#13;
    // When an 'electric' character is inserted, immediately trigger a reindent&#13;
    if (!cm.options.electricChars || !cm.options.smartIndent) return;&#13;
    var sel = cm.doc.sel;&#13;
&#13;
    for (var i = sel.ranges.length - 1; i &gt;= 0; i--) {&#13;
      var range = sel.ranges[i];&#13;
      if (range.head.ch &gt; 100 || (i &amp;&amp; sel.ranges[i - 1].head.line == range.head.line)) continue;&#13;
      var mode = cm.getModeAt(range.head);&#13;
      var indented = false;&#13;
      if (mode.electricChars) {&#13;
        for (var j = 0; j &lt; mode.electricChars.length; j++)&#13;
          if (inserted.indexOf(mode.electricChars.charAt(j)) &gt; -1) {&#13;
            indented = indentLine(cm, range.head.line, "smart");&#13;
            break;&#13;
          }&#13;
      } else if (mode.electricInput) {&#13;
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))&#13;
          indented = indentLine(cm, range.head.line, "smart");&#13;
      }&#13;
      if (indented) signalLater(cm, "electricInput", cm, range.head.line);&#13;
    }&#13;
  }&#13;
&#13;
  function copyableRanges(cm) {&#13;
    var text = [], ranges = [];&#13;
    for (var i = 0; i &lt; cm.doc.sel.ranges.length; i++) {&#13;
      var line = cm.doc.sel.ranges[i].head.line;&#13;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};&#13;
      ranges.push(lineRange);&#13;
      text.push(cm.getRange(lineRange.anchor, lineRange.head));&#13;
    }&#13;
    return {text: text, ranges: ranges};&#13;
  }&#13;
&#13;
  function disableBrowserMagic(field) {&#13;
    field.setAttribute("autocorrect", "off");&#13;
    field.setAttribute("autocapitalize", "off");&#13;
    field.setAttribute("spellcheck", "false");&#13;
  }&#13;
&#13;
  // TEXTAREA INPUT STYLE&#13;
&#13;
  function TextareaInput(cm) {&#13;
    this.cm = cm;&#13;
    // See input.poll and input.reset&#13;
    this.prevInput = "";&#13;
&#13;
    // Flag that indicates whether we expect input to appear real soon&#13;
    // now (after some event like 'keypress' or 'input') and are&#13;
    // polling intensively.&#13;
    this.pollingFast = false;&#13;
    // Self-resetting timeout for the poller&#13;
    this.polling = new Delayed();&#13;
    // Tracks when input.reset has punted to just putting a short&#13;
    // string into the textarea instead of the full selection.&#13;
    this.inaccurateSelection = false;&#13;
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea&#13;
    this.hasSelection = false;&#13;
    this.composing = null;&#13;
  };&#13;
&#13;
  function hiddenTextarea() {&#13;
    var te = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");&#13;
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");&#13;
    // The textarea is kept positioned near the cursor to prevent the&#13;
    // fact that it'll be scrolled into view on input from scrolling&#13;
    // our fake cursor out of view. On webkit, when wrap=off, paste is&#13;
    // very slow. So make the area wide instead.&#13;
    if (webkit) te.style.width = "1000px";&#13;
    else te.setAttribute("wrap", "off");&#13;
    // If border: 0; -- iOS fails to open keyboard (issue #1287)&#13;
    if (ios) te.style.border = "1px solid black";&#13;
    disableBrowserMagic(te);&#13;
    return div;&#13;
  }&#13;
&#13;
  TextareaInput.prototype = copyObj({&#13;
    init: function(display) {&#13;
      var input = this, cm = this.cm;&#13;
&#13;
      // Wraps and hides input textarea&#13;
      var div = this.wrapper = hiddenTextarea();&#13;
      // The semihidden textarea that is focused when the editor is&#13;
      // focused, and receives input.&#13;
      var te = this.textarea = div.firstChild;&#13;
      display.wrapper.insertBefore(div, display.wrapper.firstChild);&#13;
&#13;
      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)&#13;
      if (ios) te.style.width = "0px";&#13;
&#13;
      on(te, "input", function() {&#13;
        if (ie &amp;&amp; ie_version &gt;= 9 &amp;&amp; input.hasSelection) input.hasSelection = null;&#13;
        input.poll();&#13;
      });&#13;
&#13;
      on(te, "paste", function(e) {&#13;
        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return&#13;
&#13;
        cm.state.pasteIncoming = true;&#13;
        input.fastPoll();&#13;
      });&#13;
&#13;
      function prepareCopyCut(e) {&#13;
        if (signalDOMEvent(cm, e)) return&#13;
        if (cm.somethingSelected()) {&#13;
          lastCopied = {lineWise: false, text: cm.getSelections()};&#13;
          if (input.inaccurateSelection) {&#13;
            input.prevInput = "";&#13;
            input.inaccurateSelection = false;&#13;
            te.value = lastCopied.text.join("\n");&#13;
            selectInput(te);&#13;
          }&#13;
        } else if (!cm.options.lineWiseCopyCut) {&#13;
          return;&#13;
        } else {&#13;
          var ranges = copyableRanges(cm);&#13;
          lastCopied = {lineWise: true, text: ranges.text};&#13;
          if (e.type == "cut") {&#13;
            cm.setSelections(ranges.ranges, null, sel_dontScroll);&#13;
          } else {&#13;
            input.prevInput = "";&#13;
            te.value = ranges.text.join("\n");&#13;
            selectInput(te);&#13;
          }&#13;
        }&#13;
        if (e.type == "cut") cm.state.cutIncoming = true;&#13;
      }&#13;
      on(te, "cut", prepareCopyCut);&#13;
      on(te, "copy", prepareCopyCut);&#13;
&#13;
      on(display.scroller, "paste", function(e) {&#13;
        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;&#13;
        cm.state.pasteIncoming = true;&#13;
        input.focus();&#13;
      });&#13;
&#13;
      // Prevent normal selection in the editor (we handle our own)&#13;
      on(display.lineSpace, "selectstart", function(e) {&#13;
        if (!eventInWidget(display, e)) e_preventDefault(e);&#13;
      });&#13;
&#13;
      on(te, "compositionstart", function() {&#13;
        var start = cm.getCursor("from");&#13;
        if (input.composing) input.composing.range.clear()&#13;
        input.composing = {&#13;
          start: start,&#13;
          range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})&#13;
        };&#13;
      });&#13;
      on(te, "compositionend", function() {&#13;
        if (input.composing) {&#13;
          input.poll();&#13;
          input.composing.range.clear();&#13;
          input.composing = null;&#13;
        }&#13;
      });&#13;
    },&#13;
&#13;
    prepareSelection: function() {&#13;
      // Redraw the selection and/or cursor&#13;
      var cm = this.cm, display = cm.display, doc = cm.doc;&#13;
      var result = prepareSelection(cm);&#13;
&#13;
      // Move the hidden textarea near the cursor to prevent scrolling artifacts&#13;
      if (cm.options.moveInputWithCursor) {&#13;
        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");&#13;
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();&#13;
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,&#13;
                                            headPos.top + lineOff.top - wrapOff.top));&#13;
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,&#13;
                                             headPos.left + lineOff.left - wrapOff.left));&#13;
      }&#13;
&#13;
      return result;&#13;
    },&#13;
&#13;
    showSelection: function(drawn) {&#13;
      var cm = this.cm, display = cm.display;&#13;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);&#13;
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);&#13;
      if (drawn.teTop != null) {&#13;
        this.wrapper.style.top = drawn.teTop + "px";&#13;
        this.wrapper.style.left = drawn.teLeft + "px";&#13;
      }&#13;
    },&#13;
&#13;
    // Reset the input to correspond to the selection (or to be empty,&#13;
    // when not typing and nothing is selected)&#13;
    reset: function(typing) {&#13;
      if (this.contextMenuPending) return;&#13;
      var minimal, selected, cm = this.cm, doc = cm.doc;&#13;
      if (cm.somethingSelected()) {&#13;
        this.prevInput = "";&#13;
        var range = doc.sel.primary();&#13;
        minimal = hasCopyEvent &amp;&amp;&#13;
          (range.to().line - range.from().line &gt; 100 || (selected = cm.getSelection()).length &gt; 1000);&#13;
        var content = minimal ? "-" : selected || cm.getSelection();&#13;
        this.textarea.value = content;&#13;
        if (cm.state.focused) selectInput(this.textarea);&#13;
        if (ie &amp;&amp; ie_version &gt;= 9) this.hasSelection = content;&#13;
      } else if (!typing) {&#13;
        this.prevInput = this.textarea.value = "";&#13;
        if (ie &amp;&amp; ie_version &gt;= 9) this.hasSelection = null;&#13;
      }&#13;
      this.inaccurateSelection = minimal;&#13;
    },&#13;
&#13;
    getField: function() { return this.textarea; },&#13;
&#13;
    supportsTouch: function() { return false; },&#13;
&#13;
    focus: function() {&#13;
      if (this.cm.options.readOnly != "nocursor" &amp;&amp; (!mobile || activeElt() != this.textarea)) {&#13;
        try { this.textarea.focus(); }&#13;
        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM&#13;
      }&#13;
    },&#13;
&#13;
    blur: function() { this.textarea.blur(); },&#13;
&#13;
    resetPosition: function() {&#13;
      this.wrapper.style.top = this.wrapper.style.left = 0;&#13;
    },&#13;
&#13;
    receivedFocus: function() { this.slowPoll(); },&#13;
&#13;
    // Poll for input changes, using the normal rate of polling. This&#13;
    // runs as long as the editor is focused.&#13;
    slowPoll: function() {&#13;
      var input = this;&#13;
      if (input.pollingFast) return;&#13;
      input.polling.set(this.cm.options.pollInterval, function() {&#13;
        input.poll();&#13;
        if (input.cm.state.focused) input.slowPoll();&#13;
      });&#13;
    },&#13;
&#13;
    // When an event has just come in that is likely to add or change&#13;
    // something in the input textarea, we poll faster, to ensure that&#13;
    // the change appears on the screen quickly.&#13;
    fastPoll: function() {&#13;
      var missed = false, input = this;&#13;
      input.pollingFast = true;&#13;
      function p() {&#13;
        var changed = input.poll();&#13;
        if (!changed &amp;&amp; !missed) {missed = true; input.polling.set(60, p);}&#13;
        else {input.pollingFast = false; input.slowPoll();}&#13;
      }&#13;
      input.polling.set(20, p);&#13;
    },&#13;
&#13;
    // Read input from the textarea, and update the document to match.&#13;
    // When something is selected, it is present in the textarea, and&#13;
    // selected (unless it is huge, in which case a placeholder is&#13;
    // used). When nothing is selected, the cursor sits after previously&#13;
    // seen text (can be empty), which is stored in prevInput (we must&#13;
    // not reset the textarea when typing, because that breaks IME).&#13;
    poll: function() {&#13;
      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;&#13;
      // Since this is called a *lot*, try to bail out as cheaply as&#13;
      // possible when it is clear that nothing happened. hasSelection&#13;
      // will be the case when there is a lot of text in the textarea,&#13;
      // in which case reading its value would be expensive.&#13;
      if (this.contextMenuPending || !cm.state.focused ||&#13;
          (hasSelection(input) &amp;&amp; !prevInput &amp;&amp; !this.composing) ||&#13;
          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)&#13;
        return false;&#13;
&#13;
      var text = input.value;&#13;
      // If nothing changed, bail.&#13;
      if (text == prevInput &amp;&amp; !cm.somethingSelected()) return false;&#13;
      // Work around nonsensical selection resetting in IE9/10, and&#13;
      // inexplicable appearance of private area unicode characters on&#13;
      // some key combos in Mac (#2689).&#13;
      if (ie &amp;&amp; ie_version &gt;= 9 &amp;&amp; this.hasSelection === text ||&#13;
          mac &amp;&amp; /[\uf700-\uf7ff]/.test(text)) {&#13;
        cm.display.input.reset();&#13;
        return false;&#13;
      }&#13;
&#13;
      if (cm.doc.sel == cm.display.selForContextMenu) {&#13;
        var first = text.charCodeAt(0);&#13;
        if (first == 0x200b &amp;&amp; !prevInput) prevInput = "\u200b";&#13;
        if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo"); }&#13;
      }&#13;
      // Find the part of the input that is actually new&#13;
      var same = 0, l = Math.min(prevInput.length, text.length);&#13;
      while (same &lt; l &amp;&amp; prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;&#13;
&#13;
      var self = this;&#13;
      runInOp(cm, function() {&#13;
        applyTextInput(cm, text.slice(same), prevInput.length - same,&#13;
                       null, self.composing ? "*compose" : null);&#13;
&#13;
        // Don't leave long text in the textarea, since it makes further polling slow&#13;
        if (text.length &gt; 1000 || text.indexOf("\n") &gt; -1) input.value = self.prevInput = "";&#13;
        else self.prevInput = text;&#13;
&#13;
        if (self.composing) {&#13;
          self.composing.range.clear();&#13;
          self.composing.range = cm.markText(self.composing.start, cm.getCursor("to"),&#13;
                                             {className: "CodeMirror-composing"});&#13;
        }&#13;
      });&#13;
      return true;&#13;
    },&#13;
&#13;
    ensurePolled: function() {&#13;
      if (this.pollingFast &amp;&amp; this.poll()) this.pollingFast = false;&#13;
    },&#13;
&#13;
    onKeyPress: function() {&#13;
      if (ie &amp;&amp; ie_version &gt;= 9) this.hasSelection = null;&#13;
      this.fastPoll();&#13;
    },&#13;
&#13;
    onContextMenu: function(e) {&#13;
      var input = this, cm = input.cm, display = cm.display, te = input.textarea;&#13;
      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;&#13;
      if (!pos || presto) return; // Opera is difficult.&#13;
&#13;
      // Reset the current text selection only if the click is done outside of the selection&#13;
      // and 'resetSelectionOnContextMenu' option is true.&#13;
      var reset = cm.options.resetSelectionOnContextMenu;&#13;
      if (reset &amp;&amp; cm.doc.sel.contains(pos) == -1)&#13;
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);&#13;
&#13;
      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;&#13;
      input.wrapper.style.cssText = "position: absolute"&#13;
      var wrapperBox = input.wrapper.getBoundingClientRect()&#13;
      te.style.cssText = "position: absolute; width: 30px; height: 30px; top: " + (e.clientY - wrapperBox.top - 5) +&#13;
        "px; left: " + (e.clientX - wrapperBox.left - 5) + "px; z-index: 1000; background: " +&#13;
        (ie ? "rgba(255, 255, 255, .05)" : "transparent") +&#13;
        "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";&#13;
      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)&#13;
      display.input.focus();&#13;
      if (webkit) window.scrollTo(null, oldScrollY);&#13;
      display.input.reset();&#13;
      // Adds "Select all" to context menu in FF&#13;
      if (!cm.somethingSelected()) te.value = input.prevInput = " ";&#13;
      input.contextMenuPending = true;&#13;
      display.selForContextMenu = cm.doc.sel;&#13;
      clearTimeout(display.detectingSelectAll);&#13;
&#13;
      // Select-all will be greyed out if there's nothing to select, so&#13;
      // this adds a zero-width space so that we can later check whether&#13;
      // it got selected.&#13;
      function prepareSelectAllHack() {&#13;
        if (te.selectionStart != null) {&#13;
          var selected = cm.somethingSelected();&#13;
          var extval = "\u200b" + (selected ? te.value : "");&#13;
          te.value = "\u21da"; // Used to catch context-menu undo&#13;
          te.value = extval;&#13;
          input.prevInput = selected ? "" : "\u200b";&#13;
          te.selectionStart = 1; te.selectionEnd = extval.length;&#13;
          // Re-set this, in case some other handler touched the&#13;
          // selection in the meantime.&#13;
          display.selForContextMenu = cm.doc.sel;&#13;
        }&#13;
      }&#13;
      function rehide() {&#13;
        input.contextMenuPending = false;&#13;
        input.wrapper.style.cssText = oldWrapperCSS&#13;
        te.style.cssText = oldCSS;&#13;
        if (ie &amp;&amp; ie_version &lt; 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);&#13;
&#13;
        // Try to detect the user choosing select-all&#13;
        if (te.selectionStart != null) {&#13;
          if (!ie || (ie &amp;&amp; ie_version &lt; 9)) prepareSelectAllHack();&#13;
          var i = 0, poll = function() {&#13;
            if (display.selForContextMenu == cm.doc.sel &amp;&amp; te.selectionStart == 0 &amp;&amp;&#13;
                te.selectionEnd &gt; 0 &amp;&amp; input.prevInput == "\u200b")&#13;
              operation(cm, commands.selectAll)(cm);&#13;
            else if (i++ &lt; 10) display.detectingSelectAll = setTimeout(poll, 500);&#13;
            else display.input.reset();&#13;
          };&#13;
          display.detectingSelectAll = setTimeout(poll, 200);&#13;
        }&#13;
      }&#13;
&#13;
      if (ie &amp;&amp; ie_version &gt;= 9) prepareSelectAllHack();&#13;
      if (captureRightClick) {&#13;
        e_stop(e);&#13;
        var mouseup = function() {&#13;
          off(window, "mouseup", mouseup);&#13;
          setTimeout(rehide, 20);&#13;
        };&#13;
        on(window, "mouseup", mouseup);&#13;
      } else {&#13;
        setTimeout(rehide, 50);&#13;
      }&#13;
    },&#13;
&#13;
    readOnlyChanged: function(val) {&#13;
      if (!val) this.reset();&#13;
    },&#13;
&#13;
    setUneditable: nothing,&#13;
&#13;
    needsContentAttribute: false&#13;
  }, TextareaInput.prototype);&#13;
&#13;
  // CONTENTEDITABLE INPUT STYLE&#13;
&#13;
  function ContentEditableInput(cm) {&#13;
    this.cm = cm;&#13;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;&#13;
    this.polling = new Delayed();&#13;
    this.gracePeriod = false;&#13;
  }&#13;
&#13;
  ContentEditableInput.prototype = copyObj({&#13;
    init: function(display) {&#13;
      var input = this, cm = input.cm;&#13;
      var div = input.div = display.lineDiv;&#13;
      disableBrowserMagic(div);&#13;
&#13;
      on(div, "paste", function(e) {&#13;
        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);&#13;
      })&#13;
&#13;
      on(div, "compositionstart", function(e) {&#13;
        var data = e.data;&#13;
        input.composing = {sel: cm.doc.sel, data: data, startData: data};&#13;
        if (!data) return;&#13;
        var prim = cm.doc.sel.primary();&#13;
        var line = cm.getLine(prim.head.line);&#13;
        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));&#13;
        if (found &gt; -1 &amp;&amp; found &lt;= prim.head.ch)&#13;
          input.composing.sel = simpleSelection(Pos(prim.head.line, found),&#13;
                                                Pos(prim.head.line, found + data.length));&#13;
      });&#13;
      on(div, "compositionupdate", function(e) {&#13;
        input.composing.data = e.data;&#13;
      });&#13;
      on(div, "compositionend", function(e) {&#13;
        var ours = input.composing;&#13;
        if (!ours) return;&#13;
        if (e.data != ours.startData &amp;&amp; !/\u200b/.test(e.data))&#13;
          ours.data = e.data;&#13;
        // Need a small delay to prevent other code (input event,&#13;
        // selection polling) from doing damage when fired right after&#13;
        // compositionend.&#13;
        setTimeout(function() {&#13;
          if (!ours.handled)&#13;
            input.applyComposition(ours);&#13;
          if (input.composing == ours)&#13;
            input.composing = null;&#13;
        }, 50);&#13;
      });&#13;
&#13;
      on(div, "touchstart", function() {&#13;
        input.forceCompositionEnd();&#13;
      });&#13;
&#13;
      on(div, "input", function() {&#13;
        if (input.composing) return;&#13;
        if (cm.isReadOnly() || !input.pollContent())&#13;
          runInOp(input.cm, function() {regChange(cm);});&#13;
      });&#13;
&#13;
      function onCopyCut(e) {&#13;
        if (signalDOMEvent(cm, e)) return&#13;
        if (cm.somethingSelected()) {&#13;
          lastCopied = {lineWise: false, text: cm.getSelections()};&#13;
          if (e.type == "cut") cm.replaceSelection("", null, "cut");&#13;
        } else if (!cm.options.lineWiseCopyCut) {&#13;
          return;&#13;
        } else {&#13;
          var ranges = copyableRanges(cm);&#13;
          lastCopied = {lineWise: true, text: ranges.text};&#13;
          if (e.type == "cut") {&#13;
            cm.operation(function() {&#13;
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);&#13;
              cm.replaceSelection("", null, "cut");&#13;
            });&#13;
          }&#13;
        }&#13;
        // iOS exposes the clipboard API, but seems to discard content inserted into it&#13;
        if (e.clipboardData &amp;&amp; !ios) {&#13;
          e.preventDefault();&#13;
          e.clipboardData.clearData();&#13;
          e.clipboardData.setData("text/plain", lastCopied.text.join("\n"));&#13;
        } else {&#13;
          // Old-fashioned briefly-focus-a-textarea hack&#13;
          var kludge = hiddenTextarea(), te = kludge.firstChild;&#13;
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);&#13;
          te.value = lastCopied.text.join("\n");&#13;
          var hadFocus = document.activeElement;&#13;
          selectInput(te);&#13;
          setTimeout(function() {&#13;
            cm.display.lineSpace.removeChild(kludge);&#13;
            hadFocus.focus();&#13;
          }, 50);&#13;
        }&#13;
      }&#13;
      on(div, "copy", onCopyCut);&#13;
      on(div, "cut", onCopyCut);&#13;
    },&#13;
&#13;
    prepareSelection: function() {&#13;
      var result = prepareSelection(this.cm, false);&#13;
      result.focus = this.cm.state.focused;&#13;
      return result;&#13;
    },&#13;
&#13;
    showSelection: function(info, takeFocus) {&#13;
      if (!info || !this.cm.display.view.length) return;&#13;
      if (info.focus || takeFocus) this.showPrimarySelection();&#13;
      this.showMultipleSelections(info);&#13;
    },&#13;
&#13;
    showPrimarySelection: function() {&#13;
      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();&#13;
      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);&#13;
      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);&#13;
      if (curAnchor &amp;&amp; !curAnchor.bad &amp;&amp; curFocus &amp;&amp; !curFocus.bad &amp;&amp;&#13;
          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &amp;&amp;&#13;
          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)&#13;
        return;&#13;
&#13;
      var start = posToDOM(this.cm, prim.from());&#13;
      var end = posToDOM(this.cm, prim.to());&#13;
      if (!start &amp;&amp; !end) return;&#13;
&#13;
      var view = this.cm.display.view;&#13;
      var old = sel.rangeCount &amp;&amp; sel.getRangeAt(0);&#13;
      if (!start) {&#13;
        start = {node: view[0].measure.map[2], offset: 0};&#13;
      } else if (!end) { // FIXME dangerously hacky&#13;
        var measure = view[view.length - 1].measure;&#13;
        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;&#13;
        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};&#13;
      }&#13;
&#13;
      try { var rng = range(start.node, start.offset, end.offset, end.node); }&#13;
      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible&#13;
      if (rng) {&#13;
        if (!gecko &amp;&amp; this.cm.state.focused) {&#13;
          sel.collapse(start.node, start.offset);&#13;
          if (!rng.collapsed) sel.addRange(rng);&#13;
        } else {&#13;
          sel.removeAllRanges();&#13;
          sel.addRange(rng);&#13;
        }&#13;
        if (old &amp;&amp; sel.anchorNode == null) sel.addRange(old);&#13;
        else if (gecko) this.startGracePeriod();&#13;
      }&#13;
      this.rememberSelection();&#13;
    },&#13;
&#13;
    startGracePeriod: function() {&#13;
      var input = this;&#13;
      clearTimeout(this.gracePeriod);&#13;
      this.gracePeriod = setTimeout(function() {&#13;
        input.gracePeriod = false;&#13;
        if (input.selectionChanged())&#13;
          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });&#13;
      }, 20);&#13;
    },&#13;
&#13;
    showMultipleSelections: function(info) {&#13;
      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);&#13;
      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);&#13;
    },&#13;
&#13;
    rememberSelection: function() {&#13;
      var sel = window.getSelection();&#13;
      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;&#13;
      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;&#13;
    },&#13;
&#13;
    selectionInEditor: function() {&#13;
      var sel = window.getSelection();&#13;
      if (!sel.rangeCount) return false;&#13;
      var node = sel.getRangeAt(0).commonAncestorContainer;&#13;
      return contains(this.div, node);&#13;
    },&#13;
&#13;
    focus: function() {&#13;
      if (this.cm.options.readOnly != "nocursor") this.div.focus();&#13;
    },&#13;
    blur: function() { this.div.blur(); },&#13;
    getField: function() { return this.div; },&#13;
&#13;
    supportsTouch: function() { return true; },&#13;
&#13;
    receivedFocus: function() {&#13;
      var input = this;&#13;
      if (this.selectionInEditor())&#13;
        this.pollSelection();&#13;
      else&#13;
        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });&#13;
&#13;
      function poll() {&#13;
        if (input.cm.state.focused) {&#13;
          input.pollSelection();&#13;
          input.polling.set(input.cm.options.pollInterval, poll);&#13;
        }&#13;
      }&#13;
      this.polling.set(this.cm.options.pollInterval, poll);&#13;
    },&#13;
&#13;
    selectionChanged: function() {&#13;
      var sel = window.getSelection();&#13;
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||&#13;
        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;&#13;
    },&#13;
&#13;
    pollSelection: function() {&#13;
      if (!this.composing &amp;&amp; !this.gracePeriod &amp;&amp; this.selectionChanged()) {&#13;
        var sel = window.getSelection(), cm = this.cm;&#13;
        this.rememberSelection();&#13;
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);&#13;
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);&#13;
        if (anchor &amp;&amp; head) runInOp(cm, function() {&#13;
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);&#13;
          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;&#13;
        });&#13;
      }&#13;
    },&#13;
&#13;
    pollContent: function() {&#13;
      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();&#13;
      var from = sel.from(), to = sel.to();&#13;
      if (from.line &lt; display.viewFrom || to.line &gt; display.viewTo - 1) return false;&#13;
&#13;
      var fromIndex;&#13;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {&#13;
        var fromLine = lineNo(display.view[0].line);&#13;
        var fromNode = display.view[0].node;&#13;
      } else {&#13;
        var fromLine = lineNo(display.view[fromIndex].line);&#13;
        var fromNode = display.view[fromIndex - 1].node.nextSibling;&#13;
      }&#13;
      var toIndex = findViewIndex(cm, to.line);&#13;
      if (toIndex == display.view.length - 1) {&#13;
        var toLine = display.viewTo - 1;&#13;
        var toNode = display.lineDiv.lastChild;&#13;
      } else {&#13;
        var toLine = lineNo(display.view[toIndex + 1].line) - 1;&#13;
        var toNode = display.view[toIndex + 1].node.previousSibling;&#13;
      }&#13;
&#13;
      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));&#13;
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));&#13;
      while (newText.length &gt; 1 &amp;&amp; oldText.length &gt; 1) {&#13;
        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }&#13;
        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }&#13;
        else break;&#13;
      }&#13;
&#13;
      var cutFront = 0, cutEnd = 0;&#13;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);&#13;
      while (cutFront &lt; maxCutFront &amp;&amp; newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))&#13;
        ++cutFront;&#13;
      var newBot = lst(newText), oldBot = lst(oldText);&#13;
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),&#13;
                               oldBot.length - (oldText.length == 1 ? cutFront : 0));&#13;
      while (cutEnd &lt; maxCutEnd &amp;&amp;&#13;
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))&#13;
        ++cutEnd;&#13;
&#13;
      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);&#13;
      newText[0] = newText[0].slice(cutFront);&#13;
&#13;
      var chFrom = Pos(fromLine, cutFront);&#13;
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);&#13;
      if (newText.length &gt; 1 || newText[0] || cmp(chFrom, chTo)) {&#13;
        replaceRange(cm.doc, newText, chFrom, chTo, "+input");&#13;
        return true;&#13;
      }&#13;
    },&#13;
&#13;
    ensurePolled: function() {&#13;
      this.forceCompositionEnd();&#13;
    },&#13;
    reset: function() {&#13;
      this.forceCompositionEnd();&#13;
    },&#13;
    forceCompositionEnd: function() {&#13;
      if (!this.composing || this.composing.handled) return;&#13;
      this.applyComposition(this.composing);&#13;
      this.composing.handled = true;&#13;
      this.div.blur();&#13;
      this.div.focus();&#13;
    },&#13;
    applyComposition: function(composing) {&#13;
      if (this.cm.isReadOnly())&#13;
        operation(this.cm, regChange)(this.cm)&#13;
      else if (composing.data &amp;&amp; composing.data != composing.startData)&#13;
        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);&#13;
    },&#13;
&#13;
    setUneditable: function(node) {&#13;
      node.contentEditable = "false"&#13;
    },&#13;
&#13;
    onKeyPress: function(e) {&#13;
      e.preventDefault();&#13;
      if (!this.cm.isReadOnly())&#13;
        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);&#13;
    },&#13;
&#13;
    readOnlyChanged: function(val) {&#13;
      this.div.contentEditable = String(val != "nocursor")&#13;
    },&#13;
&#13;
    onContextMenu: nothing,&#13;
    resetPosition: nothing,&#13;
&#13;
    needsContentAttribute: true&#13;
  }, ContentEditableInput.prototype);&#13;
&#13;
  function posToDOM(cm, pos) {&#13;
    var view = findViewForLine(cm, pos.line);&#13;
    if (!view || view.hidden) return null;&#13;
    var line = getLine(cm.doc, pos.line);&#13;
    var info = mapFromLineView(view, line, pos.line);&#13;
&#13;
    var order = getOrder(line), side = "left";&#13;
    if (order) {&#13;
      var partPos = getBidiPartAt(order, pos.ch);&#13;
      side = partPos % 2 ? "right" : "left";&#13;
    }&#13;
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);&#13;
    result.offset = result.collapse == "right" ? result.end : result.start;&#13;
    return result;&#13;
  }&#13;
&#13;
  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }&#13;
&#13;
  function domToPos(cm, node, offset) {&#13;
    var lineNode;&#13;
    if (node == cm.display.lineDiv) {&#13;
      lineNode = cm.display.lineDiv.childNodes[offset];&#13;
      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);&#13;
      node = null; offset = 0;&#13;
    } else {&#13;
      for (lineNode = node;; lineNode = lineNode.parentNode) {&#13;
        if (!lineNode || lineNode == cm.display.lineDiv) return null;&#13;
        if (lineNode.parentNode &amp;&amp; lineNode.parentNode == cm.display.lineDiv) break;&#13;
      }&#13;
    }&#13;
    for (var i = 0; i &lt; cm.display.view.length; i++) {&#13;
      var lineView = cm.display.view[i];&#13;
      if (lineView.node == lineNode)&#13;
        return locateNodeInLineView(lineView, node, offset);&#13;
    }&#13;
  }&#13;
&#13;
  function locateNodeInLineView(lineView, node, offset) {&#13;
    var wrapper = lineView.text.firstChild, bad = false;&#13;
    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);&#13;
    if (node == wrapper) {&#13;
      bad = true;&#13;
      node = wrapper.childNodes[offset];&#13;
      offset = 0;&#13;
      if (!node) {&#13;
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;&#13;
        return badPos(Pos(lineNo(line), line.text.length), bad);&#13;
      }&#13;
    }&#13;
&#13;
    var textNode = node.nodeType == 3 ? node : null, topNode = node;&#13;
    if (!textNode &amp;&amp; node.childNodes.length == 1 &amp;&amp; node.firstChild.nodeType == 3) {&#13;
      textNode = node.firstChild;&#13;
      if (offset) offset = textNode.nodeValue.length;&#13;
    }&#13;
    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;&#13;
    var measure = lineView.measure, maps = measure.maps;&#13;
&#13;
    function find(textNode, topNode, offset) {&#13;
      for (var i = -1; i &lt; (maps ? maps.length : 0); i++) {&#13;
        var map = i &lt; 0 ? measure.map : maps[i];&#13;
        for (var j = 0; j &lt; map.length; j += 3) {&#13;
          var curNode = map[j + 2];&#13;
          if (curNode == textNode || curNode == topNode) {&#13;
            var line = lineNo(i &lt; 0 ? lineView.line : lineView.rest[i]);&#13;
            var ch = map[j] + offset;&#13;
            if (offset &lt; 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];&#13;
            return Pos(line, ch);&#13;
          }&#13;
        }&#13;
      }&#13;
    }&#13;
    var found = find(textNode, topNode, offset);&#13;
    if (found) return badPos(found, bad);&#13;
&#13;
    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems&#13;
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {&#13;
      found = find(after, after.firstChild, 0);&#13;
      if (found)&#13;
        return badPos(Pos(found.line, found.ch - dist), bad);&#13;
      else&#13;
        dist += after.textContent.length;&#13;
    }&#13;
    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {&#13;
      found = find(before, before.firstChild, -1);&#13;
      if (found)&#13;
        return badPos(Pos(found.line, found.ch + dist), bad);&#13;
      else&#13;
        dist += after.textContent.length;&#13;
    }&#13;
  }&#13;
&#13;
  function domTextBetween(cm, from, to, fromLine, toLine) {&#13;
    var text = "", closing = false, lineSep = cm.doc.lineSeparator();&#13;
    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }&#13;
    function walk(node) {&#13;
      if (node.nodeType == 1) {&#13;
        var cmText = node.getAttribute("cm-text");&#13;
        if (cmText != null) {&#13;
          if (cmText == "") cmText = node.textContent.replace(/\u200b/g, "");&#13;
          text += cmText;&#13;
          return;&#13;
        }&#13;
        var markerID = node.getAttribute("cm-marker"), range;&#13;
        if (markerID) {&#13;
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));&#13;
          if (found.length &amp;&amp; (range = found[0].find()))&#13;
            text += getBetween(cm.doc, range.from, range.to).join(lineSep);&#13;
          return;&#13;
        }&#13;
        if (node.getAttribute("contenteditable") == "false") return;&#13;
        for (var i = 0; i &lt; node.childNodes.length; i++)&#13;
          walk(node.childNodes[i]);&#13;
        if (/^(pre|div|p)$/i.test(node.nodeName))&#13;
          closing = true;&#13;
      } else if (node.nodeType == 3) {&#13;
        var val = node.nodeValue;&#13;
        if (!val) return;&#13;
        if (closing) {&#13;
          text += lineSep;&#13;
          closing = false;&#13;
        }&#13;
        text += val;&#13;
      }&#13;
    }&#13;
    for (;;) {&#13;
      walk(from);&#13;
      if (from == to) break;&#13;
      from = from.nextSibling;&#13;
    }&#13;
    return text;&#13;
  }&#13;
&#13;
  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};&#13;
&#13;
  // SELECTION / CURSOR&#13;
&#13;
  // Selection objects are immutable. A new one is created every time&#13;
  // the selection changes. A selection is one or more non-overlapping&#13;
  // (and non-touching) ranges, sorted, and an integer that indicates&#13;
  // which one is the primary selection (the one that's scrolled into&#13;
  // view, that getCursor returns, etc).&#13;
  function Selection(ranges, primIndex) {&#13;
    this.ranges = ranges;&#13;
    this.primIndex = primIndex;&#13;
  }&#13;
&#13;
  Selection.prototype = {&#13;
    primary: function() { return this.ranges[this.primIndex]; },&#13;
    equals: function(other) {&#13;
      if (other == this) return true;&#13;
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;&#13;
      for (var i = 0; i &lt; this.ranges.length; i++) {&#13;
        var here = this.ranges[i], there = other.ranges[i];&#13;
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;&#13;
      }&#13;
      return true;&#13;
    },&#13;
    deepCopy: function() {&#13;
      for (var out = [], i = 0; i &lt; this.ranges.length; i++)&#13;
        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));&#13;
      return new Selection(out, this.primIndex);&#13;
    },&#13;
    somethingSelected: function() {&#13;
      for (var i = 0; i &lt; this.ranges.length; i++)&#13;
        if (!this.ranges[i].empty()) return true;&#13;
      return false;&#13;
    },&#13;
    contains: function(pos, end) {&#13;
      if (!end) end = pos;&#13;
      for (var i = 0; i &lt; this.ranges.length; i++) {&#13;
        var range = this.ranges[i];&#13;
        if (cmp(end, range.from()) &gt;= 0 &amp;&amp; cmp(pos, range.to()) &lt;= 0)&#13;
          return i;&#13;
      }&#13;
      return -1;&#13;
    }&#13;
  };&#13;
&#13;
  function Range(anchor, head) {&#13;
    this.anchor = anchor; this.head = head;&#13;
  }&#13;
&#13;
  Range.prototype = {&#13;
    from: function() { return minPos(this.anchor, this.head); },&#13;
    to: function() { return maxPos(this.anchor, this.head); },&#13;
    empty: function() {&#13;
      return this.head.line == this.anchor.line &amp;&amp; this.head.ch == this.anchor.ch;&#13;
    }&#13;
  };&#13;
&#13;
  // Take an unsorted, potentially overlapping set of ranges, and&#13;
  // build a selection out of it. 'Consumes' ranges array (modifying&#13;
  // it).&#13;
  function normalizeSelection(ranges, primIndex) {&#13;
    var prim = ranges[primIndex];&#13;
    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });&#13;
    primIndex = indexOf(ranges, prim);&#13;
    for (var i = 1; i &lt; ranges.length; i++) {&#13;
      var cur = ranges[i], prev = ranges[i - 1];&#13;
      if (cmp(prev.to(), cur.from()) &gt;= 0) {&#13;
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());&#13;
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;&#13;
        if (i &lt;= primIndex) --primIndex;&#13;
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));&#13;
      }&#13;
    }&#13;
    return new Selection(ranges, primIndex);&#13;
  }&#13;
&#13;
  function simpleSelection(anchor, head) {&#13;
    return new Selection([new Range(anchor, head || anchor)], 0);&#13;
  }&#13;
&#13;
  // Most of the external API clips given positions to make sure they&#13;
  // actually exist within the document.&#13;
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}&#13;
  function clipPos(doc, pos) {&#13;
    if (pos.line &lt; doc.first) return Pos(doc.first, 0);&#13;
    var last = doc.first + doc.size - 1;&#13;
    if (pos.line &gt; last) return Pos(last, getLine(doc, last).text.length);&#13;
    return clipToLen(pos, getLine(doc, pos.line).text.length);&#13;
  }&#13;
  function clipToLen(pos, linelen) {&#13;
    var ch = pos.ch;&#13;
    if (ch == null || ch &gt; linelen) return Pos(pos.line, linelen);&#13;
    else if (ch &lt; 0) return Pos(pos.line, 0);&#13;
    else return pos;&#13;
  }&#13;
  function isLine(doc, l) {return l &gt;= doc.first &amp;&amp; l &lt; doc.first + doc.size;}&#13;
  function clipPosArray(doc, array) {&#13;
    for (var out = [], i = 0; i &lt; array.length; i++) out[i] = clipPos(doc, array[i]);&#13;
    return out;&#13;
  }&#13;
&#13;
  // SELECTION UPDATES&#13;
&#13;
  // The 'scroll' parameter given to many of these indicated whether&#13;
  // the new cursor position should be scrolled into view after&#13;
  // modifying the selection.&#13;
&#13;
  // If shift is held or the extend flag is set, extends a range to&#13;
  // include a given position (and optionally a second position).&#13;
  // Otherwise, simply returns the range between the given positions.&#13;
  // Used for cursor motion and such.&#13;
  function extendRange(doc, range, head, other) {&#13;
    if (doc.cm &amp;&amp; doc.cm.display.shift || doc.extend) {&#13;
      var anchor = range.anchor;&#13;
      if (other) {&#13;
        var posBefore = cmp(head, anchor) &lt; 0;&#13;
        if (posBefore != (cmp(other, anchor) &lt; 0)) {&#13;
          anchor = head;&#13;
          head = other;&#13;
        } else if (posBefore != (cmp(head, other) &lt; 0)) {&#13;
          head = other;&#13;
        }&#13;
      }&#13;
      return new Range(anchor, head);&#13;
    } else {&#13;
      return new Range(other || head, head);&#13;
    }&#13;
  }&#13;
&#13;
  // Extend the primary selection range, discard the rest.&#13;
  function extendSelection(doc, head, other, options) {&#13;
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);&#13;
  }&#13;
&#13;
  // Extend all selections (pos is an array of selections with length&#13;
  // equal the number of selections)&#13;
  function extendSelections(doc, heads, options) {&#13;
    for (var out = [], i = 0; i &lt; doc.sel.ranges.length; i++)&#13;
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);&#13;
    var newSel = normalizeSelection(out, doc.sel.primIndex);&#13;
    setSelection(doc, newSel, options);&#13;
  }&#13;
&#13;
  // Updates a single range in the selection.&#13;
  function replaceOneSelection(doc, i, range, options) {&#13;
    var ranges = doc.sel.ranges.slice(0);&#13;
    ranges[i] = range;&#13;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);&#13;
  }&#13;
&#13;
  // Reset the selection to a single range.&#13;
  function setSimpleSelection(doc, anchor, head, options) {&#13;
    setSelection(doc, simpleSelection(anchor, head), options);&#13;
  }&#13;
&#13;
  // Give beforeSelectionChange handlers a change to influence a&#13;
  // selection update.&#13;
  function filterSelectionChange(doc, sel, options) {&#13;
    var obj = {&#13;
      ranges: sel.ranges,&#13;
      update: function(ranges) {&#13;
        this.ranges = [];&#13;
        for (var i = 0; i &lt; ranges.length; i++)&#13;
          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),&#13;
                                     clipPos(doc, ranges[i].head));&#13;
      },&#13;
      origin: options &amp;&amp; options.origin&#13;
    };&#13;
    signal(doc, "beforeSelectionChange", doc, obj);&#13;
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);&#13;
    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);&#13;
    else return sel;&#13;
  }&#13;
&#13;
  function setSelectionReplaceHistory(doc, sel, options) {&#13;
    var done = doc.history.done, last = lst(done);&#13;
    if (last &amp;&amp; last.ranges) {&#13;
      done[done.length - 1] = sel;&#13;
      setSelectionNoUndo(doc, sel, options);&#13;
    } else {&#13;
      setSelection(doc, sel, options);&#13;
    }&#13;
  }&#13;
&#13;
  // Set a new selection.&#13;
  function setSelection(doc, sel, options) {&#13;
    setSelectionNoUndo(doc, sel, options);&#13;
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);&#13;
  }&#13;
&#13;
  function setSelectionNoUndo(doc, sel, options) {&#13;
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm &amp;&amp; hasHandler(doc.cm, "beforeSelectionChange"))&#13;
      sel = filterSelectionChange(doc, sel, options);&#13;
&#13;
    var bias = options &amp;&amp; options.bias ||&#13;
      (cmp(sel.primary().head, doc.sel.primary().head) &lt; 0 ? -1 : 1);&#13;
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));&#13;
&#13;
    if (!(options &amp;&amp; options.scroll === false) &amp;&amp; doc.cm)&#13;
      ensureCursorVisible(doc.cm);&#13;
  }&#13;
&#13;
  function setSelectionInner(doc, sel) {&#13;
    if (sel.equals(doc.sel)) return;&#13;
&#13;
    doc.sel = sel;&#13;
&#13;
    if (doc.cm) {&#13;
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;&#13;
      signalCursorActivity(doc.cm);&#13;
    }&#13;
    signalLater(doc, "cursorActivity", doc);&#13;
  }&#13;
&#13;
  // Verify that the selection does not partially select any atomic&#13;
  // marked ranges.&#13;
  function reCheckSelection(doc) {&#13;
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);&#13;
  }&#13;
&#13;
  // Return a selection that does not partially select any atomic&#13;
  // ranges.&#13;
  function skipAtomicInSelection(doc, sel, bias, mayClear) {&#13;
    var out;&#13;
    for (var i = 0; i &lt; sel.ranges.length; i++) {&#13;
      var range = sel.ranges[i];&#13;
      var old = sel.ranges.length == doc.sel.ranges.length &amp;&amp; doc.sel.ranges[i];&#13;
      var newAnchor = skipAtomic(doc, range.anchor, old &amp;&amp; old.anchor, bias, mayClear);&#13;
      var newHead = skipAtomic(doc, range.head, old &amp;&amp; old.head, bias, mayClear);&#13;
      if (out || newAnchor != range.anchor || newHead != range.head) {&#13;
        if (!out) out = sel.ranges.slice(0, i);&#13;
        out[i] = new Range(newAnchor, newHead);&#13;
      }&#13;
    }&#13;
    return out ? normalizeSelection(out, sel.primIndex) : sel;&#13;
  }&#13;
&#13;
  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {&#13;
    var line = getLine(doc, pos.line);&#13;
    if (line.markedSpans) for (var i = 0; i &lt; line.markedSpans.length; ++i) {&#13;
      var sp = line.markedSpans[i], m = sp.marker;&#13;
      if ((sp.from == null || (m.inclusiveLeft ? sp.from &lt;= pos.ch : sp.from &lt; pos.ch)) &amp;&amp;&#13;
          (sp.to == null || (m.inclusiveRight ? sp.to &gt;= pos.ch : sp.to &gt; pos.ch))) {&#13;
        if (mayClear) {&#13;
          signal(m, "beforeCursorEnter");&#13;
          if (m.explicitlyCleared) {&#13;
            if (!line.markedSpans) break;&#13;
            else {--i; continue;}&#13;
          }&#13;
        }&#13;
        if (!m.atomic) continue;&#13;
&#13;
        if (oldPos) {&#13;
          var near = m.find(dir &lt; 0 ? 1 : -1), diff;&#13;
          if (dir &lt; 0 ? m.inclusiveRight : m.inclusiveLeft)&#13;
            near = movePos(doc, near, -dir, near &amp;&amp; near.line == pos.line ? line : null);&#13;
          if (near &amp;&amp; near.line == pos.line &amp;&amp; (diff = cmp(near, oldPos)) &amp;&amp; (dir &lt; 0 ? diff &lt; 0 : diff &gt; 0))&#13;
            return skipAtomicInner(doc, near, pos, dir, mayClear);&#13;
        }&#13;
&#13;
        var far = m.find(dir &lt; 0 ? -1 : 1);&#13;
        if (dir &lt; 0 ? m.inclusiveLeft : m.inclusiveRight)&#13;
          far = movePos(doc, far, dir, far.line == pos.line ? line : null);&#13;
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;&#13;
      }&#13;
    }&#13;
    return pos;&#13;
  }&#13;
&#13;
  // Ensure a given position is not inside an atomic range.&#13;
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {&#13;
    var dir = bias || 1;&#13;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||&#13;
        (!mayClear &amp;&amp; skipAtomicInner(doc, pos, oldPos, dir, true)) ||&#13;
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||&#13;
        (!mayClear &amp;&amp; skipAtomicInner(doc, pos, oldPos, -dir, true));&#13;
    if (!found) {&#13;
      doc.cantEdit = true;&#13;
      return Pos(doc.first, 0);&#13;
    }&#13;
    return found;&#13;
  }&#13;
&#13;
  function movePos(doc, pos, dir, line) {&#13;
    if (dir &lt; 0 &amp;&amp; pos.ch == 0) {&#13;
      if (pos.line &gt; doc.first) return clipPos(doc, Pos(pos.line - 1));&#13;
      else return null;&#13;
    } else if (dir &gt; 0 &amp;&amp; pos.ch == (line || getLine(doc, pos.line)).text.length) {&#13;
      if (pos.line &lt; doc.first + doc.size - 1) return Pos(pos.line + 1, 0);&#13;
      else return null;&#13;
    } else {&#13;
      return new Pos(pos.line, pos.ch + dir);&#13;
    }&#13;
  }&#13;
&#13;
  // SELECTION DRAWING&#13;
&#13;
  function updateSelection(cm) {&#13;
    cm.display.input.showSelection(cm.display.input.prepareSelection());&#13;
  }&#13;
&#13;
  function prepareSelection(cm, primary) {&#13;
    var doc = cm.doc, result = {};&#13;
    var curFragment = result.cursors = document.createDocumentFragment();&#13;
    var selFragment = result.selection = document.createDocumentFragment();&#13;
&#13;
    for (var i = 0; i &lt; doc.sel.ranges.length; i++) {&#13;
      if (primary === false &amp;&amp; i == doc.sel.primIndex) continue;&#13;
      var range = doc.sel.ranges[i];&#13;
      if (range.from().line &gt;= cm.display.viewTo || range.to().line &lt; cm.display.viewFrom) continue;&#13;
      var collapsed = range.empty();&#13;
      if (collapsed || cm.options.showCursorWhenSelecting)&#13;
        drawSelectionCursor(cm, range.head, curFragment);&#13;
      if (!collapsed)&#13;
        drawSelectionRange(cm, range, selFragment);&#13;
    }&#13;
    return result;&#13;
  }&#13;
&#13;
  // Draws a cursor for the given range&#13;
  function drawSelectionCursor(cm, head, output) {&#13;
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);&#13;
&#13;
    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));&#13;
    cursor.style.left = pos.left + "px";&#13;
    cursor.style.top = pos.top + "px";&#13;
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";&#13;
&#13;
    if (pos.other) {&#13;
      // Secondary cursor, shown when on a 'jump' in bi-directional text&#13;
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));&#13;
      otherCursor.style.display = "";&#13;
      otherCursor.style.left = pos.other.left + "px";&#13;
      otherCursor.style.top = pos.other.top + "px";&#13;
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";&#13;
    }&#13;
  }&#13;
&#13;
  // Draws the given range as a highlighted selection&#13;
  function drawSelectionRange(cm, range, output) {&#13;
    var display = cm.display, doc = cm.doc;&#13;
    var fragment = document.createDocumentFragment();&#13;
    var padding = paddingH(cm.display), leftSide = padding.left;&#13;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;&#13;
&#13;
    function add(left, top, width, bottom) {&#13;
      if (top &lt; 0) top = 0;&#13;
      top = Math.round(top);&#13;
      bottom = Math.round(bottom);&#13;
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +&#13;
                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +&#13;
                               "px; height: " + (bottom - top) + "px"));&#13;
    }&#13;
&#13;
    function drawForLine(line, fromArg, toArg) {&#13;
      var lineObj = getLine(doc, line);&#13;
      var lineLen = lineObj.text.length;&#13;
      var start, end;&#13;
      function coords(ch, bias) {&#13;
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);&#13;
      }&#13;
&#13;
      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {&#13;
        var leftPos = coords(from, "left"), rightPos, left, right;&#13;
        if (from == to) {&#13;
          rightPos = leftPos;&#13;
          left = right = leftPos.left;&#13;
        } else {&#13;
          rightPos = coords(to - 1, "right");&#13;
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }&#13;
          left = leftPos.left;&#13;
          right = rightPos.right;&#13;
        }&#13;
        if (fromArg == null &amp;&amp; from == 0) left = leftSide;&#13;
        if (rightPos.top - leftPos.top &gt; 3) { // Different lines, draw top part&#13;
          add(left, leftPos.top, null, leftPos.bottom);&#13;
          left = leftSide;&#13;
          if (leftPos.bottom &lt; rightPos.top) add(left, leftPos.bottom, null, rightPos.top);&#13;
        }&#13;
        if (toArg == null &amp;&amp; to == lineLen) right = rightSide;&#13;
        if (!start || leftPos.top &lt; start.top || leftPos.top == start.top &amp;&amp; leftPos.left &lt; start.left)&#13;
          start = leftPos;&#13;
        if (!end || rightPos.bottom &gt; end.bottom || rightPos.bottom == end.bottom &amp;&amp; rightPos.right &gt; end.right)&#13;
          end = rightPos;&#13;
        if (left &lt; leftSide + 1) left = leftSide;&#13;
        add(left, rightPos.top, right - left, rightPos.bottom);&#13;
      });&#13;
      return {start: start, end: end};&#13;
    }&#13;
&#13;
    var sFrom = range.from(), sTo = range.to();&#13;
    if (sFrom.line == sTo.line) {&#13;
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);&#13;
    } else {&#13;
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);&#13;
      var singleVLine = visualLine(fromLine) == visualLine(toLine);&#13;
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;&#13;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;&#13;
      if (singleVLine) {&#13;
        if (leftEnd.top &lt; rightStart.top - 2) {&#13;
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);&#13;
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);&#13;
        } else {&#13;
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);&#13;
        }&#13;
      }&#13;
      if (leftEnd.bottom &lt; rightStart.top)&#13;
        add(leftSide, leftEnd.bottom, null, rightStart.top);&#13;
    }&#13;
&#13;
    output.appendChild(fragment);&#13;
  }&#13;
&#13;
  // Cursor-blinking&#13;
  function restartBlink(cm) {&#13;
    if (!cm.state.focused) return;&#13;
    var display = cm.display;&#13;
    clearInterval(display.blinker);&#13;
    var on = true;&#13;
    display.cursorDiv.style.visibility = "";&#13;
    if (cm.options.cursorBlinkRate &gt; 0)&#13;
      display.blinker = setInterval(function() {&#13;
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";&#13;
      }, cm.options.cursorBlinkRate);&#13;
    else if (cm.options.cursorBlinkRate &lt; 0)&#13;
      display.cursorDiv.style.visibility = "hidden";&#13;
  }&#13;
&#13;
  // HIGHLIGHT WORKER&#13;
&#13;
  function startWorker(cm, time) {&#13;
    if (cm.doc.mode.startState &amp;&amp; cm.doc.frontier &lt; cm.display.viewTo)&#13;
      cm.state.highlight.set(time, bind(highlightWorker, cm));&#13;
  }&#13;
&#13;
  function highlightWorker(cm) {&#13;
    var doc = cm.doc;&#13;
    if (doc.frontier &lt; doc.first) doc.frontier = doc.first;&#13;
    if (doc.frontier &gt;= cm.display.viewTo) return;&#13;
    var end = +new Date + cm.options.workTime;&#13;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));&#13;
    var changedLines = [];&#13;
&#13;
    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {&#13;
      if (doc.frontier &gt;= cm.display.viewFrom) { // Visible&#13;
        var oldStyles = line.styles, tooLong = line.text.length &gt; cm.options.maxHighlightLength;&#13;
        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);&#13;
        line.styles = highlighted.styles;&#13;
        var oldCls = line.styleClasses, newCls = highlighted.classes;&#13;
        if (newCls) line.styleClasses = newCls;&#13;
        else if (oldCls) line.styleClasses = null;&#13;
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||&#13;
          oldCls != newCls &amp;&amp; (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);&#13;
        for (var i = 0; !ischange &amp;&amp; i &lt; oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];&#13;
        if (ischange) changedLines.push(doc.frontier);&#13;
        line.stateAfter = tooLong ? state : copyState(doc.mode, state);&#13;
      } else {&#13;
        if (line.text.length &lt;= cm.options.maxHighlightLength)&#13;
          processLine(cm, line.text, state);&#13;
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;&#13;
      }&#13;
      ++doc.frontier;&#13;
      if (+new Date &gt; end) {&#13;
        startWorker(cm, cm.options.workDelay);&#13;
        return true;&#13;
      }&#13;
    });&#13;
    if (changedLines.length) runInOp(cm, function() {&#13;
      for (var i = 0; i &lt; changedLines.length; i++)&#13;
        regLineChange(cm, changedLines[i], "text");&#13;
    });&#13;
  }&#13;
&#13;
  // Finds the line to start with when starting a parse. Tries to&#13;
  // find a line with a stateAfter, so that it can start with a&#13;
  // valid state. If that fails, it returns the line with the&#13;
  // smallest indentation, which tends to need the least context to&#13;
  // parse correctly.&#13;
  function findStartLine(cm, n, precise) {&#13;
    var minindent, minline, doc = cm.doc;&#13;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);&#13;
    for (var search = n; search &gt; lim; --search) {&#13;
      if (search &lt;= doc.first) return doc.first;&#13;
      var line = getLine(doc, search - 1);&#13;
      if (line.stateAfter &amp;&amp; (!precise || search &lt;= doc.frontier)) return search;&#13;
      var indented = countColumn(line.text, null, cm.options.tabSize);&#13;
      if (minline == null || minindent &gt; indented) {&#13;
        minline = search - 1;&#13;
        minindent = indented;&#13;
      }&#13;
    }&#13;
    return minline;&#13;
  }&#13;
&#13;
  function getStateBefore(cm, n, precise) {&#13;
    var doc = cm.doc, display = cm.display;&#13;
    if (!doc.mode.startState) return true;&#13;
    var pos = findStartLine(cm, n, precise), state = pos &gt; doc.first &amp;&amp; getLine(doc, pos-1).stateAfter;&#13;
    if (!state) state = startState(doc.mode);&#13;
    else state = copyState(doc.mode, state);&#13;
    doc.iter(pos, n, function(line) {&#13;
      processLine(cm, line.text, state);&#13;
      var save = pos == n - 1 || pos % 5 == 0 || pos &gt;= display.viewFrom &amp;&amp; pos &lt; display.viewTo;&#13;
      line.stateAfter = save ? copyState(doc.mode, state) : null;&#13;
      ++pos;&#13;
    });&#13;
    if (precise) doc.frontier = pos;&#13;
    return state;&#13;
  }&#13;
&#13;
  // POSITION MEASUREMENT&#13;
&#13;
  function paddingTop(display) {return display.lineSpace.offsetTop;}&#13;
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}&#13;
  function paddingH(display) {&#13;
    if (display.cachedPaddingH) return display.cachedPaddingH;&#13;
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));&#13;
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;&#13;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};&#13;
    if (!isNaN(data.left) &amp;&amp; !isNaN(data.right)) display.cachedPaddingH = data;&#13;
    return data;&#13;
  }&#13;
&#13;
  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }&#13;
  function displayWidth(cm) {&#13;
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;&#13;
  }&#13;
  function displayHeight(cm) {&#13;
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;&#13;
  }&#13;
&#13;
  // Ensure the lineView.wrapping.heights array is populated. This is&#13;
  // an array of bottom offsets for the lines that make up a drawn&#13;
  // line. When lineWrapping is on, there might be more than one&#13;
  // height.&#13;
  function ensureLineHeights(cm, lineView, rect) {&#13;
    var wrapping = cm.options.lineWrapping;&#13;
    var curWidth = wrapping &amp;&amp; displayWidth(cm);&#13;
    if (!lineView.measure.heights || wrapping &amp;&amp; lineView.measure.width != curWidth) {&#13;
      var heights = lineView.measure.heights = [];&#13;
      if (wrapping) {&#13;
        lineView.measure.width = curWidth;&#13;
        var rects = lineView.text.firstChild.getClientRects();&#13;
        for (var i = 0; i &lt; rects.length - 1; i++) {&#13;
          var cur = rects[i], next = rects[i + 1];&#13;
          if (Math.abs(cur.bottom - next.bottom) &gt; 2)&#13;
            heights.push((cur.bottom + next.top) / 2 - rect.top);&#13;
        }&#13;
      }&#13;
      heights.push(rect.bottom - rect.top);&#13;
    }&#13;
  }&#13;
&#13;
  // Find a line map (mapping character offsets to text nodes) and a&#13;
  // measurement cache for the given line number. (A line view might&#13;
  // contain multiple lines when collapsed ranges are present.)&#13;
  function mapFromLineView(lineView, line, lineN) {&#13;
    if (lineView.line == line)&#13;
      return {map: lineView.measure.map, cache: lineView.measure.cache};&#13;
    for (var i = 0; i &lt; lineView.rest.length; i++)&#13;
      if (lineView.rest[i] == line)&#13;
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};&#13;
    for (var i = 0; i &lt; lineView.rest.length; i++)&#13;
      if (lineNo(lineView.rest[i]) &gt; lineN)&#13;
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};&#13;
  }&#13;
&#13;
  // Render a line into the hidden node display.externalMeasured. Used&#13;
  // when measurement is needed for a line that's not in the viewport.&#13;
  function updateExternalMeasurement(cm, line) {&#13;
    line = visualLine(line);&#13;
    var lineN = lineNo(line);&#13;
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);&#13;
    view.lineN = lineN;&#13;
    var built = view.built = buildLineContent(cm, view);&#13;
    view.text = built.pre;&#13;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);&#13;
    return view;&#13;
  }&#13;
&#13;
  // Get a {top, bottom, left, right} box (in line-local coordinates)&#13;
  // for a given character.&#13;
  function measureChar(cm, line, ch, bias) {&#13;
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);&#13;
  }&#13;
&#13;
  // Find a line view that corresponds to the given line number.&#13;
  function findViewForLine(cm, lineN) {&#13;
    if (lineN &gt;= cm.display.viewFrom &amp;&amp; lineN &lt; cm.display.viewTo)&#13;
      return cm.display.view[findViewIndex(cm, lineN)];&#13;
    var ext = cm.display.externalMeasured;&#13;
    if (ext &amp;&amp; lineN &gt;= ext.lineN &amp;&amp; lineN &lt; ext.lineN + ext.size)&#13;
      return ext;&#13;
  }&#13;
&#13;
  // Measurement can be split in two steps, the set-up work that&#13;
  // applies to the whole line, and the measurement of the actual&#13;
  // character. Functions like coordsChar, that need to do a lot of&#13;
  // measurements in a row, can thus ensure that the set-up work is&#13;
  // only done once.&#13;
  function prepareMeasureForLine(cm, line) {&#13;
    var lineN = lineNo(line);&#13;
    var view = findViewForLine(cm, lineN);&#13;
    if (view &amp;&amp; !view.text) {&#13;
      view = null;&#13;
    } else if (view &amp;&amp; view.changes) {&#13;
      updateLineForChanges(cm, view, lineN, getDimensions(cm));&#13;
      cm.curOp.forceUpdate = true;&#13;
    }&#13;
    if (!view)&#13;
      view = updateExternalMeasurement(cm, line);&#13;
&#13;
    var info = mapFromLineView(view, line, lineN);&#13;
    return {&#13;
      line: line, view: view, rect: null,&#13;
      map: info.map, cache: info.cache, before: info.before,&#13;
      hasHeights: false&#13;
    };&#13;
  }&#13;
&#13;
  // Given a prepared measurement object, measures the position of an&#13;
  // actual character (or fetches it from the cache).&#13;
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {&#13;
    if (prepared.before) ch = -1;&#13;
    var key = ch + (bias || ""), found;&#13;
    if (prepared.cache.hasOwnProperty(key)) {&#13;
      found = prepared.cache[key];&#13;
    } else {&#13;
      if (!prepared.rect)&#13;
        prepared.rect = prepared.view.text.getBoundingClientRect();&#13;
      if (!prepared.hasHeights) {&#13;
        ensureLineHeights(cm, prepared.view, prepared.rect);&#13;
        prepared.hasHeights = true;&#13;
      }&#13;
      found = measureCharInner(cm, prepared, ch, bias);&#13;
      if (!found.bogus) prepared.cache[key] = found;&#13;
    }&#13;
    return {left: found.left, right: found.right,&#13;
            top: varHeight ? found.rtop : found.top,&#13;
            bottom: varHeight ? found.rbottom : found.bottom};&#13;
  }&#13;
&#13;
  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};&#13;
&#13;
  function nodeAndOffsetInLineMap(map, ch, bias) {&#13;
    var node, start, end, collapse;&#13;
    // First, search the line map for the text node corresponding to,&#13;
    // or closest to, the target character.&#13;
    for (var i = 0; i &lt; map.length; i += 3) {&#13;
      var mStart = map[i], mEnd = map[i + 1];&#13;
      if (ch &lt; mStart) {&#13;
        start = 0; end = 1;&#13;
        collapse = "left";&#13;
      } else if (ch &lt; mEnd) {&#13;
        start = ch - mStart;&#13;
        end = start + 1;&#13;
      } else if (i == map.length - 3 || ch == mEnd &amp;&amp; map[i + 3] &gt; ch) {&#13;
        end = mEnd - mStart;&#13;
        start = end - 1;&#13;
        if (ch &gt;= mEnd) collapse = "right";&#13;
      }&#13;
      if (start != null) {&#13;
        node = map[i + 2];&#13;
        if (mStart == mEnd &amp;&amp; bias == (node.insertLeft ? "left" : "right"))&#13;
          collapse = bias;&#13;
        if (bias == "left" &amp;&amp; start == 0)&#13;
          while (i &amp;&amp; map[i - 2] == map[i - 3] &amp;&amp; map[i - 1].insertLeft) {&#13;
            node = map[(i -= 3) + 2];&#13;
            collapse = "left";&#13;
          }&#13;
        if (bias == "right" &amp;&amp; start == mEnd - mStart)&#13;
          while (i &lt; map.length - 3 &amp;&amp; map[i + 3] == map[i + 4] &amp;&amp; !map[i + 5].insertLeft) {&#13;
            node = map[(i += 3) + 2];&#13;
            collapse = "right";&#13;
          }&#13;
        break;&#13;
      }&#13;
    }&#13;
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};&#13;
  }&#13;
&#13;
  function measureCharInner(cm, prepared, ch, bias) {&#13;
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);&#13;
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;&#13;
&#13;
    var rect;&#13;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.&#13;
      for (var i = 0; i &lt; 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned&#13;
        while (start &amp;&amp; isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;&#13;
        while (place.coverStart + end &lt; place.coverEnd &amp;&amp; isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;&#13;
        if (ie &amp;&amp; ie_version &lt; 9 &amp;&amp; start == 0 &amp;&amp; end == place.coverEnd - place.coverStart) {&#13;
          rect = node.parentNode.getBoundingClientRect();&#13;
        } else if (ie &amp;&amp; cm.options.lineWrapping) {&#13;
          var rects = range(node, start, end).getClientRects();&#13;
          if (rects.length)&#13;
            rect = rects[bias == "right" ? rects.length - 1 : 0];&#13;
          else&#13;
            rect = nullRect;&#13;
        } else {&#13;
          rect = range(node, start, end).getBoundingClientRect() || nullRect;&#13;
        }&#13;
        if (rect.left || rect.right || start == 0) break;&#13;
        end = start;&#13;
        start = start - 1;&#13;
        collapse = "right";&#13;
      }&#13;
      if (ie &amp;&amp; ie_version &lt; 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);&#13;
    } else { // If it is a widget, simply get the box for the whole widget.&#13;
      if (start &gt; 0) collapse = bias = "right";&#13;
      var rects;&#13;
      if (cm.options.lineWrapping &amp;&amp; (rects = node.getClientRects()).length &gt; 1)&#13;
        rect = rects[bias == "right" ? rects.length - 1 : 0];&#13;
      else&#13;
        rect = node.getBoundingClientRect();&#13;
    }&#13;
    if (ie &amp;&amp; ie_version &lt; 9 &amp;&amp; !start &amp;&amp; (!rect || !rect.left &amp;&amp; !rect.right)) {&#13;
      var rSpan = node.parentNode.getClientRects()[0];&#13;
      if (rSpan)&#13;
        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};&#13;
      else&#13;
        rect = nullRect;&#13;
    }&#13;
&#13;
    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;&#13;
    var mid = (rtop + rbot) / 2;&#13;
    var heights = prepared.view.measure.heights;&#13;
    for (var i = 0; i &lt; heights.length - 1; i++)&#13;
      if (mid &lt; heights[i]) break;&#13;
    var top = i ? heights[i - 1] : 0, bot = heights[i];&#13;
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,&#13;
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,&#13;
                  top: top, bottom: bot};&#13;
    if (!rect.left &amp;&amp; !rect.right) result.bogus = true;&#13;
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }&#13;
&#13;
    return result;&#13;
  }&#13;
&#13;
  // Work around problem with bounding client rects on ranges being&#13;
  // returned incorrectly when zoomed on IE10 and below.&#13;
  function maybeUpdateRectForZooming(measure, rect) {&#13;
    if (!window.screen || screen.logicalXDPI == null ||&#13;
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))&#13;
      return rect;&#13;
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;&#13;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;&#13;
    return {left: rect.left * scaleX, right: rect.right * scaleX,&#13;
            top: rect.top * scaleY, bottom: rect.bottom * scaleY};&#13;
  }&#13;
&#13;
  function clearLineMeasurementCacheFor(lineView) {&#13;
    if (lineView.measure) {&#13;
      lineView.measure.cache = {};&#13;
      lineView.measure.heights = null;&#13;
      if (lineView.rest) for (var i = 0; i &lt; lineView.rest.length; i++)&#13;
        lineView.measure.caches[i] = {};&#13;
    }&#13;
  }&#13;
&#13;
  function clearLineMeasurementCache(cm) {&#13;
    cm.display.externalMeasure = null;&#13;
    removeChildren(cm.display.lineMeasure);&#13;
    for (var i = 0; i &lt; cm.display.view.length; i++)&#13;
      clearLineMeasurementCacheFor(cm.display.view[i]);&#13;
  }&#13;
&#13;
  function clearCaches(cm) {&#13;
    clearLineMeasurementCache(cm);&#13;
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;&#13;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;&#13;
    cm.display.lineNumChars = null;&#13;
  }&#13;
&#13;
  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }&#13;
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }&#13;
&#13;
  // Converts a {top, bottom, left, right} box from line-local&#13;
  // coordinates into another coordinate system. Context may be one of&#13;
  // "line", "div" (display.lineDiv), "local"/null (editor), "window",&#13;
  // or "page".&#13;
  function intoCoordSystem(cm, lineObj, rect, context) {&#13;
    if (lineObj.widgets) for (var i = 0; i &lt; lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {&#13;
      var size = widgetHeight(lineObj.widgets[i]);&#13;
      rect.top += size; rect.bottom += size;&#13;
    }&#13;
    if (context == "line") return rect;&#13;
    if (!context) context = "local";&#13;
    var yOff = heightAtLine(lineObj);&#13;
    if (context == "local") yOff += paddingTop(cm.display);&#13;
    else yOff -= cm.display.viewOffset;&#13;
    if (context == "page" || context == "window") {&#13;
      var lOff = cm.display.lineSpace.getBoundingClientRect();&#13;
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());&#13;
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());&#13;
      rect.left += xOff; rect.right += xOff;&#13;
    }&#13;
    rect.top += yOff; rect.bottom += yOff;&#13;
    return rect;&#13;
  }&#13;
&#13;
  // Coverts a box from "div" coords to another coordinate system.&#13;
  // Context may be "window", "page", "div", or "local"/null.&#13;
  function fromCoordSystem(cm, coords, context) {&#13;
    if (context == "div") return coords;&#13;
    var left = coords.left, top = coords.top;&#13;
    // First move into "page" coordinate system&#13;
    if (context == "page") {&#13;
      left -= pageScrollX();&#13;
      top -= pageScrollY();&#13;
    } else if (context == "local" || !context) {&#13;
      var localBox = cm.display.sizer.getBoundingClientRect();&#13;
      left += localBox.left;&#13;
      top += localBox.top;&#13;
    }&#13;
&#13;
    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();&#13;
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};&#13;
  }&#13;
&#13;
  function charCoords(cm, pos, context, lineObj, bias) {&#13;
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);&#13;
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);&#13;
  }&#13;
&#13;
  // Returns a box for a given cursor position, which may have an&#13;
  // 'other' property containing the position of the secondary cursor&#13;
  // on a bidi boundary.&#13;
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {&#13;
    lineObj = lineObj || getLine(cm.doc, pos.line);&#13;
    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);&#13;
    function get(ch, right) {&#13;
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);&#13;
      if (right) m.left = m.right; else m.right = m.left;&#13;
      return intoCoordSystem(cm, lineObj, m, context);&#13;
    }&#13;
    function getBidi(ch, partPos) {&#13;
      var part = order[partPos], right = part.level % 2;&#13;
      if (ch == bidiLeft(part) &amp;&amp; partPos &amp;&amp; part.level &lt; order[partPos - 1].level) {&#13;
        part = order[--partPos];&#13;
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);&#13;
        right = true;&#13;
      } else if (ch == bidiRight(part) &amp;&amp; partPos &lt; order.length - 1 &amp;&amp; part.level &lt; order[partPos + 1].level) {&#13;
        part = order[++partPos];&#13;
        ch = bidiLeft(part) - part.level % 2;&#13;
        right = false;&#13;
      }&#13;
      if (right &amp;&amp; ch == part.to &amp;&amp; ch &gt; part.from) return get(ch - 1);&#13;
      return get(ch, right);&#13;
    }&#13;
    var order = getOrder(lineObj), ch = pos.ch;&#13;
    if (!order) return get(ch);&#13;
    var partPos = getBidiPartAt(order, ch);&#13;
    var val = getBidi(ch, partPos);&#13;
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);&#13;
    return val;&#13;
  }&#13;
&#13;
  // Used to cheaply estimate the coordinates for a position. Used for&#13;
  // intermediate scroll updates.&#13;
  function estimateCoords(cm, pos) {&#13;
    var left = 0, pos = clipPos(cm.doc, pos);&#13;
    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;&#13;
    var lineObj = getLine(cm.doc, pos.line);&#13;
    var top = heightAtLine(lineObj) + paddingTop(cm.display);&#13;
    return {left: left, right: left, top: top, bottom: top + lineObj.height};&#13;
  }&#13;
&#13;
  // Positions returned by coordsChar contain some extra information.&#13;
  // xRel is the relative x position of the input coordinates compared&#13;
  // to the found position (so xRel &gt; 0 means the coordinates are to&#13;
  // the right of the character position, for example). When outside&#13;
  // is true, that means the coordinates lie outside the line's&#13;
  // vertical range.&#13;
  function PosWithInfo(line, ch, outside, xRel) {&#13;
    var pos = Pos(line, ch);&#13;
    pos.xRel = xRel;&#13;
    if (outside) pos.outside = true;&#13;
    return pos;&#13;
  }&#13;
&#13;
  // Compute the character position closest to the given coordinates.&#13;
  // Input must be lineSpace-local ("div" coordinate system).&#13;
  function coordsChar(cm, x, y) {&#13;
    var doc = cm.doc;&#13;
    y += cm.display.viewOffset;&#13;
    if (y &lt; 0) return PosWithInfo(doc.first, 0, true, -1);&#13;
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;&#13;
    if (lineN &gt; last)&#13;
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);&#13;
    if (x &lt; 0) x = 0;&#13;
&#13;
    var lineObj = getLine(doc, lineN);&#13;
    for (;;) {&#13;
      var found = coordsCharInner(cm, lineObj, lineN, x, y);&#13;
      var merged = collapsedSpanAtEnd(lineObj);&#13;
      var mergedPos = merged &amp;&amp; merged.find(0, true);&#13;
      if (merged &amp;&amp; (found.ch &gt; mergedPos.from.ch || found.ch == mergedPos.from.ch &amp;&amp; found.xRel &gt; 0))&#13;
        lineN = lineNo(lineObj = mergedPos.to.line);&#13;
      else&#13;
        return found;&#13;
    }&#13;
  }&#13;
&#13;
  function coordsCharInner(cm, lineObj, lineNo, x, y) {&#13;
    var innerOff = y - heightAtLine(lineObj);&#13;
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;&#13;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);&#13;
&#13;
    function getX(ch) {&#13;
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);&#13;
      wrongLine = true;&#13;
      if (innerOff &gt; sp.bottom) return sp.left - adjust;&#13;
      else if (innerOff &lt; sp.top) return sp.left + adjust;&#13;
      else wrongLine = false;&#13;
      return sp.left;&#13;
    }&#13;
&#13;
    var bidi = getOrder(lineObj), dist = lineObj.text.length;&#13;
    var from = lineLeft(lineObj), to = lineRight(lineObj);&#13;
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;&#13;
&#13;
    if (x &gt; toX) return PosWithInfo(lineNo, to, toOutside, 1);&#13;
    // Do a binary search between these bounds.&#13;
    for (;;) {&#13;
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from &lt;= 1) {&#13;
        var ch = x &lt; fromX || x - fromX &lt;= toX - x ? from : to;&#13;
        var xDiff = x - (ch == from ? fromX : toX);&#13;
        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;&#13;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,&#13;
                              xDiff &lt; -1 ? -1 : xDiff &gt; 1 ? 1 : 0);&#13;
        return pos;&#13;
      }&#13;
      var step = Math.ceil(dist / 2), middle = from + step;&#13;
      if (bidi) {&#13;
        middle = from;&#13;
        for (var i = 0; i &lt; step; ++i) middle = moveVisually(lineObj, middle, 1);&#13;
      }&#13;
      var middleX = getX(middle);&#13;
      if (middleX &gt; x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}&#13;
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}&#13;
    }&#13;
  }&#13;
&#13;
  var measureText;&#13;
  // Compute the default text height.&#13;
  function textHeight(display) {&#13;
    if (display.cachedTextHeight != null) return display.cachedTextHeight;&#13;
    if (measureText == null) {&#13;
      measureText = elt("pre");&#13;
      // Measure a bunch of lines, for browsers that compute&#13;
      // fractional heights.&#13;
      for (var i = 0; i &lt; 49; ++i) {&#13;
        measureText.appendChild(document.createTextNode("x"));&#13;
        measureText.appendChild(elt("br"));&#13;
      }&#13;
      measureText.appendChild(document.createTextNode("x"));&#13;
    }&#13;
    removeChildrenAndAdd(display.measure, measureText);&#13;
    var height = measureText.offsetHeight / 50;&#13;
    if (height &gt; 3) display.cachedTextHeight = height;&#13;
    removeChildren(display.measure);&#13;
    return height || 1;&#13;
  }&#13;
&#13;
  // Compute the default character width.&#13;
  function charWidth(display) {&#13;
    if (display.cachedCharWidth != null) return display.cachedCharWidth;&#13;
    var anchor = elt("span", "xxxxxxxxxx");&#13;
    var pre = elt("pre", [anchor]);&#13;
    removeChildrenAndAdd(display.measure, pre);&#13;
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;&#13;
    if (width &gt; 2) display.cachedCharWidth = width;&#13;
    return width || 10;&#13;
  }&#13;
&#13;
  // OPERATIONS&#13;
&#13;
  // Operations are used to wrap a series of changes to the editor&#13;
  // state in such a way that each change won't have to update the&#13;
  // cursor and display (which would be awkward, slow, and&#13;
  // error-prone). Instead, display updates are batched and then all&#13;
  // combined and executed at once.&#13;
&#13;
  var operationGroup = null;&#13;
&#13;
  var nextOpId = 0;&#13;
  // Start a new operation.&#13;
  function startOperation(cm) {&#13;
    cm.curOp = {&#13;
      cm: cm,&#13;
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn&#13;
      startHeight: cm.doc.height, // Used to detect need to update scrollbar&#13;
      forceUpdate: false,      // Used to force a redraw&#13;
      updateInput: null,       // Whether to reset the input textarea&#13;
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)&#13;
      changeObjs: null,        // Accumulated changes, for firing change events&#13;
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on&#13;
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already&#13;
      selectionChanged: false, // Whether the selection needs to be redrawn&#13;
      updateMaxLine: false,    // Set when the widest line needs to be determined anew&#13;
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet&#13;
      scrollToPos: null,       // Used to scroll to a specific position&#13;
      focus: false,&#13;
      id: ++nextOpId           // Unique ID&#13;
    };&#13;
    if (operationGroup) {&#13;
      operationGroup.ops.push(cm.curOp);&#13;
    } else {&#13;
      cm.curOp.ownsGroup = operationGroup = {&#13;
        ops: [cm.curOp],&#13;
        delayedCallbacks: []&#13;
      };&#13;
    }&#13;
  }&#13;
&#13;
  function fireCallbacksForOps(group) {&#13;
    // Calls delayed callbacks and cursorActivity handlers until no&#13;
    // new ones appear&#13;
    var callbacks = group.delayedCallbacks, i = 0;&#13;
    do {&#13;
      for (; i &lt; callbacks.length; i++)&#13;
        callbacks[i].call(null);&#13;
      for (var j = 0; j &lt; group.ops.length; j++) {&#13;
        var op = group.ops[j];&#13;
        if (op.cursorActivityHandlers)&#13;
          while (op.cursorActivityCalled &lt; op.cursorActivityHandlers.length)&#13;
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);&#13;
      }&#13;
    } while (i &lt; callbacks.length);&#13;
  }&#13;
&#13;
  // Finish an operation, updating the display and signalling delayed events&#13;
  function endOperation(cm) {&#13;
    var op = cm.curOp, group = op.ownsGroup;&#13;
    if (!group) return;&#13;
&#13;
    try { fireCallbacksForOps(group); }&#13;
    finally {&#13;
      operationGroup = null;&#13;
      for (var i = 0; i &lt; group.ops.length; i++)&#13;
        group.ops[i].cm.curOp = null;&#13;
      endOperations(group);&#13;
    }&#13;
  }&#13;
&#13;
  // The DOM updates done when an operation finishes are batched so&#13;
  // that the minimum number of relayouts are required.&#13;
  function endOperations(group) {&#13;
    var ops = group.ops;&#13;
    for (var i = 0; i &lt; ops.length; i++) // Read DOM&#13;
      endOperation_R1(ops[i]);&#13;
    for (var i = 0; i &lt; ops.length; i++) // Write DOM (maybe)&#13;
      endOperation_W1(ops[i]);&#13;
    for (var i = 0; i &lt; ops.length; i++) // Read DOM&#13;
      endOperation_R2(ops[i]);&#13;
    for (var i = 0; i &lt; ops.length; i++) // Write DOM (maybe)&#13;
      endOperation_W2(ops[i]);&#13;
    for (var i = 0; i &lt; ops.length; i++) // Read DOM&#13;
      endOperation_finish(ops[i]);&#13;
  }&#13;
&#13;
  function endOperation_R1(op) {&#13;
    var cm = op.cm, display = cm.display;&#13;
    maybeClipScrollbars(cm);&#13;
    if (op.updateMaxLine) findMaxLine(cm);&#13;
&#13;
    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||&#13;
      op.scrollToPos &amp;&amp; (op.scrollToPos.from.line &lt; display.viewFrom ||&#13;
                         op.scrollToPos.to.line &gt;= display.viewTo) ||&#13;
      display.maxLineChanged &amp;&amp; cm.options.lineWrapping;&#13;
    op.update = op.mustUpdate &amp;&amp;&#13;
      new DisplayUpdate(cm, op.mustUpdate &amp;&amp; {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);&#13;
  }&#13;
&#13;
  function endOperation_W1(op) {&#13;
    op.updatedDisplay = op.mustUpdate &amp;&amp; updateDisplayIfNeeded(op.cm, op.update);&#13;
  }&#13;
&#13;
  function endOperation_R2(op) {&#13;
    var cm = op.cm, display = cm.display;&#13;
    if (op.updatedDisplay) updateHeightsInViewport(cm);&#13;
&#13;
    op.barMeasure = measureForScrollbars(cm);&#13;
&#13;
    // If the max line changed since it was last measured, measure it,&#13;
    // and ensure the document's width matches it.&#13;
    // updateDisplay_W2 will use these properties to do the actual resizing&#13;
    if (display.maxLineChanged &amp;&amp; !cm.options.lineWrapping) {&#13;
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;&#13;
      cm.display.sizerWidth = op.adjustWidthTo;&#13;
      op.barMeasure.scrollWidth =&#13;
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);&#13;
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));&#13;
    }&#13;
&#13;
    if (op.updatedDisplay || op.selectionChanged)&#13;
      op.preparedSelection = display.input.prepareSelection(op.focus);&#13;
  }&#13;
&#13;
  function endOperation_W2(op) {&#13;
    var cm = op.cm;&#13;
&#13;
    if (op.adjustWidthTo != null) {&#13;
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";&#13;
      if (op.maxScrollLeft &lt; cm.doc.scrollLeft)&#13;
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);&#13;
      cm.display.maxLineChanged = false;&#13;
    }&#13;
&#13;
    var takeFocus = op.focus &amp;&amp; op.focus == activeElt() &amp;&amp; (!document.hasFocus || document.hasFocus())&#13;
    if (op.preparedSelection)&#13;
      cm.display.input.showSelection(op.preparedSelection, takeFocus);&#13;
    if (op.updatedDisplay || op.startHeight != cm.doc.height)&#13;
      updateScrollbars(cm, op.barMeasure);&#13;
    if (op.updatedDisplay)&#13;
      setDocumentHeight(cm, op.barMeasure);&#13;
&#13;
    if (op.selectionChanged) restartBlink(cm);&#13;
&#13;
    if (cm.state.focused &amp;&amp; op.updateInput)&#13;
      cm.display.input.reset(op.typing);&#13;
    if (takeFocus) ensureFocus(op.cm);&#13;
  }&#13;
&#13;
  function endOperation_finish(op) {&#13;
    var cm = op.cm, display = cm.display, doc = cm.doc;&#13;
&#13;
    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);&#13;
&#13;
    // Abort mouse wheel delta measurement, when scrolling explicitly&#13;
    if (display.wheelStartX != null &amp;&amp; (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))&#13;
      display.wheelStartX = display.wheelStartY = null;&#13;
&#13;
    // Propagate the scroll position to the actual DOM scroller&#13;
    if (op.scrollTop != null &amp;&amp; (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {&#13;
      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));&#13;
      display.scrollbars.setScrollTop(doc.scrollTop);&#13;
      display.scroller.scrollTop = doc.scrollTop;&#13;
    }&#13;
    if (op.scrollLeft != null &amp;&amp; (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {&#13;
      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));&#13;
      display.scrollbars.setScrollLeft(doc.scrollLeft);&#13;
      display.scroller.scrollLeft = doc.scrollLeft;&#13;
      alignHorizontally(cm);&#13;
    }&#13;
    // If we need to scroll a specific position into view, do so.&#13;
    if (op.scrollToPos) {&#13;
      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),&#13;
                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);&#13;
      if (op.scrollToPos.isCursor &amp;&amp; cm.state.focused) maybeScrollWindow(cm, coords);&#13;
    }&#13;
&#13;
    // Fire events for markers that are hidden/unidden by editing or&#13;
    // undoing&#13;
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;&#13;
    if (hidden) for (var i = 0; i &lt; hidden.length; ++i)&#13;
      if (!hidden[i].lines.length) signal(hidden[i], "hide");&#13;
    if (unhidden) for (var i = 0; i &lt; unhidden.length; ++i)&#13;
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");&#13;
&#13;
    if (display.wrapper.offsetHeight)&#13;
      doc.scrollTop = cm.display.scroller.scrollTop;&#13;
&#13;
    // Fire change events, and delayed event handlers&#13;
    if (op.changeObjs)&#13;
      signal(cm, "changes", cm, op.changeObjs);&#13;
    if (op.update)&#13;
      op.update.finish();&#13;
  }&#13;
&#13;
  // Run the given function in an operation&#13;
  function runInOp(cm, f) {&#13;
    if (cm.curOp) return f();&#13;
    startOperation(cm);&#13;
    try { return f(); }&#13;
    finally { endOperation(cm); }&#13;
  }&#13;
  // Wraps a function in an operation. Returns the wrapped function.&#13;
  function operation(cm, f) {&#13;
    return function() {&#13;
      if (cm.curOp) return f.apply(cm, arguments);&#13;
      startOperation(cm);&#13;
      try { return f.apply(cm, arguments); }&#13;
      finally { endOperation(cm); }&#13;
    };&#13;
  }&#13;
  // Used to add methods to editor and doc instances, wrapping them in&#13;
  // operations.&#13;
  function methodOp(f) {&#13;
    return function() {&#13;
      if (this.curOp) return f.apply(this, arguments);&#13;
      startOperation(this);&#13;
      try { return f.apply(this, arguments); }&#13;
      finally { endOperation(this); }&#13;
    };&#13;
  }&#13;
  function docMethodOp(f) {&#13;
    return function() {&#13;
      var cm = this.cm;&#13;
      if (!cm || cm.curOp) return f.apply(this, arguments);&#13;
      startOperation(cm);&#13;
      try { return f.apply(this, arguments); }&#13;
      finally { endOperation(cm); }&#13;
    };&#13;
  }&#13;
&#13;
  // VIEW TRACKING&#13;
&#13;
  // These objects are used to represent the visible (currently drawn)&#13;
  // part of the document. A LineView may correspond to multiple&#13;
  // logical lines, if those are connected by collapsed ranges.&#13;
  function LineView(doc, line, lineN) {&#13;
    // The starting line&#13;
    this.line = line;&#13;
    // Continuing lines, if any&#13;
    this.rest = visualLineContinued(line);&#13;
    // Number of logical lines in this visual line&#13;
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;&#13;
    this.node = this.text = null;&#13;
    this.hidden = lineIsHidden(doc, line);&#13;
  }&#13;
&#13;
  // Create a range of LineView objects for the given lines.&#13;
  function buildViewArray(cm, from, to) {&#13;
    var array = [], nextPos;&#13;
    for (var pos = from; pos &lt; to; pos = nextPos) {&#13;
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);&#13;
      nextPos = pos + view.size;&#13;
      array.push(view);&#13;
    }&#13;
    return array;&#13;
  }&#13;
&#13;
  // Updates the display.view data structure for a given change to the&#13;
  // document. From and to are in pre-change coordinates. Lendiff is&#13;
  // the amount of lines added or subtracted by the change. This is&#13;
  // used for changes that span multiple lines, or change the way&#13;
  // lines are divided into visual lines. regLineChange (below)&#13;
  // registers single-line changes.&#13;
  function regChange(cm, from, to, lendiff) {&#13;
    if (from == null) from = cm.doc.first;&#13;
    if (to == null) to = cm.doc.first + cm.doc.size;&#13;
    if (!lendiff) lendiff = 0;&#13;
&#13;
    var display = cm.display;&#13;
    if (lendiff &amp;&amp; to &lt; display.viewTo &amp;&amp;&#13;
        (display.updateLineNumbers == null || display.updateLineNumbers &gt; from))&#13;
      display.updateLineNumbers = from;&#13;
&#13;
    cm.curOp.viewChanged = true;&#13;
&#13;
    if (from &gt;= display.viewTo) { // Change after&#13;
      if (sawCollapsedSpans &amp;&amp; visualLineNo(cm.doc, from) &lt; display.viewTo)&#13;
        resetView(cm);&#13;
    } else if (to &lt;= display.viewFrom) { // Change before&#13;
      if (sawCollapsedSpans &amp;&amp; visualLineEndNo(cm.doc, to + lendiff) &gt; display.viewFrom) {&#13;
        resetView(cm);&#13;
      } else {&#13;
        display.viewFrom += lendiff;&#13;
        display.viewTo += lendiff;&#13;
      }&#13;
    } else if (from &lt;= display.viewFrom &amp;&amp; to &gt;= display.viewTo) { // Full overlap&#13;
      resetView(cm);&#13;
    } else if (from &lt;= display.viewFrom) { // Top overlap&#13;
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);&#13;
      if (cut) {&#13;
        display.view = display.view.slice(cut.index);&#13;
        display.viewFrom = cut.lineN;&#13;
        display.viewTo += lendiff;&#13;
      } else {&#13;
        resetView(cm);&#13;
      }&#13;
    } else if (to &gt;= display.viewTo) { // Bottom overlap&#13;
      var cut = viewCuttingPoint(cm, from, from, -1);&#13;
      if (cut) {&#13;
        display.view = display.view.slice(0, cut.index);&#13;
        display.viewTo = cut.lineN;&#13;
      } else {&#13;
        resetView(cm);&#13;
      }&#13;
    } else { // Gap in the middle&#13;
      var cutTop = viewCuttingPoint(cm, from, from, -1);&#13;
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);&#13;
      if (cutTop &amp;&amp; cutBot) {&#13;
        display.view = display.view.slice(0, cutTop.index)&#13;
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))&#13;
          .concat(display.view.slice(cutBot.index));&#13;
        display.viewTo += lendiff;&#13;
      } else {&#13;
        resetView(cm);&#13;
      }&#13;
    }&#13;
&#13;
    var ext = display.externalMeasured;&#13;
    if (ext) {&#13;
      if (to &lt; ext.lineN)&#13;
        ext.lineN += lendiff;&#13;
      else if (from &lt; ext.lineN + ext.size)&#13;
        display.externalMeasured = null;&#13;
    }&#13;
  }&#13;
&#13;
  // Register a change to a single line. Type must be one of "text",&#13;
  // "gutter", "class", "widget"&#13;
  function regLineChange(cm, line, type) {&#13;
    cm.curOp.viewChanged = true;&#13;
    var display = cm.display, ext = cm.display.externalMeasured;&#13;
    if (ext &amp;&amp; line &gt;= ext.lineN &amp;&amp; line &lt; ext.lineN + ext.size)&#13;
      display.externalMeasured = null;&#13;
&#13;
    if (line &lt; display.viewFrom || line &gt;= display.viewTo) return;&#13;
    var lineView = display.view[findViewIndex(cm, line)];&#13;
    if (lineView.node == null) return;&#13;
    var arr = lineView.changes || (lineView.changes = []);&#13;
    if (indexOf(arr, type) == -1) arr.push(type);&#13;
  }&#13;
&#13;
  // Clear the view.&#13;
  function resetView(cm) {&#13;
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;&#13;
    cm.display.view = [];&#13;
    cm.display.viewOffset = 0;&#13;
  }&#13;
&#13;
  // Find the view element corresponding to a given line. Return null&#13;
  // when the line isn't visible.&#13;
  function findViewIndex(cm, n) {&#13;
    if (n &gt;= cm.display.viewTo) return null;&#13;
    n -= cm.display.viewFrom;&#13;
    if (n &lt; 0) return null;&#13;
    var view = cm.display.view;&#13;
    for (var i = 0; i &lt; view.length; i++) {&#13;
      n -= view[i].size;&#13;
      if (n &lt; 0) return i;&#13;
    }&#13;
  }&#13;
&#13;
  function viewCuttingPoint(cm, oldN, newN, dir) {&#13;
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;&#13;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)&#13;
      return {index: index, lineN: newN};&#13;
    for (var i = 0, n = cm.display.viewFrom; i &lt; index; i++)&#13;
      n += view[i].size;&#13;
    if (n != oldN) {&#13;
      if (dir &gt; 0) {&#13;
        if (index == view.length - 1) return null;&#13;
        diff = (n + view[index].size) - oldN;&#13;
        index++;&#13;
      } else {&#13;
        diff = n - oldN;&#13;
      }&#13;
      oldN += diff; newN += diff;&#13;
    }&#13;
    while (visualLineNo(cm.doc, newN) != newN) {&#13;
      if (index == (dir &lt; 0 ? 0 : view.length - 1)) return null;&#13;
      newN += dir * view[index - (dir &lt; 0 ? 1 : 0)].size;&#13;
      index += dir;&#13;
    }&#13;
    return {index: index, lineN: newN};&#13;
  }&#13;
&#13;
  // Force the view to cover a given range, adding empty view element&#13;
  // or clipping off existing ones as needed.&#13;
  function adjustView(cm, from, to) {&#13;
    var display = cm.display, view = display.view;&#13;
    if (view.length == 0 || from &gt;= display.viewTo || to &lt;= display.viewFrom) {&#13;
      display.view = buildViewArray(cm, from, to);&#13;
      display.viewFrom = from;&#13;
    } else {&#13;
      if (display.viewFrom &gt; from)&#13;
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);&#13;
      else if (display.viewFrom &lt; from)&#13;
        display.view = display.view.slice(findViewIndex(cm, from));&#13;
      display.viewFrom = from;&#13;
      if (display.viewTo &lt; to)&#13;
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));&#13;
      else if (display.viewTo &gt; to)&#13;
        display.view = display.view.slice(0, findViewIndex(cm, to));&#13;
    }&#13;
    display.viewTo = to;&#13;
  }&#13;
&#13;
  // Count the number of lines in the view whose DOM representation is&#13;
  // out of date (or nonexistent).&#13;
  function countDirtyView(cm) {&#13;
    var view = cm.display.view, dirty = 0;&#13;
    for (var i = 0; i &lt; view.length; i++) {&#13;
      var lineView = view[i];&#13;
      if (!lineView.hidden &amp;&amp; (!lineView.node || lineView.changes)) ++dirty;&#13;
    }&#13;
    return dirty;&#13;
  }&#13;
&#13;
  // EVENT HANDLERS&#13;
&#13;
  // Attach the necessary event handlers when initializing the editor&#13;
  function registerEventHandlers(cm) {&#13;
    var d = cm.display;&#13;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));&#13;
    // Older IE's will not fire a second mousedown for a double click&#13;
    if (ie &amp;&amp; ie_version &lt; 11)&#13;
      on(d.scroller, "dblclick", operation(cm, function(e) {&#13;
        if (signalDOMEvent(cm, e)) return;&#13;
        var pos = posFromMouse(cm, e);&#13;
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;&#13;
        e_preventDefault(e);&#13;
        var word = cm.findWordAt(pos);&#13;
        extendSelection(cm.doc, word.anchor, word.head);&#13;
      }));&#13;
    else&#13;
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });&#13;
    // Some browsers fire contextmenu *after* opening the menu, at&#13;
    // which point we can't mess with it anymore. Context menu is&#13;
    // handled in onMouseDown for these browsers.&#13;
    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});&#13;
&#13;
    // Used to suppress mouse event handling when a touch happens&#13;
    var touchFinished, prevTouch = {end: 0};&#13;
    function finishTouch() {&#13;
      if (d.activeTouch) {&#13;
        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);&#13;
        prevTouch = d.activeTouch;&#13;
        prevTouch.end = +new Date;&#13;
      }&#13;
    };&#13;
    function isMouseLikeTouchEvent(e) {&#13;
      if (e.touches.length != 1) return false;&#13;
      var touch = e.touches[0];&#13;
      return touch.radiusX &lt;= 1 &amp;&amp; touch.radiusY &lt;= 1;&#13;
    }&#13;
    function farAway(touch, other) {&#13;
      if (other.left == null) return true;&#13;
      var dx = other.left - touch.left, dy = other.top - touch.top;&#13;
      return dx * dx + dy * dy &gt; 20 * 20;&#13;
    }&#13;
    on(d.scroller, "touchstart", function(e) {&#13;
      if (!signalDOMEvent(cm, e) &amp;&amp; !isMouseLikeTouchEvent(e)) {&#13;
        clearTimeout(touchFinished);&#13;
        var now = +new Date;&#13;
        d.activeTouch = {start: now, moved: false,&#13;
                         prev: now - prevTouch.end &lt;= 300 ? prevTouch : null};&#13;
        if (e.touches.length == 1) {&#13;
          d.activeTouch.left = e.touches[0].pageX;&#13;
          d.activeTouch.top = e.touches[0].pageY;&#13;
        }&#13;
      }&#13;
    });&#13;
    on(d.scroller, "touchmove", function() {&#13;
      if (d.activeTouch) d.activeTouch.moved = true;&#13;
    });&#13;
    on(d.scroller, "touchend", function(e) {&#13;
      var touch = d.activeTouch;&#13;
      if (touch &amp;&amp; !eventInWidget(d, e) &amp;&amp; touch.left != null &amp;&amp;&#13;
          !touch.moved &amp;&amp; new Date - touch.start &lt; 300) {&#13;
        var pos = cm.coordsChar(d.activeTouch, "page"), range;&#13;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap&#13;
          range = new Range(pos, pos);&#13;
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap&#13;
          range = cm.findWordAt(pos);&#13;
        else // Triple tap&#13;
          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));&#13;
        cm.setSelection(range.anchor, range.head);&#13;
        cm.focus();&#13;
        e_preventDefault(e);&#13;
      }&#13;
      finishTouch();&#13;
    });&#13;
    on(d.scroller, "touchcancel", finishTouch);&#13;
&#13;
    // Sync scrolling between fake scrollbars and real scrollable&#13;
    // area, ensure viewport is updated when scrolling.&#13;
    on(d.scroller, "scroll", function() {&#13;
      if (d.scroller.clientHeight) {&#13;
        setScrollTop(cm, d.scroller.scrollTop);&#13;
        setScrollLeft(cm, d.scroller.scrollLeft, true);&#13;
        signal(cm, "scroll", cm);&#13;
      }&#13;
    });&#13;
&#13;
    // Listen to wheel events in order to try and update the viewport on time.&#13;
    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});&#13;
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});&#13;
&#13;
    // Prevent wrapper from ever scrolling&#13;
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });&#13;
&#13;
    d.dragFunctions = {&#13;
      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},&#13;
      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},&#13;
      start: function(e){onDragStart(cm, e);},&#13;
      drop: operation(cm, onDrop),&#13;
      leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}&#13;
    };&#13;
&#13;
    var inp = d.input.getField();&#13;
    on(inp, "keyup", function(e) { onKeyUp.call(cm, e); });&#13;
    on(inp, "keydown", operation(cm, onKeyDown));&#13;
    on(inp, "keypress", operation(cm, onKeyPress));&#13;
    on(inp, "focus", bind(onFocus, cm));&#13;
    on(inp, "blur", bind(onBlur, cm));&#13;
  }&#13;
&#13;
  function dragDropChanged(cm, value, old) {&#13;
    var wasOn = old &amp;&amp; old != CodeMirror.Init;&#13;
    if (!value != !wasOn) {&#13;
      var funcs = cm.display.dragFunctions;&#13;
      var toggle = value ? on : off;&#13;
      toggle(cm.display.scroller, "dragstart", funcs.start);&#13;
      toggle(cm.display.scroller, "dragenter", funcs.enter);&#13;
      toggle(cm.display.scroller, "dragover", funcs.over);&#13;
      toggle(cm.display.scroller, "dragleave", funcs.leave);&#13;
      toggle(cm.display.scroller, "drop", funcs.drop);&#13;
    }&#13;
  }&#13;
&#13;
  // Called when the window resizes&#13;
  function onResize(cm) {&#13;
    var d = cm.display;&#13;
    if (d.lastWrapHeight == d.wrapper.clientHeight &amp;&amp; d.lastWrapWidth == d.wrapper.clientWidth)&#13;
      return;&#13;
    // Might be a text scaling operation, clear size caches.&#13;
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;&#13;
    d.scrollbarsClipped = false;&#13;
    cm.setSize();&#13;
  }&#13;
&#13;
  // MOUSE EVENTS&#13;
&#13;
  // Return true when the given mouse event happened in a widget&#13;
  function eventInWidget(display, e) {&#13;
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {&#13;
      if (!n || (n.nodeType == 1 &amp;&amp; n.getAttribute("cm-ignore-events") == "true") ||&#13;
          (n.parentNode == display.sizer &amp;&amp; n != display.mover))&#13;
        return true;&#13;
    }&#13;
  }&#13;
&#13;
  // Given a mouse event, find the corresponding position. If liberal&#13;
  // is false, it checks whether a gutter or scrollbar was clicked,&#13;
  // and returns null if it was. forRect is used by rectangular&#13;
  // selections, and tries to estimate a character position even for&#13;
  // coordinates beyond the right of the text.&#13;
  function posFromMouse(cm, e, liberal, forRect) {&#13;
    var display = cm.display;&#13;
    if (!liberal &amp;&amp; e_target(e).getAttribute("cm-not-content") == "true") return null;&#13;
&#13;
    var x, y, space = display.lineSpace.getBoundingClientRect();&#13;
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.&#13;
    try { x = e.clientX - space.left; y = e.clientY - space.top; }&#13;
    catch (e) { return null; }&#13;
    var coords = coordsChar(cm, x, y), line;&#13;
    if (forRect &amp;&amp; coords.xRel == 1 &amp;&amp; (line = getLine(cm.doc, coords.line).text).length == coords.ch) {&#13;
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;&#13;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));&#13;
    }&#13;
    return coords;&#13;
  }&#13;
&#13;
  // A mouse down can be a single click, double click, triple click,&#13;
  // start of selection drag, start of text drag, new cursor&#13;
  // (ctrl-click), rectangle drag (alt-drag), or xwin&#13;
  // middle-click-paste. Or it might be a click on something we should&#13;
  // not interfere with, such as a scrollbar or widget.&#13;
  function onMouseDown(e) {&#13;
    var cm = this, display = cm.display;&#13;
    if (signalDOMEvent(cm, e) || display.activeTouch &amp;&amp; display.input.supportsTouch()) return;&#13;
    display.shift = e.shiftKey;&#13;
&#13;
    if (eventInWidget(display, e)) {&#13;
      if (!webkit) {&#13;
        // Briefly turn off draggability, to allow widgets to do&#13;
        // normal dragging things.&#13;
        display.scroller.draggable = false;&#13;
        setTimeout(function(){display.scroller.draggable = true;}, 100);&#13;
      }&#13;
      return;&#13;
    }&#13;
    if (clickInGutter(cm, e)) return;&#13;
    var start = posFromMouse(cm, e);&#13;
    window.focus();&#13;
&#13;
    switch (e_button(e)) {&#13;
    case 1:&#13;
      // #3261: make sure, that we're not starting a second selection&#13;
      if (cm.state.selectingText)&#13;
        cm.state.selectingText(e);&#13;
      else if (start)&#13;
        leftButtonDown(cm, e, start);&#13;
      else if (e_target(e) == display.scroller)&#13;
        e_preventDefault(e);&#13;
      break;&#13;
    case 2:&#13;
      if (webkit) cm.state.lastMiddleDown = +new Date;&#13;
      if (start) extendSelection(cm.doc, start);&#13;
      setTimeout(function() {display.input.focus();}, 20);&#13;
      e_preventDefault(e);&#13;
      break;&#13;
    case 3:&#13;
      if (captureRightClick) onContextMenu(cm, e);&#13;
      else delayBlurEvent(cm);&#13;
      break;&#13;
    }&#13;
  }&#13;
&#13;
  var lastClick, lastDoubleClick;&#13;
  function leftButtonDown(cm, e, start) {&#13;
    if (ie) setTimeout(bind(ensureFocus, cm), 0);&#13;
    else cm.curOp.focus = activeElt();&#13;
&#13;
    var now = +new Date, type;&#13;
    if (lastDoubleClick &amp;&amp; lastDoubleClick.time &gt; now - 400 &amp;&amp; cmp(lastDoubleClick.pos, start) == 0) {&#13;
      type = "triple";&#13;
    } else if (lastClick &amp;&amp; lastClick.time &gt; now - 400 &amp;&amp; cmp(lastClick.pos, start) == 0) {&#13;
      type = "double";&#13;
      lastDoubleClick = {time: now, pos: start};&#13;
    } else {&#13;
      type = "single";&#13;
      lastClick = {time: now, pos: start};&#13;
    }&#13;
&#13;
    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;&#13;
    if (cm.options.dragDrop &amp;&amp; dragAndDrop &amp;&amp; !cm.isReadOnly() &amp;&amp;&#13;
        type == "single" &amp;&amp; (contained = sel.contains(start)) &gt; -1 &amp;&amp;&#13;
        (cmp((contained = sel.ranges[contained]).from(), start) &lt; 0 || start.xRel &gt; 0) &amp;&amp;&#13;
        (cmp(contained.to(), start) &gt; 0 || start.xRel &lt; 0))&#13;
      leftButtonStartDrag(cm, e, start, modifier);&#13;
    else&#13;
      leftButtonSelect(cm, e, start, type, modifier);&#13;
  }&#13;
&#13;
  // Start a text drag. When it ends, see if any dragging actually&#13;
  // happen, and treat as a click if it didn't.&#13;
  function leftButtonStartDrag(cm, e, start, modifier) {&#13;
    var display = cm.display, startTime = +new Date;&#13;
    var dragEnd = operation(cm, function(e2) {&#13;
      if (webkit) display.scroller.draggable = false;&#13;
      cm.state.draggingText = false;&#13;
      off(document, "mouseup", dragEnd);&#13;
      off(display.scroller, "drop", dragEnd);&#13;
      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) &lt; 10) {&#13;
        e_preventDefault(e2);&#13;
        if (!modifier &amp;&amp; +new Date - 200 &lt; startTime)&#13;
          extendSelection(cm.doc, start);&#13;
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)&#13;
        if (webkit || ie &amp;&amp; ie_version == 9)&#13;
          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);&#13;
        else&#13;
          display.input.focus();&#13;
      }&#13;
    });&#13;
    // Let the drag handler handle this.&#13;
    if (webkit) display.scroller.draggable = true;&#13;
    cm.state.draggingText = dragEnd;&#13;
    // IE's approach to draggable&#13;
    if (display.scroller.dragDrop) display.scroller.dragDrop();&#13;
    on(document, "mouseup", dragEnd);&#13;
    on(display.scroller, "drop", dragEnd);&#13;
  }&#13;
&#13;
  // Normal selection, as opposed to text dragging.&#13;
  function leftButtonSelect(cm, e, start, type, addNew) {&#13;
    var display = cm.display, doc = cm.doc;&#13;
    e_preventDefault(e);&#13;
&#13;
    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;&#13;
    if (addNew &amp;&amp; !e.shiftKey) {&#13;
      ourIndex = doc.sel.contains(start);&#13;
      if (ourIndex &gt; -1)&#13;
        ourRange = ranges[ourIndex];&#13;
      else&#13;
        ourRange = new Range(start, start);&#13;
    } else {&#13;
      ourRange = doc.sel.primary();&#13;
      ourIndex = doc.sel.primIndex;&#13;
    }&#13;
&#13;
    if (chromeOS ? e.shiftKey &amp;&amp; e.metaKey : e.altKey) {&#13;
      type = "rect";&#13;
      if (!addNew) ourRange = new Range(start, start);&#13;
      start = posFromMouse(cm, e, true, true);&#13;
      ourIndex = -1;&#13;
    } else if (type == "double") {&#13;
      var word = cm.findWordAt(start);&#13;
      if (cm.display.shift || doc.extend)&#13;
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);&#13;
      else&#13;
        ourRange = word;&#13;
    } else if (type == "triple") {&#13;
      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));&#13;
      if (cm.display.shift || doc.extend)&#13;
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);&#13;
      else&#13;
        ourRange = line;&#13;
    } else {&#13;
      ourRange = extendRange(doc, ourRange, start);&#13;
    }&#13;
&#13;
    if (!addNew) {&#13;
      ourIndex = 0;&#13;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);&#13;
      startSel = doc.sel;&#13;
    } else if (ourIndex == -1) {&#13;
      ourIndex = ranges.length;&#13;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),&#13;
                   {scroll: false, origin: "*mouse"});&#13;
    } else if (ranges.length &gt; 1 &amp;&amp; ranges[ourIndex].empty() &amp;&amp; type == "single" &amp;&amp; !e.shiftKey) {&#13;
      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),&#13;
                   {scroll: false, origin: "*mouse"});&#13;
      startSel = doc.sel;&#13;
    } else {&#13;
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);&#13;
    }&#13;
&#13;
    var lastPos = start;&#13;
    function extendTo(pos) {&#13;
      if (cmp(lastPos, pos) == 0) return;&#13;
      lastPos = pos;&#13;
&#13;
      if (type == "rect") {&#13;
        var ranges = [], tabSize = cm.options.tabSize;&#13;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);&#13;
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);&#13;
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);&#13;
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));&#13;
             line &lt;= end; line++) {&#13;
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);&#13;
          if (left == right)&#13;
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));&#13;
          else if (text.length &gt; leftPos)&#13;
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));&#13;
        }&#13;
        if (!ranges.length) ranges.push(new Range(start, start));&#13;
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),&#13;
                     {origin: "*mouse", scroll: false});&#13;
        cm.scrollIntoView(pos);&#13;
      } else {&#13;
        var oldRange = ourRange;&#13;
        var anchor = oldRange.anchor, head = pos;&#13;
        if (type != "single") {&#13;
          if (type == "double")&#13;
            var range = cm.findWordAt(pos);&#13;
          else&#13;
            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));&#13;
          if (cmp(range.anchor, anchor) &gt; 0) {&#13;
            head = range.head;&#13;
            anchor = minPos(oldRange.from(), range.anchor);&#13;
          } else {&#13;
            head = range.anchor;&#13;
            anchor = maxPos(oldRange.to(), range.head);&#13;
          }&#13;
        }&#13;
        var ranges = startSel.ranges.slice(0);&#13;
        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);&#13;
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);&#13;
      }&#13;
    }&#13;
&#13;
    var editorSize = display.wrapper.getBoundingClientRect();&#13;
    // Used to ensure timeout re-tries don't fire when another extend&#13;
    // happened in the meantime (clearTimeout isn't reliable -- at&#13;
    // least on Chrome, the timeouts still happen even when cleared,&#13;
    // if the clear happens after their scheduled firing time).&#13;
    var counter = 0;&#13;
&#13;
    function extend(e) {&#13;
      var curCount = ++counter;&#13;
      var cur = posFromMouse(cm, e, true, type == "rect");&#13;
      if (!cur) return;&#13;
      if (cmp(cur, lastPos) != 0) {&#13;
        cm.curOp.focus = activeElt();&#13;
        extendTo(cur);&#13;
        var visible = visibleLines(display, doc);&#13;
        if (cur.line &gt;= visible.to || cur.line &lt; visible.from)&#13;
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);&#13;
      } else {&#13;
        var outside = e.clientY &lt; editorSize.top ? -20 : e.clientY &gt; editorSize.bottom ? 20 : 0;&#13;
        if (outside) setTimeout(operation(cm, function() {&#13;
          if (counter != curCount) return;&#13;
          display.scroller.scrollTop += outside;&#13;
          extend(e);&#13;
        }), 50);&#13;
      }&#13;
    }&#13;
&#13;
    function done(e) {&#13;
      cm.state.selectingText = false;&#13;
      counter = Infinity;&#13;
      e_preventDefault(e);&#13;
      display.input.focus();&#13;
      off(document, "mousemove", move);&#13;
      off(document, "mouseup", up);&#13;
      doc.history.lastSelOrigin = null;&#13;
    }&#13;
&#13;
    var move = operation(cm, function(e) {&#13;
      if (!e_button(e)) done(e);&#13;
      else extend(e);&#13;
    });&#13;
    var up = operation(cm, done);&#13;
    cm.state.selectingText = up;&#13;
    on(document, "mousemove", move);&#13;
    on(document, "mouseup", up);&#13;
  }&#13;
&#13;
  // Determines whether an event happened in the gutter, and fires the&#13;
  // handlers for the corresponding event.&#13;
  function gutterEvent(cm, e, type, prevent) {&#13;
    try { var mX = e.clientX, mY = e.clientY; }&#13;
    catch(e) { return false; }&#13;
    if (mX &gt;= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;&#13;
    if (prevent) e_preventDefault(e);&#13;
&#13;
    var display = cm.display;&#13;
    var lineBox = display.lineDiv.getBoundingClientRect();&#13;
&#13;
    if (mY &gt; lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);&#13;
    mY -= lineBox.top - display.viewOffset;&#13;
&#13;
    for (var i = 0; i &lt; cm.options.gutters.length; ++i) {&#13;
      var g = display.gutters.childNodes[i];&#13;
      if (g &amp;&amp; g.getBoundingClientRect().right &gt;= mX) {&#13;
        var line = lineAtHeight(cm.doc, mY);&#13;
        var gutter = cm.options.gutters[i];&#13;
        signal(cm, type, cm, line, gutter, e);&#13;
        return e_defaultPrevented(e);&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function clickInGutter(cm, e) {&#13;
    return gutterEvent(cm, e, "gutterClick", true);&#13;
  }&#13;
&#13;
  // Kludge to work around strange IE behavior where it'll sometimes&#13;
  // re-fire a series of drag-related events right after the drop (#1551)&#13;
  var lastDrop = 0;&#13;
&#13;
  function onDrop(e) {&#13;
    var cm = this;&#13;
    clearDragCursor(cm);&#13;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))&#13;
      return;&#13;
    e_preventDefault(e);&#13;
    if (ie) lastDrop = +new Date;&#13;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;&#13;
    if (!pos || cm.isReadOnly()) return;&#13;
    // Might be a file drop, in which case we simply extract the text&#13;
    // and insert it.&#13;
    if (files &amp;&amp; files.length &amp;&amp; window.FileReader &amp;&amp; window.File) {&#13;
      var n = files.length, text = Array(n), read = 0;&#13;
      var loadFile = function(file, i) {&#13;
        if (cm.options.allowDropFileTypes &amp;&amp;&#13;
            indexOf(cm.options.allowDropFileTypes, file.type) == -1)&#13;
          return;&#13;
&#13;
        var reader = new FileReader;&#13;
        reader.onload = operation(cm, function() {&#13;
          var content = reader.result;&#13;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) content = "";&#13;
          text[i] = content;&#13;
          if (++read == n) {&#13;
            pos = clipPos(cm.doc, pos);&#13;
            var change = {from: pos, to: pos,&#13;
                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),&#13;
                          origin: "paste"};&#13;
            makeChange(cm.doc, change);&#13;
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));&#13;
          }&#13;
        });&#13;
        reader.readAsText(file);&#13;
      };&#13;
      for (var i = 0; i &lt; n; ++i) loadFile(files[i], i);&#13;
    } else { // Normal drop&#13;
      // Don't do a replace if the drop happened inside of the selected text.&#13;
      if (cm.state.draggingText &amp;&amp; cm.doc.sel.contains(pos) &gt; -1) {&#13;
        cm.state.draggingText(e);&#13;
        // Ensure the editor is re-focused&#13;
        setTimeout(function() {cm.display.input.focus();}, 20);&#13;
        return;&#13;
      }&#13;
      try {&#13;
        var text = e.dataTransfer.getData("Text");&#13;
        if (text) {&#13;
          if (cm.state.draggingText &amp;&amp; !(mac ? e.altKey : e.ctrlKey))&#13;
            var selected = cm.listSelections();&#13;
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));&#13;
          if (selected) for (var i = 0; i &lt; selected.length; ++i)&#13;
            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");&#13;
          cm.replaceSelection(text, "around", "paste");&#13;
          cm.display.input.focus();&#13;
        }&#13;
      }&#13;
      catch(e){}&#13;
    }&#13;
  }&#13;
&#13;
  function onDragStart(cm, e) {&#13;
    if (ie &amp;&amp; (!cm.state.draggingText || +new Date - lastDrop &lt; 100)) { e_stop(e); return; }&#13;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;&#13;
&#13;
    e.dataTransfer.setData("Text", cm.getSelection());&#13;
    e.dataTransfer.effectAllowed = "copyMove"&#13;
&#13;
    // Use dummy image instead of default browsers image.&#13;
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.&#13;
    if (e.dataTransfer.setDragImage &amp;&amp; !safari) {&#13;
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");&#13;
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";&#13;
      if (presto) {&#13;
        img.width = img.height = 1;&#13;
        cm.display.wrapper.appendChild(img);&#13;
        // Force a relayout, or Opera won't use our image for some obscure reason&#13;
        img._top = img.offsetTop;&#13;
      }&#13;
      e.dataTransfer.setDragImage(img, 0, 0);&#13;
      if (presto) img.parentNode.removeChild(img);&#13;
    }&#13;
  }&#13;
&#13;
  function onDragOver(cm, e) {&#13;
    var pos = posFromMouse(cm, e);&#13;
    if (!pos) return;&#13;
    var frag = document.createDocumentFragment();&#13;
    drawSelectionCursor(cm, pos, frag);&#13;
    if (!cm.display.dragCursor) {&#13;
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");&#13;
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);&#13;
    }&#13;
    removeChildrenAndAdd(cm.display.dragCursor, frag);&#13;
  }&#13;
&#13;
  function clearDragCursor(cm) {&#13;
    if (cm.display.dragCursor) {&#13;
      cm.display.lineSpace.removeChild(cm.display.dragCursor);&#13;
      cm.display.dragCursor = null;&#13;
    }&#13;
  }&#13;
&#13;
  // SCROLL EVENTS&#13;
&#13;
  // Sync the scrollable area and scrollbars, ensure the viewport&#13;
  // covers the visible area.&#13;
  function setScrollTop(cm, val) {&#13;
    if (Math.abs(cm.doc.scrollTop - val) &lt; 2) return;&#13;
    cm.doc.scrollTop = val;&#13;
    if (!gecko) updateDisplaySimple(cm, {top: val});&#13;
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;&#13;
    cm.display.scrollbars.setScrollTop(val);&#13;
    if (gecko) updateDisplaySimple(cm);&#13;
    startWorker(cm, 100);&#13;
  }&#13;
  // Sync scroller and scrollbar, ensure the gutter elements are&#13;
  // aligned.&#13;
  function setScrollLeft(cm, val, isScroller) {&#13;
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) &lt; 2) return;&#13;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);&#13;
    cm.doc.scrollLeft = val;&#13;
    alignHorizontally(cm);&#13;
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;&#13;
    cm.display.scrollbars.setScrollLeft(val);&#13;
  }&#13;
&#13;
  // Since the delta values reported on mouse wheel events are&#13;
  // unstandardized between browsers and even browser versions, and&#13;
  // generally horribly unpredictable, this code starts by measuring&#13;
  // the scroll effect that the first few mouse wheel events have,&#13;
  // and, from that, detects the way it can convert deltas to pixel&#13;
  // offsets afterwards.&#13;
  //&#13;
  // The reason we want to know the amount a wheel event will scroll&#13;
  // is that it gives us a chance to update the display before the&#13;
  // actual scrolling happens, reducing flickering.&#13;
&#13;
  var wheelSamples = 0, wheelPixelsPerUnit = null;&#13;
  // Fill in a browser-detected starting value on browsers where we&#13;
  // know one. These don't have to be accurate -- the result of them&#13;
  // being wrong would just be a slight flicker on the first wheel&#13;
  // scroll (if it is large enough).&#13;
  if (ie) wheelPixelsPerUnit = -.53;&#13;
  else if (gecko) wheelPixelsPerUnit = 15;&#13;
  else if (chrome) wheelPixelsPerUnit = -.7;&#13;
  else if (safari) wheelPixelsPerUnit = -1/3;&#13;
&#13;
  var wheelEventDelta = function(e) {&#13;
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;&#13;
    if (dx == null &amp;&amp; e.detail &amp;&amp; e.axis == e.HORIZONTAL_AXIS) dx = e.detail;&#13;
    if (dy == null &amp;&amp; e.detail &amp;&amp; e.axis == e.VERTICAL_AXIS) dy = e.detail;&#13;
    else if (dy == null) dy = e.wheelDelta;&#13;
    return {x: dx, y: dy};&#13;
  };&#13;
  CodeMirror.wheelEventPixels = function(e) {&#13;
    var delta = wheelEventDelta(e);&#13;
    delta.x *= wheelPixelsPerUnit;&#13;
    delta.y *= wheelPixelsPerUnit;&#13;
    return delta;&#13;
  };&#13;
&#13;
  function onScrollWheel(cm, e) {&#13;
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;&#13;
&#13;
    var display = cm.display, scroll = display.scroller;&#13;
    // Quit if there's nothing to scroll here&#13;
    var canScrollX = scroll.scrollWidth &gt; scroll.clientWidth;&#13;
    var canScrollY = scroll.scrollHeight &gt; scroll.clientHeight;&#13;
    if (!(dx &amp;&amp; canScrollX || dy &amp;&amp; canScrollY)) return;&#13;
&#13;
    // Webkit browsers on OS X abort momentum scrolls when the target&#13;
    // of the scroll event is removed from the scrollable element.&#13;
    // This hack (see related code in patchDisplay) makes sure the&#13;
    // element is kept around.&#13;
    if (dy &amp;&amp; mac &amp;&amp; webkit) {&#13;
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {&#13;
        for (var i = 0; i &lt; view.length; i++) {&#13;
          if (view[i].node == cur) {&#13;
            cm.display.currentWheelTarget = cur;&#13;
            break outer;&#13;
          }&#13;
        }&#13;
      }&#13;
    }&#13;
&#13;
    // On some browsers, horizontal scrolling will cause redraws to&#13;
    // happen before the gutter has been realigned, causing it to&#13;
    // wriggle around in a most unseemly way. When we have an&#13;
    // estimated pixels/delta value, we just handle horizontal&#13;
    // scrolling entirely here. It'll be slightly off from native, but&#13;
    // better than glitching out.&#13;
    if (dx &amp;&amp; !gecko &amp;&amp; !presto &amp;&amp; wheelPixelsPerUnit != null) {&#13;
      if (dy &amp;&amp; canScrollY)&#13;
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));&#13;
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));&#13;
      // Only prevent default scrolling if vertical scrolling is&#13;
      // actually possible. Otherwise, it causes vertical scroll&#13;
      // jitter on OSX trackpads when deltaX is small and deltaY&#13;
      // is large (issue #3579)&#13;
      if (!dy || (dy &amp;&amp; canScrollY))&#13;
        e_preventDefault(e);&#13;
      display.wheelStartX = null; // Abort measurement, if in progress&#13;
      return;&#13;
    }&#13;
&#13;
    // 'Project' the visible viewport to cover the area that is being&#13;
    // scrolled into view (if we know enough to estimate it).&#13;
    if (dy &amp;&amp; wheelPixelsPerUnit != null) {&#13;
      var pixels = dy * wheelPixelsPerUnit;&#13;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;&#13;
      if (pixels &lt; 0) top = Math.max(0, top + pixels - 50);&#13;
      else bot = Math.min(cm.doc.height, bot + pixels + 50);&#13;
      updateDisplaySimple(cm, {top: top, bottom: bot});&#13;
    }&#13;
&#13;
    if (wheelSamples &lt; 20) {&#13;
      if (display.wheelStartX == null) {&#13;
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;&#13;
        display.wheelDX = dx; display.wheelDY = dy;&#13;
        setTimeout(function() {&#13;
          if (display.wheelStartX == null) return;&#13;
          var movedX = scroll.scrollLeft - display.wheelStartX;&#13;
          var movedY = scroll.scrollTop - display.wheelStartY;&#13;
          var sample = (movedY &amp;&amp; display.wheelDY &amp;&amp; movedY / display.wheelDY) ||&#13;
            (movedX &amp;&amp; display.wheelDX &amp;&amp; movedX / display.wheelDX);&#13;
          display.wheelStartX = display.wheelStartY = null;&#13;
          if (!sample) return;&#13;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);&#13;
          ++wheelSamples;&#13;
        }, 200);&#13;
      } else {&#13;
        display.wheelDX += dx; display.wheelDY += dy;&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  // KEY EVENTS&#13;
&#13;
  // Run a handler that was bound to a key.&#13;
  function doHandleBinding(cm, bound, dropShift) {&#13;
    if (typeof bound == "string") {&#13;
      bound = commands[bound];&#13;
      if (!bound) return false;&#13;
    }&#13;
    // Ensure previous input has been read, so that the handler sees a&#13;
    // consistent view of the document&#13;
    cm.display.input.ensurePolled();&#13;
    var prevShift = cm.display.shift, done = false;&#13;
    try {&#13;
      if (cm.isReadOnly()) cm.state.suppressEdits = true;&#13;
      if (dropShift) cm.display.shift = false;&#13;
      done = bound(cm) != Pass;&#13;
    } finally {&#13;
      cm.display.shift = prevShift;&#13;
      cm.state.suppressEdits = false;&#13;
    }&#13;
    return done;&#13;
  }&#13;
&#13;
  function lookupKeyForEditor(cm, name, handle) {&#13;
    for (var i = 0; i &lt; cm.state.keyMaps.length; i++) {&#13;
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);&#13;
      if (result) return result;&#13;
    }&#13;
    return (cm.options.extraKeys &amp;&amp; lookupKey(name, cm.options.extraKeys, handle, cm))&#13;
      || lookupKey(name, cm.options.keyMap, handle, cm);&#13;
  }&#13;
&#13;
  var stopSeq = new Delayed;&#13;
  function dispatchKey(cm, name, e, handle) {&#13;
    var seq = cm.state.keySeq;&#13;
    if (seq) {&#13;
      if (isModifierKey(name)) return "handled";&#13;
      stopSeq.set(50, function() {&#13;
        if (cm.state.keySeq == seq) {&#13;
          cm.state.keySeq = null;&#13;
          cm.display.input.reset();&#13;
        }&#13;
      });&#13;
      name = seq + " " + name;&#13;
    }&#13;
    var result = lookupKeyForEditor(cm, name, handle);&#13;
&#13;
    if (result == "multi")&#13;
      cm.state.keySeq = name;&#13;
    if (result == "handled")&#13;
      signalLater(cm, "keyHandled", cm, name, e);&#13;
&#13;
    if (result == "handled" || result == "multi") {&#13;
      e_preventDefault(e);&#13;
      restartBlink(cm);&#13;
    }&#13;
&#13;
    if (seq &amp;&amp; !result &amp;&amp; /\'$/.test(name)) {&#13;
      e_preventDefault(e);&#13;
      return true;&#13;
    }&#13;
    return !!result;&#13;
  }&#13;
&#13;
  // Handle a key from the keydown event.&#13;
  function handleKeyBinding(cm, e) {&#13;
    var name = keyName(e, true);&#13;
    if (!name) return false;&#13;
&#13;
    if (e.shiftKey &amp;&amp; !cm.state.keySeq) {&#13;
      // First try to resolve full name (including 'Shift-'). Failing&#13;
      // that, see if there is a cursor-motion command (starting with&#13;
      // 'go') bound to the keyname without 'Shift-'.&#13;
      return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})&#13;
          || dispatchKey(cm, name, e, function(b) {&#13;
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)&#13;
                 return doHandleBinding(cm, b);&#13;
             });&#13;
    } else {&#13;
      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });&#13;
    }&#13;
  }&#13;
&#13;
  // Handle a key from the keypress event&#13;
  function handleCharBinding(cm, e, ch) {&#13;
    return dispatchKey(cm, "'" + ch + "'", e,&#13;
                       function(b) { return doHandleBinding(cm, b, true); });&#13;
  }&#13;
&#13;
  var lastStoppedKey = null;&#13;
  function onKeyDown(e) {&#13;
    var cm = this;&#13;
    cm.curOp.focus = activeElt();&#13;
    if (signalDOMEvent(cm, e)) return;&#13;
    // IE does strange things with escape.&#13;
    if (ie &amp;&amp; ie_version &lt; 11 &amp;&amp; e.keyCode == 27) e.returnValue = false;&#13;
    var code = e.keyCode;&#13;
    cm.display.shift = code == 16 || e.shiftKey;&#13;
    var handled = handleKeyBinding(cm, e);&#13;
    if (presto) {&#13;
      lastStoppedKey = handled ? code : null;&#13;
      // Opera has no cut event... we try to at least catch the key combo&#13;
      if (!handled &amp;&amp; code == 88 &amp;&amp; !hasCopyEvent &amp;&amp; (mac ? e.metaKey : e.ctrlKey))&#13;
        cm.replaceSelection("", null, "cut");&#13;
    }&#13;
&#13;
    // Turn mouse into crosshair when Alt is held on Mac.&#13;
    if (code == 18 &amp;&amp; !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))&#13;
      showCrossHair(cm);&#13;
  }&#13;
&#13;
  function showCrossHair(cm) {&#13;
    var lineDiv = cm.display.lineDiv;&#13;
    addClass(lineDiv, "CodeMirror-crosshair");&#13;
&#13;
    function up(e) {&#13;
      if (e.keyCode == 18 || !e.altKey) {&#13;
        rmClass(lineDiv, "CodeMirror-crosshair");&#13;
        off(document, "keyup", up);&#13;
        off(document, "mouseover", up);&#13;
      }&#13;
    }&#13;
    on(document, "keyup", up);&#13;
    on(document, "mouseover", up);&#13;
  }&#13;
&#13;
  function onKeyUp(e) {&#13;
    if (e.keyCode == 16) this.doc.sel.shift = false;&#13;
    signalDOMEvent(this, e);&#13;
  }&#13;
&#13;
  function onKeyPress(e) {&#13;
    var cm = this;&#13;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey &amp;&amp; !e.altKey || mac &amp;&amp; e.metaKey) return;&#13;
    var keyCode = e.keyCode, charCode = e.charCode;&#13;
    if (presto &amp;&amp; keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}&#13;
    if ((presto &amp;&amp; (!e.which || e.which &lt; 10)) &amp;&amp; handleKeyBinding(cm, e)) return;&#13;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);&#13;
    if (handleCharBinding(cm, e, ch)) return;&#13;
    cm.display.input.onKeyPress(e);&#13;
  }&#13;
&#13;
  // FOCUS/BLUR EVENTS&#13;
&#13;
  function delayBlurEvent(cm) {&#13;
    cm.state.delayingBlurEvent = true;&#13;
    setTimeout(function() {&#13;
      if (cm.state.delayingBlurEvent) {&#13;
        cm.state.delayingBlurEvent = false;&#13;
        onBlur(cm);&#13;
      }&#13;
    }, 100);&#13;
  }&#13;
&#13;
  function onFocus(cm) {&#13;
    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;&#13;
&#13;
    if (cm.options.readOnly == "nocursor") return;&#13;
    if (!cm.state.focused) {&#13;
      signal(cm, "focus", cm);&#13;
      cm.state.focused = true;&#13;
      addClass(cm.display.wrapper, "CodeMirror-focused");&#13;
      // This test prevents this from firing when a context&#13;
      // menu is closed (since the input reset would kill the&#13;
      // select-all detection hack)&#13;
      if (!cm.curOp &amp;&amp; cm.display.selForContextMenu != cm.doc.sel) {&#13;
        cm.display.input.reset();&#13;
        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730&#13;
      }&#13;
      cm.display.input.receivedFocus();&#13;
    }&#13;
    restartBlink(cm);&#13;
  }&#13;
  function onBlur(cm) {&#13;
    if (cm.state.delayingBlurEvent) return;&#13;
&#13;
    if (cm.state.focused) {&#13;
      signal(cm, "blur", cm);&#13;
      cm.state.focused = false;&#13;
      rmClass(cm.display.wrapper, "CodeMirror-focused");&#13;
    }&#13;
    clearInterval(cm.display.blinker);&#13;
    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);&#13;
  }&#13;
&#13;
  // CONTEXT MENU HANDLING&#13;
&#13;
  // To make the context menu work, we need to briefly unhide the&#13;
  // textarea (making it as unobtrusive as possible) to let the&#13;
  // right-click take effect on it.&#13;
  function onContextMenu(cm, e) {&#13;
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;&#13;
    if (signalDOMEvent(cm, e, "contextmenu")) return;&#13;
    cm.display.input.onContextMenu(e);&#13;
  }&#13;
&#13;
  function contextMenuInGutter(cm, e) {&#13;
    if (!hasHandler(cm, "gutterContextMenu")) return false;&#13;
    return gutterEvent(cm, e, "gutterContextMenu", false);&#13;
  }&#13;
&#13;
  // UPDATING&#13;
&#13;
  // Compute the position of the end of a change (its 'to' property&#13;
  // refers to the pre-change end).&#13;
  var changeEnd = CodeMirror.changeEnd = function(change) {&#13;
    if (!change.text) return change.to;&#13;
    return Pos(change.from.line + change.text.length - 1,&#13;
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));&#13;
  };&#13;
&#13;
  // Adjust a position to refer to the post-change position of the&#13;
  // same text, or the end of the change if the change covers it.&#13;
  function adjustForChange(pos, change) {&#13;
    if (cmp(pos, change.from) &lt; 0) return pos;&#13;
    if (cmp(pos, change.to) &lt;= 0) return changeEnd(change);&#13;
&#13;
    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;&#13;
    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;&#13;
    return Pos(line, ch);&#13;
  }&#13;
&#13;
  function computeSelAfterChange(doc, change) {&#13;
    var out = [];&#13;
    for (var i = 0; i &lt; doc.sel.ranges.length; i++) {&#13;
      var range = doc.sel.ranges[i];&#13;
      out.push(new Range(adjustForChange(range.anchor, change),&#13;
                         adjustForChange(range.head, change)));&#13;
    }&#13;
    return normalizeSelection(out, doc.sel.primIndex);&#13;
  }&#13;
&#13;
  function offsetPos(pos, old, nw) {&#13;
    if (pos.line == old.line)&#13;
      return Pos(nw.line, pos.ch - old.ch + nw.ch);&#13;
    else&#13;
      return Pos(nw.line + (pos.line - old.line), pos.ch);&#13;
  }&#13;
&#13;
  // Used by replaceSelections to allow moving the selection to the&#13;
  // start or around the replaced test. Hint may be "start" or "around".&#13;
  function computeReplacedSel(doc, changes, hint) {&#13;
    var out = [];&#13;
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;&#13;
    for (var i = 0; i &lt; changes.length; i++) {&#13;
      var change = changes[i];&#13;
      var from = offsetPos(change.from, oldPrev, newPrev);&#13;
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);&#13;
      oldPrev = change.to;&#13;
      newPrev = to;&#13;
      if (hint == "around") {&#13;
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) &lt; 0;&#13;
        out[i] = new Range(inv ? to : from, inv ? from : to);&#13;
      } else {&#13;
        out[i] = new Range(from, from);&#13;
      }&#13;
    }&#13;
    return new Selection(out, doc.sel.primIndex);&#13;
  }&#13;
&#13;
  // Allow "beforeChange" event handlers to influence a change&#13;
  function filterChange(doc, change, update) {&#13;
    var obj = {&#13;
      canceled: false,&#13;
      from: change.from,&#13;
      to: change.to,&#13;
      text: change.text,&#13;
      origin: change.origin,&#13;
      cancel: function() { this.canceled = true; }&#13;
    };&#13;
    if (update) obj.update = function(from, to, text, origin) {&#13;
      if (from) this.from = clipPos(doc, from);&#13;
      if (to) this.to = clipPos(doc, to);&#13;
      if (text) this.text = text;&#13;
      if (origin !== undefined) this.origin = origin;&#13;
    };&#13;
    signal(doc, "beforeChange", doc, obj);&#13;
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);&#13;
&#13;
    if (obj.canceled) return null;&#13;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};&#13;
  }&#13;
&#13;
  // Apply a change to a document, and add it to the document's&#13;
  // history, and propagating it to all linked documents.&#13;
  function makeChange(doc, change, ignoreReadOnly) {&#13;
    if (doc.cm) {&#13;
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);&#13;
      if (doc.cm.state.suppressEdits) return;&#13;
    }&#13;
&#13;
    if (hasHandler(doc, "beforeChange") || doc.cm &amp;&amp; hasHandler(doc.cm, "beforeChange")) {&#13;
      change = filterChange(doc, change, true);&#13;
      if (!change) return;&#13;
    }&#13;
&#13;
    // Possibly split or suppress the update based on the presence&#13;
    // of read-only spans in its range.&#13;
    var split = sawReadOnlySpans &amp;&amp; !ignoreReadOnly &amp;&amp; removeReadOnlyRanges(doc, change.from, change.to);&#13;
    if (split) {&#13;
      for (var i = split.length - 1; i &gt;= 0; --i)&#13;
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});&#13;
    } else {&#13;
      makeChangeInner(doc, change);&#13;
    }&#13;
  }&#13;
&#13;
  function makeChangeInner(doc, change) {&#13;
    if (change.text.length == 1 &amp;&amp; change.text[0] == "" &amp;&amp; cmp(change.from, change.to) == 0) return;&#13;
    var selAfter = computeSelAfterChange(doc, change);&#13;
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);&#13;
&#13;
    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));&#13;
    var rebased = [];&#13;
&#13;
    linkedDocs(doc, function(doc, sharedHist) {&#13;
      if (!sharedHist &amp;&amp; indexOf(rebased, doc.history) == -1) {&#13;
        rebaseHist(doc.history, change);&#13;
        rebased.push(doc.history);&#13;
      }&#13;
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));&#13;
    });&#13;
  }&#13;
&#13;
  // Revert a change stored in a document's history.&#13;
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {&#13;
    if (doc.cm &amp;&amp; doc.cm.state.suppressEdits) return;&#13;
&#13;
    var hist = doc.history, event, selAfter = doc.sel;&#13;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;&#13;
&#13;
    // Verify that there is a useable event (so that ctrl-z won't&#13;
    // needlessly clear selection events)&#13;
    for (var i = 0; i &lt; source.length; i++) {&#13;
      event = source[i];&#13;
      if (allowSelectionOnly ? event.ranges &amp;&amp; !event.equals(doc.sel) : !event.ranges)&#13;
        break;&#13;
    }&#13;
    if (i == source.length) return;&#13;
    hist.lastOrigin = hist.lastSelOrigin = null;&#13;
&#13;
    for (;;) {&#13;
      event = source.pop();&#13;
      if (event.ranges) {&#13;
        pushSelectionToHistory(event, dest);&#13;
        if (allowSelectionOnly &amp;&amp; !event.equals(doc.sel)) {&#13;
          setSelection(doc, event, {clearRedo: false});&#13;
          return;&#13;
        }&#13;
        selAfter = event;&#13;
      }&#13;
      else break;&#13;
    }&#13;
&#13;
    // Build up a reverse change object to add to the opposite history&#13;
    // stack (redo when undoing, and vice versa).&#13;
    var antiChanges = [];&#13;
    pushSelectionToHistory(selAfter, dest);&#13;
    dest.push({changes: antiChanges, generation: hist.generation});&#13;
    hist.generation = event.generation || ++hist.maxGeneration;&#13;
&#13;
    var filter = hasHandler(doc, "beforeChange") || doc.cm &amp;&amp; hasHandler(doc.cm, "beforeChange");&#13;
&#13;
    for (var i = event.changes.length - 1; i &gt;= 0; --i) {&#13;
      var change = event.changes[i];&#13;
      change.origin = type;&#13;
      if (filter &amp;&amp; !filterChange(doc, change, false)) {&#13;
        source.length = 0;&#13;
        return;&#13;
      }&#13;
&#13;
      antiChanges.push(historyChangeFromChange(doc, change));&#13;
&#13;
      var after = i ? computeSelAfterChange(doc, change) : lst(source);&#13;
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));&#13;
      if (!i &amp;&amp; doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});&#13;
      var rebased = [];&#13;
&#13;
      // Propagate to the linked documents&#13;
      linkedDocs(doc, function(doc, sharedHist) {&#13;
        if (!sharedHist &amp;&amp; indexOf(rebased, doc.history) == -1) {&#13;
          rebaseHist(doc.history, change);&#13;
          rebased.push(doc.history);&#13;
        }&#13;
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));&#13;
      });&#13;
    }&#13;
  }&#13;
&#13;
  // Sub-views need their line numbers shifted when text is added&#13;
  // above or below them in the parent document.&#13;
  function shiftDoc(doc, distance) {&#13;
    if (distance == 0) return;&#13;
    doc.first += distance;&#13;
    doc.sel = new Selection(map(doc.sel.ranges, function(range) {&#13;
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),&#13;
                       Pos(range.head.line + distance, range.head.ch));&#13;
    }), doc.sel.primIndex);&#13;
    if (doc.cm) {&#13;
      regChange(doc.cm, doc.first, doc.first - distance, distance);&#13;
      for (var d = doc.cm.display, l = d.viewFrom; l &lt; d.viewTo; l++)&#13;
        regLineChange(doc.cm, l, "gutter");&#13;
    }&#13;
  }&#13;
&#13;
  // More lower-level change function, handling only a single document&#13;
  // (not linked ones).&#13;
  function makeChangeSingleDoc(doc, change, selAfter, spans) {&#13;
    if (doc.cm &amp;&amp; !doc.cm.curOp)&#13;
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);&#13;
&#13;
    if (change.to.line &lt; doc.first) {&#13;
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));&#13;
      return;&#13;
    }&#13;
    if (change.from.line &gt; doc.lastLine()) return;&#13;
&#13;
    // Clip the change to the size of this doc&#13;
    if (change.from.line &lt; doc.first) {&#13;
      var shift = change.text.length - 1 - (doc.first - change.from.line);&#13;
      shiftDoc(doc, shift);&#13;
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),&#13;
                text: [lst(change.text)], origin: change.origin};&#13;
    }&#13;
    var last = doc.lastLine();&#13;
    if (change.to.line &gt; last) {&#13;
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),&#13;
                text: [change.text[0]], origin: change.origin};&#13;
    }&#13;
&#13;
    change.removed = getBetween(doc, change.from, change.to);&#13;
&#13;
    if (!selAfter) selAfter = computeSelAfterChange(doc, change);&#13;
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);&#13;
    else updateDoc(doc, change, spans);&#13;
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);&#13;
  }&#13;
&#13;
  // Handle the interaction of a change to a document with the editor&#13;
  // that this document is part of.&#13;
  function makeChangeSingleDocInEditor(cm, change, spans) {&#13;
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;&#13;
&#13;
    var recomputeMaxLength = false, checkWidthStart = from.line;&#13;
    if (!cm.options.lineWrapping) {&#13;
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));&#13;
      doc.iter(checkWidthStart, to.line + 1, function(line) {&#13;
        if (line == display.maxLine) {&#13;
          recomputeMaxLength = true;&#13;
          return true;&#13;
        }&#13;
      });&#13;
    }&#13;
&#13;
    if (doc.sel.contains(change.from, change.to) &gt; -1)&#13;
      signalCursorActivity(cm);&#13;
&#13;
    updateDoc(doc, change, spans, estimateHeight(cm));&#13;
&#13;
    if (!cm.options.lineWrapping) {&#13;
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {&#13;
        var len = lineLength(line);&#13;
        if (len &gt; display.maxLineLength) {&#13;
          display.maxLine = line;&#13;
          display.maxLineLength = len;&#13;
          display.maxLineChanged = true;&#13;
          recomputeMaxLength = false;&#13;
        }&#13;
      });&#13;
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;&#13;
    }&#13;
&#13;
    // Adjust frontier, schedule worker&#13;
    doc.frontier = Math.min(doc.frontier, from.line);&#13;
    startWorker(cm, 400);&#13;
&#13;
    var lendiff = change.text.length - (to.line - from.line) - 1;&#13;
    // Remember that these lines changed, for updating the display&#13;
    if (change.full)&#13;
      regChange(cm);&#13;
    else if (from.line == to.line &amp;&amp; change.text.length == 1 &amp;&amp; !isWholeLineUpdate(cm.doc, change))&#13;
      regLineChange(cm, from.line, "text");&#13;
    else&#13;
      regChange(cm, from.line, to.line + 1, lendiff);&#13;
&#13;
    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");&#13;
    if (changeHandler || changesHandler) {&#13;
      var obj = {&#13;
        from: from, to: to,&#13;
        text: change.text,&#13;
        removed: change.removed,&#13;
        origin: change.origin&#13;
      };&#13;
      if (changeHandler) signalLater(cm, "change", cm, obj);&#13;
      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);&#13;
    }&#13;
    cm.display.selForContextMenu = null;&#13;
  }&#13;
&#13;
  function replaceRange(doc, code, from, to, origin) {&#13;
    if (!to) to = from;&#13;
    if (cmp(to, from) &lt; 0) { var tmp = to; to = from; from = tmp; }&#13;
    if (typeof code == "string") code = doc.splitLines(code);&#13;
    makeChange(doc, {from: from, to: to, text: code, origin: origin});&#13;
  }&#13;
&#13;
  // SCROLLING THINGS INTO VIEW&#13;
&#13;
  // If an editor sits on the top or bottom of the window, partially&#13;
  // scrolled out of view, this ensures that the cursor is visible.&#13;
  function maybeScrollWindow(cm, coords) {&#13;
    if (signalDOMEvent(cm, "scrollCursorIntoView")) return;&#13;
&#13;
    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;&#13;
    if (coords.top + box.top &lt; 0) doScroll = true;&#13;
    else if (coords.bottom + box.top &gt; (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;&#13;
    if (doScroll != null &amp;&amp; !phantom) {&#13;
      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +&#13;
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +&#13;
                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +&#13;
                           coords.left + "px; width: 2px;");&#13;
      cm.display.lineSpace.appendChild(scrollNode);&#13;
      scrollNode.scrollIntoView(doScroll);&#13;
      cm.display.lineSpace.removeChild(scrollNode);&#13;
    }&#13;
  }&#13;
&#13;
  // Scroll a given position into view (immediately), verifying that&#13;
  // it actually became visible (as line heights are accurately&#13;
  // measured, the position of something may 'drift' during drawing).&#13;
  function scrollPosIntoView(cm, pos, end, margin) {&#13;
    if (margin == null) margin = 0;&#13;
    for (var limit = 0; limit &lt; 5; limit++) {&#13;
      var changed = false, coords = cursorCoords(cm, pos);&#13;
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);&#13;
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),&#13;
                                         Math.min(coords.top, endCoords.top) - margin,&#13;
                                         Math.max(coords.left, endCoords.left),&#13;
                                         Math.max(coords.bottom, endCoords.bottom) + margin);&#13;
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;&#13;
      if (scrollPos.scrollTop != null) {&#13;
        setScrollTop(cm, scrollPos.scrollTop);&#13;
        if (Math.abs(cm.doc.scrollTop - startTop) &gt; 1) changed = true;&#13;
      }&#13;
      if (scrollPos.scrollLeft != null) {&#13;
        setScrollLeft(cm, scrollPos.scrollLeft);&#13;
        if (Math.abs(cm.doc.scrollLeft - startLeft) &gt; 1) changed = true;&#13;
      }&#13;
      if (!changed) break;&#13;
    }&#13;
    return coords;&#13;
  }&#13;
&#13;
  // Scroll a given set of coordinates into view (immediately).&#13;
  function scrollIntoView(cm, x1, y1, x2, y2) {&#13;
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);&#13;
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);&#13;
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);&#13;
  }&#13;
&#13;
  // Calculate a new scroll position needed to scroll the given&#13;
  // rectangle into view. Returns an object with scrollTop and&#13;
  // scrollLeft properties. When these are undefined, the&#13;
  // vertical/horizontal position does not need to be adjusted.&#13;
  function calculateScrollPos(cm, x1, y1, x2, y2) {&#13;
    var display = cm.display, snapMargin = textHeight(cm.display);&#13;
    if (y1 &lt; 0) y1 = 0;&#13;
    var screentop = cm.curOp &amp;&amp; cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;&#13;
    var screen = displayHeight(cm), result = {};&#13;
    if (y2 - y1 &gt; screen) y2 = y1 + screen;&#13;
    var docBottom = cm.doc.height + paddingVert(display);&#13;
    var atTop = y1 &lt; snapMargin, atBottom = y2 &gt; docBottom - snapMargin;&#13;
    if (y1 &lt; screentop) {&#13;
      result.scrollTop = atTop ? 0 : y1;&#13;
    } else if (y2 &gt; screentop + screen) {&#13;
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);&#13;
      if (newTop != screentop) result.scrollTop = newTop;&#13;
    }&#13;
&#13;
    var screenleft = cm.curOp &amp;&amp; cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;&#13;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);&#13;
    var tooWide = x2 - x1 &gt; screenw;&#13;
    if (tooWide) x2 = x1 + screenw;&#13;
    if (x1 &lt; 10)&#13;
      result.scrollLeft = 0;&#13;
    else if (x1 &lt; screenleft)&#13;
      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));&#13;
    else if (x2 &gt; screenw + screenleft - 3)&#13;
      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;&#13;
    return result;&#13;
  }&#13;
&#13;
  // Store a relative adjustment to the scroll position in the current&#13;
  // operation (to be applied when the operation finishes).&#13;
  function addToScrollPos(cm, left, top) {&#13;
    if (left != null || top != null) resolveScrollToPos(cm);&#13;
    if (left != null)&#13;
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;&#13;
    if (top != null)&#13;
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;&#13;
  }&#13;
&#13;
  // Make sure that at the end of the operation the current cursor is&#13;
  // shown.&#13;
  function ensureCursorVisible(cm) {&#13;
    resolveScrollToPos(cm);&#13;
    var cur = cm.getCursor(), from = cur, to = cur;&#13;
    if (!cm.options.lineWrapping) {&#13;
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;&#13;
      to = Pos(cur.line, cur.ch + 1);&#13;
    }&#13;
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};&#13;
  }&#13;
&#13;
  // When an operation has its scrollToPos property set, and another&#13;
  // scroll action is applied before the end of the operation, this&#13;
  // 'simulates' scrolling that position into view in a cheap way, so&#13;
  // that the effect of intermediate scroll commands is not ignored.&#13;
  function resolveScrollToPos(cm) {&#13;
    var range = cm.curOp.scrollToPos;&#13;
    if (range) {&#13;
      cm.curOp.scrollToPos = null;&#13;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);&#13;
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),&#13;
                                    Math.min(from.top, to.top) - range.margin,&#13;
                                    Math.max(from.right, to.right),&#13;
                                    Math.max(from.bottom, to.bottom) + range.margin);&#13;
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);&#13;
    }&#13;
  }&#13;
&#13;
  // API UTILITIES&#13;
&#13;
  // Indent the given line. The how parameter can be "smart",&#13;
  // "add"/null, "subtract", or "prev". When aggressive is false&#13;
  // (typically set to true for forced single-line indents), empty&#13;
  // lines are not indented, and places where the mode returns Pass&#13;
  // are left alone.&#13;
  function indentLine(cm, n, how, aggressive) {&#13;
    var doc = cm.doc, state;&#13;
    if (how == null) how = "add";&#13;
    if (how == "smart") {&#13;
      // Fall back to "prev" when the mode doesn't have an indentation&#13;
      // method.&#13;
      if (!doc.mode.indent) how = "prev";&#13;
      else state = getStateBefore(cm, n);&#13;
    }&#13;
&#13;
    var tabSize = cm.options.tabSize;&#13;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);&#13;
    if (line.stateAfter) line.stateAfter = null;&#13;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;&#13;
    if (!aggressive &amp;&amp; !/\S/.test(line.text)) {&#13;
      indentation = 0;&#13;
      how = "not";&#13;
    } else if (how == "smart") {&#13;
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);&#13;
      if (indentation == Pass || indentation &gt; 150) {&#13;
        if (!aggressive) return;&#13;
        how = "prev";&#13;
      }&#13;
    }&#13;
    if (how == "prev") {&#13;
      if (n &gt; doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);&#13;
      else indentation = 0;&#13;
    } else if (how == "add") {&#13;
      indentation = curSpace + cm.options.indentUnit;&#13;
    } else if (how == "subtract") {&#13;
      indentation = curSpace - cm.options.indentUnit;&#13;
    } else if (typeof how == "number") {&#13;
      indentation = curSpace + how;&#13;
    }&#13;
    indentation = Math.max(0, indentation);&#13;
&#13;
    var indentString = "", pos = 0;&#13;
    if (cm.options.indentWithTabs)&#13;
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}&#13;
    if (pos &lt; indentation) indentString += spaceStr(indentation - pos);&#13;
&#13;
    if (indentString != curSpaceString) {&#13;
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");&#13;
      line.stateAfter = null;&#13;
      return true;&#13;
    } else {&#13;
      // Ensure that, if the cursor was in the whitespace at the start&#13;
      // of the line, it is moved to the end of that space.&#13;
      for (var i = 0; i &lt; doc.sel.ranges.length; i++) {&#13;
        var range = doc.sel.ranges[i];&#13;
        if (range.head.line == n &amp;&amp; range.head.ch &lt; curSpaceString.length) {&#13;
          var pos = Pos(n, curSpaceString.length);&#13;
          replaceOneSelection(doc, i, new Range(pos, pos));&#13;
          break;&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  // Utility for applying a change to a line by handle or number,&#13;
  // returning the number and optionally registering the line as&#13;
  // changed.&#13;
  function changeLine(doc, handle, changeType, op) {&#13;
    var no = handle, line = handle;&#13;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));&#13;
    else no = lineNo(handle);&#13;
    if (no == null) return null;&#13;
    if (op(line, no) &amp;&amp; doc.cm) regLineChange(doc.cm, no, changeType);&#13;
    return line;&#13;
  }&#13;
&#13;
  // Helper for deleting text near the selection(s), used to implement&#13;
  // backspace, delete, and similar functionality.&#13;
  function deleteNearSelection(cm, compute) {&#13;
    var ranges = cm.doc.sel.ranges, kill = [];&#13;
    // Build up a set of ranges to kill first, merging overlapping&#13;
    // ranges.&#13;
    for (var i = 0; i &lt; ranges.length; i++) {&#13;
      var toKill = compute(ranges[i]);&#13;
      while (kill.length &amp;&amp; cmp(toKill.from, lst(kill).to) &lt;= 0) {&#13;
        var replaced = kill.pop();&#13;
        if (cmp(replaced.from, toKill.from) &lt; 0) {&#13;
          toKill.from = replaced.from;&#13;
          break;&#13;
        }&#13;
      }&#13;
      kill.push(toKill);&#13;
    }&#13;
    // Next, remove those actual ranges.&#13;
    runInOp(cm, function() {&#13;
      for (var i = kill.length - 1; i &gt;= 0; i--)&#13;
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");&#13;
      ensureCursorVisible(cm);&#13;
    });&#13;
  }&#13;
&#13;
  // Used for horizontal relative motion. Dir is -1 or 1 (left or&#13;
  // right), unit can be "char", "column" (like char, but doesn't&#13;
  // cross line boundaries), "word" (across next word), or "group" (to&#13;
  // the start of next group of word or non-word-non-whitespace&#13;
  // chars). The visually param controls whether, in right-to-left&#13;
  // text, direction 1 means to move towards the next index in the&#13;
  // string, or towards the character to the right of the current&#13;
  // position. The resulting position will have a hitSide=true&#13;
  // property if it reached the end of the document.&#13;
  function findPosH(doc, pos, dir, unit, visually) {&#13;
    var line = pos.line, ch = pos.ch, origDir = dir;&#13;
    var lineObj = getLine(doc, line);&#13;
    function findNextLine() {&#13;
      var l = line + dir;&#13;
      if (l &lt; doc.first || l &gt;= doc.first + doc.size) return false&#13;
      line = l;&#13;
      return lineObj = getLine(doc, l);&#13;
    }&#13;
    function moveOnce(boundToLine) {&#13;
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);&#13;
      if (next == null) {&#13;
        if (!boundToLine &amp;&amp; findNextLine()) {&#13;
          if (visually) ch = (dir &lt; 0 ? lineRight : lineLeft)(lineObj);&#13;
          else ch = dir &lt; 0 ? lineObj.text.length : 0;&#13;
        } else return false&#13;
      } else ch = next;&#13;
      return true;&#13;
    }&#13;
&#13;
    if (unit == "char") {&#13;
      moveOnce()&#13;
    } else if (unit == "column") {&#13;
      moveOnce(true)&#13;
    } else if (unit == "word" || unit == "group") {&#13;
      var sawType = null, group = unit == "group";&#13;
      var helper = doc.cm &amp;&amp; doc.cm.getHelper(pos, "wordChars");&#13;
      for (var first = true;; first = false) {&#13;
        if (dir &lt; 0 &amp;&amp; !moveOnce(!first)) break;&#13;
        var cur = lineObj.text.charAt(ch) || "\n";&#13;
        var type = isWordChar(cur, helper) ? "w"&#13;
          : group &amp;&amp; cur == "\n" ? "n"&#13;
          : !group || /\s/.test(cur) ? null&#13;
          : "p";&#13;
        if (group &amp;&amp; !first &amp;&amp; !type) type = "s";&#13;
        if (sawType &amp;&amp; sawType != type) {&#13;
          if (dir &lt; 0) {dir = 1; moveOnce();}&#13;
          break;&#13;
        }&#13;
&#13;
        if (type) sawType = type;&#13;
        if (dir &gt; 0 &amp;&amp; !moveOnce(!first)) break;&#13;
      }&#13;
    }&#13;
    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);&#13;
    if (!cmp(pos, result)) result.hitSide = true;&#13;
    return result;&#13;
  }&#13;
&#13;
  // For relative vertical movement. Dir may be -1 or 1. Unit can be&#13;
  // "page" or "line". The resulting position will have a hitSide=true&#13;
  // property if it reached the end of the document.&#13;
  function findPosV(cm, pos, dir, unit) {&#13;
    var doc = cm.doc, x = pos.left, y;&#13;
    if (unit == "page") {&#13;
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);&#13;
      y = pos.top + dir * (pageSize - (dir &lt; 0 ? 1.5 : .5) * textHeight(cm.display));&#13;
    } else if (unit == "line") {&#13;
      y = dir &gt; 0 ? pos.bottom + 3 : pos.top - 3;&#13;
    }&#13;
    for (;;) {&#13;
      var target = coordsChar(cm, x, y);&#13;
      if (!target.outside) break;&#13;
      if (dir &lt; 0 ? y &lt;= 0 : y &gt;= doc.height) { target.hitSide = true; break; }&#13;
      y += dir * 5;&#13;
    }&#13;
    return target;&#13;
  }&#13;
&#13;
  // EDITOR METHODS&#13;
&#13;
  // The publicly visible API. Note that methodOp(f) means&#13;
  // 'wrap f in an operation, performed on its `this` parameter'.&#13;
&#13;
  // This is not the complete set of editor methods. Most of the&#13;
  // methods defined on the Doc type are also injected into&#13;
  // CodeMirror.prototype, for backwards compatibility and&#13;
  // convenience.&#13;
&#13;
  CodeMirror.prototype = {&#13;
    constructor: CodeMirror,&#13;
    focus: function(){window.focus(); this.display.input.focus();},&#13;
&#13;
    setOption: function(option, value) {&#13;
      var options = this.options, old = options[option];&#13;
      if (options[option] == value &amp;&amp; option != "mode") return;&#13;
      options[option] = value;&#13;
      if (optionHandlers.hasOwnProperty(option))&#13;
        operation(this, optionHandlers[option])(this, value, old);&#13;
    },&#13;
&#13;
    getOption: function(option) {return this.options[option];},&#13;
    getDoc: function() {return this.doc;},&#13;
&#13;
    addKeyMap: function(map, bottom) {&#13;
      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));&#13;
    },&#13;
    removeKeyMap: function(map) {&#13;
      var maps = this.state.keyMaps;&#13;
      for (var i = 0; i &lt; maps.length; ++i)&#13;
        if (maps[i] == map || maps[i].name == map) {&#13;
          maps.splice(i, 1);&#13;
          return true;&#13;
        }&#13;
    },&#13;
&#13;
    addOverlay: methodOp(function(spec, options) {&#13;
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);&#13;
      if (mode.startState) throw new Error("Overlays may not be stateful.");&#13;
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options &amp;&amp; options.opaque});&#13;
      this.state.modeGen++;&#13;
      regChange(this);&#13;
    }),&#13;
    removeOverlay: methodOp(function(spec) {&#13;
      var overlays = this.state.overlays;&#13;
      for (var i = 0; i &lt; overlays.length; ++i) {&#13;
        var cur = overlays[i].modeSpec;&#13;
        if (cur == spec || typeof spec == "string" &amp;&amp; cur.name == spec) {&#13;
          overlays.splice(i, 1);&#13;
          this.state.modeGen++;&#13;
          regChange(this);&#13;
          return;&#13;
        }&#13;
      }&#13;
    }),&#13;
&#13;
    indentLine: methodOp(function(n, dir, aggressive) {&#13;
      if (typeof dir != "string" &amp;&amp; typeof dir != "number") {&#13;
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";&#13;
        else dir = dir ? "add" : "subtract";&#13;
      }&#13;
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);&#13;
    }),&#13;
    indentSelection: methodOp(function(how) {&#13;
      var ranges = this.doc.sel.ranges, end = -1;&#13;
      for (var i = 0; i &lt; ranges.length; i++) {&#13;
        var range = ranges[i];&#13;
        if (!range.empty()) {&#13;
          var from = range.from(), to = range.to();&#13;
          var start = Math.max(end, from.line);&#13;
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;&#13;
          for (var j = start; j &lt; end; ++j)&#13;
            indentLine(this, j, how);&#13;
          var newRanges = this.doc.sel.ranges;&#13;
          if (from.ch == 0 &amp;&amp; ranges.length == newRanges.length &amp;&amp; newRanges[i].from().ch &gt; 0)&#13;
            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);&#13;
        } else if (range.head.line &gt; end) {&#13;
          indentLine(this, range.head.line, how, true);&#13;
          end = range.head.line;&#13;
          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);&#13;
        }&#13;
      }&#13;
    }),&#13;
&#13;
    // Fetch the parser token for a given character. Useful for hacks&#13;
    // that want to inspect the mode state (say, for completion).&#13;
    getTokenAt: function(pos, precise) {&#13;
      return takeToken(this, pos, precise);&#13;
    },&#13;
&#13;
    getLineTokens: function(line, precise) {&#13;
      return takeToken(this, Pos(line), precise, true);&#13;
    },&#13;
&#13;
    getTokenTypeAt: function(pos) {&#13;
      pos = clipPos(this.doc, pos);&#13;
      var styles = getLineStyles(this, getLine(this.doc, pos.line));&#13;
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;&#13;
      var type;&#13;
      if (ch == 0) type = styles[2];&#13;
      else for (;;) {&#13;
        var mid = (before + after) &gt;&gt; 1;&#13;
        if ((mid ? styles[mid * 2 - 1] : 0) &gt;= ch) after = mid;&#13;
        else if (styles[mid * 2 + 1] &lt; ch) before = mid + 1;&#13;
        else { type = styles[mid * 2 + 2]; break; }&#13;
      }&#13;
      var cut = type ? type.indexOf("cm-overlay ") : -1;&#13;
      return cut &lt; 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);&#13;
    },&#13;
&#13;
    getModeAt: function(pos) {&#13;
      var mode = this.doc.mode;&#13;
      if (!mode.innerMode) return mode;&#13;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;&#13;
    },&#13;
&#13;
    getHelper: function(pos, type) {&#13;
      return this.getHelpers(pos, type)[0];&#13;
    },&#13;
&#13;
    getHelpers: function(pos, type) {&#13;
      var found = [];&#13;
      if (!helpers.hasOwnProperty(type)) return found;&#13;
      var help = helpers[type], mode = this.getModeAt(pos);&#13;
      if (typeof mode[type] == "string") {&#13;
        if (help[mode[type]]) found.push(help[mode[type]]);&#13;
      } else if (mode[type]) {&#13;
        for (var i = 0; i &lt; mode[type].length; i++) {&#13;
          var val = help[mode[type][i]];&#13;
          if (val) found.push(val);&#13;
        }&#13;
      } else if (mode.helperType &amp;&amp; help[mode.helperType]) {&#13;
        found.push(help[mode.helperType]);&#13;
      } else if (help[mode.name]) {&#13;
        found.push(help[mode.name]);&#13;
      }&#13;
      for (var i = 0; i &lt; help._global.length; i++) {&#13;
        var cur = help._global[i];&#13;
        if (cur.pred(mode, this) &amp;&amp; indexOf(found, cur.val) == -1)&#13;
          found.push(cur.val);&#13;
      }&#13;
      return found;&#13;
    },&#13;
&#13;
    getStateAfter: function(line, precise) {&#13;
      var doc = this.doc;&#13;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);&#13;
      return getStateBefore(this, line + 1, precise);&#13;
    },&#13;
&#13;
    cursorCoords: function(start, mode) {&#13;
      var pos, range = this.doc.sel.primary();&#13;
      if (start == null) pos = range.head;&#13;
      else if (typeof start == "object") pos = clipPos(this.doc, start);&#13;
      else pos = start ? range.from() : range.to();&#13;
      return cursorCoords(this, pos, mode || "page");&#13;
    },&#13;
&#13;
    charCoords: function(pos, mode) {&#13;
      return charCoords(this, clipPos(this.doc, pos), mode || "page");&#13;
    },&#13;
&#13;
    coordsChar: function(coords, mode) {&#13;
      coords = fromCoordSystem(this, coords, mode || "page");&#13;
      return coordsChar(this, coords.left, coords.top);&#13;
    },&#13;
&#13;
    lineAtHeight: function(height, mode) {&#13;
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;&#13;
      return lineAtHeight(this.doc, height + this.display.viewOffset);&#13;
    },&#13;
    heightAtLine: function(line, mode) {&#13;
      var end = false, lineObj;&#13;
      if (typeof line == "number") {&#13;
        var last = this.doc.first + this.doc.size - 1;&#13;
        if (line &lt; this.doc.first) line = this.doc.first;&#13;
        else if (line &gt; last) { line = last; end = true; }&#13;
        lineObj = getLine(this.doc, line);&#13;
      } else {&#13;
        lineObj = line;&#13;
      }&#13;
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +&#13;
        (end ? this.doc.height - heightAtLine(lineObj) : 0);&#13;
    },&#13;
&#13;
    defaultTextHeight: function() { return textHeight(this.display); },&#13;
    defaultCharWidth: function() { return charWidth(this.display); },&#13;
&#13;
    setGutterMarker: methodOp(function(line, gutterID, value) {&#13;
      return changeLine(this.doc, line, "gutter", function(line) {&#13;
        var markers = line.gutterMarkers || (line.gutterMarkers = {});&#13;
        markers[gutterID] = value;&#13;
        if (!value &amp;&amp; isEmpty(markers)) line.gutterMarkers = null;&#13;
        return true;&#13;
      });&#13;
    }),&#13;
&#13;
    clearGutter: methodOp(function(gutterID) {&#13;
      var cm = this, doc = cm.doc, i = doc.first;&#13;
      doc.iter(function(line) {&#13;
        if (line.gutterMarkers &amp;&amp; line.gutterMarkers[gutterID]) {&#13;
          line.gutterMarkers[gutterID] = null;&#13;
          regLineChange(cm, i, "gutter");&#13;
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;&#13;
        }&#13;
        ++i;&#13;
      });&#13;
    }),&#13;
&#13;
    lineInfo: function(line) {&#13;
      if (typeof line == "number") {&#13;
        if (!isLine(this.doc, line)) return null;&#13;
        var n = line;&#13;
        line = getLine(this.doc, line);&#13;
        if (!line) return null;&#13;
      } else {&#13;
        var n = lineNo(line);&#13;
        if (n == null) return null;&#13;
      }&#13;
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,&#13;
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,&#13;
              widgets: line.widgets};&#13;
    },&#13;
&#13;
    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},&#13;
&#13;
    addWidget: function(pos, node, scroll, vert, horiz) {&#13;
      var display = this.display;&#13;
      pos = cursorCoords(this, clipPos(this.doc, pos));&#13;
      var top = pos.bottom, left = pos.left;&#13;
      node.style.position = "absolute";&#13;
      node.setAttribute("cm-ignore-events", "true");&#13;
      this.display.input.setUneditable(node);&#13;
      display.sizer.appendChild(node);&#13;
      if (vert == "over") {&#13;
        top = pos.top;&#13;
      } else if (vert == "above" || vert == "near") {&#13;
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),&#13;
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);&#13;
        // Default to positioning above (if specified and possible); otherwise default to positioning below&#13;
        if ((vert == 'above' || pos.bottom + node.offsetHeight &gt; vspace) &amp;&amp; pos.top &gt; node.offsetHeight)&#13;
          top = pos.top - node.offsetHeight;&#13;
        else if (pos.bottom + node.offsetHeight &lt;= vspace)&#13;
          top = pos.bottom;&#13;
        if (left + node.offsetWidth &gt; hspace)&#13;
          left = hspace - node.offsetWidth;&#13;
      }&#13;
      node.style.top = top + "px";&#13;
      node.style.left = node.style.right = "";&#13;
      if (horiz == "right") {&#13;
        left = display.sizer.clientWidth - node.offsetWidth;&#13;
        node.style.right = "0px";&#13;
      } else {&#13;
        if (horiz == "left") left = 0;&#13;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;&#13;
        node.style.left = left + "px";&#13;
      }&#13;
      if (scroll)&#13;
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);&#13;
    },&#13;
&#13;
    triggerOnKeyDown: methodOp(onKeyDown),&#13;
    triggerOnKeyPress: methodOp(onKeyPress),&#13;
    triggerOnKeyUp: onKeyUp,&#13;
&#13;
    execCommand: function(cmd) {&#13;
      if (commands.hasOwnProperty(cmd))&#13;
        return commands[cmd].call(null, this);&#13;
    },&#13;
&#13;
    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),&#13;
&#13;
    findPosH: function(from, amount, unit, visually) {&#13;
      var dir = 1;&#13;
      if (amount &lt; 0) { dir = -1; amount = -amount; }&#13;
      for (var i = 0, cur = clipPos(this.doc, from); i &lt; amount; ++i) {&#13;
        cur = findPosH(this.doc, cur, dir, unit, visually);&#13;
        if (cur.hitSide) break;&#13;
      }&#13;
      return cur;&#13;
    },&#13;
&#13;
    moveH: methodOp(function(dir, unit) {&#13;
      var cm = this;&#13;
      cm.extendSelectionsBy(function(range) {&#13;
        if (cm.display.shift || cm.doc.extend || range.empty())&#13;
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);&#13;
        else&#13;
          return dir &lt; 0 ? range.from() : range.to();&#13;
      }, sel_move);&#13;
    }),&#13;
&#13;
    deleteH: methodOp(function(dir, unit) {&#13;
      var sel = this.doc.sel, doc = this.doc;&#13;
      if (sel.somethingSelected())&#13;
        doc.replaceSelection("", null, "+delete");&#13;
      else&#13;
        deleteNearSelection(this, function(range) {&#13;
          var other = findPosH(doc, range.head, dir, unit, false);&#13;
          return dir &lt; 0 ? {from: other, to: range.head} : {from: range.head, to: other};&#13;
        });&#13;
    }),&#13;
&#13;
    findPosV: function(from, amount, unit, goalColumn) {&#13;
      var dir = 1, x = goalColumn;&#13;
      if (amount &lt; 0) { dir = -1; amount = -amount; }&#13;
      for (var i = 0, cur = clipPos(this.doc, from); i &lt; amount; ++i) {&#13;
        var coords = cursorCoords(this, cur, "div");&#13;
        if (x == null) x = coords.left;&#13;
        else coords.left = x;&#13;
        cur = findPosV(this, coords, dir, unit);&#13;
        if (cur.hitSide) break;&#13;
      }&#13;
      return cur;&#13;
    },&#13;
&#13;
    moveV: methodOp(function(dir, unit) {&#13;
      var cm = this, doc = this.doc, goals = [];&#13;
      var collapse = !cm.display.shift &amp;&amp; !doc.extend &amp;&amp; doc.sel.somethingSelected();&#13;
      doc.extendSelectionsBy(function(range) {&#13;
        if (collapse)&#13;
          return dir &lt; 0 ? range.from() : range.to();&#13;
        var headPos = cursorCoords(cm, range.head, "div");&#13;
        if (range.goalColumn != null) headPos.left = range.goalColumn;&#13;
        goals.push(headPos.left);&#13;
        var pos = findPosV(cm, headPos, dir, unit);&#13;
        if (unit == "page" &amp;&amp; range == doc.sel.primary())&#13;
          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);&#13;
        return pos;&#13;
      }, sel_move);&#13;
      if (goals.length) for (var i = 0; i &lt; doc.sel.ranges.length; i++)&#13;
        doc.sel.ranges[i].goalColumn = goals[i];&#13;
    }),&#13;
&#13;
    // Find the word at the given position (as returned by coordsChar).&#13;
    findWordAt: function(pos) {&#13;
      var doc = this.doc, line = getLine(doc, pos.line).text;&#13;
      var start = pos.ch, end = pos.ch;&#13;
      if (line) {&#13;
        var helper = this.getHelper(pos, "wordChars");&#13;
        if ((pos.xRel &lt; 0 || end == line.length) &amp;&amp; start) --start; else ++end;&#13;
        var startChar = line.charAt(start);&#13;
        var check = isWordChar(startChar, helper)&#13;
          ? function(ch) { return isWordChar(ch, helper); }&#13;
          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}&#13;
          : function(ch) {return !/\s/.test(ch) &amp;&amp; !isWordChar(ch);};&#13;
        while (start &gt; 0 &amp;&amp; check(line.charAt(start - 1))) --start;&#13;
        while (end &lt; line.length &amp;&amp; check(line.charAt(end))) ++end;&#13;
      }&#13;
      return new Range(Pos(pos.line, start), Pos(pos.line, end));&#13;
    },&#13;
&#13;
    toggleOverwrite: function(value) {&#13;
      if (value != null &amp;&amp; value == this.state.overwrite) return;&#13;
      if (this.state.overwrite = !this.state.overwrite)&#13;
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");&#13;
      else&#13;
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");&#13;
&#13;
      signal(this, "overwriteToggle", this, this.state.overwrite);&#13;
    },&#13;
    hasFocus: function() { return this.display.input.getField() == activeElt(); },&#13;
    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },&#13;
&#13;
    scrollTo: methodOp(function(x, y) {&#13;
      if (x != null || y != null) resolveScrollToPos(this);&#13;
      if (x != null) this.curOp.scrollLeft = x;&#13;
      if (y != null) this.curOp.scrollTop = y;&#13;
    }),&#13;
    getScrollInfo: function() {&#13;
      var scroller = this.display.scroller;&#13;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,&#13;
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,&#13;
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,&#13;
              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};&#13;
    },&#13;
&#13;
    scrollIntoView: methodOp(function(range, margin) {&#13;
      if (range == null) {&#13;
        range = {from: this.doc.sel.primary().head, to: null};&#13;
        if (margin == null) margin = this.options.cursorScrollMargin;&#13;
      } else if (typeof range == "number") {&#13;
        range = {from: Pos(range, 0), to: null};&#13;
      } else if (range.from == null) {&#13;
        range = {from: range, to: null};&#13;
      }&#13;
      if (!range.to) range.to = range.from;&#13;
      range.margin = margin || 0;&#13;
&#13;
      if (range.from.line != null) {&#13;
        resolveScrollToPos(this);&#13;
        this.curOp.scrollToPos = range;&#13;
      } else {&#13;
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),&#13;
                                      Math.min(range.from.top, range.to.top) - range.margin,&#13;
                                      Math.max(range.from.right, range.to.right),&#13;
                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);&#13;
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);&#13;
      }&#13;
    }),&#13;
&#13;
    setSize: methodOp(function(width, height) {&#13;
      var cm = this;&#13;
      function interpret(val) {&#13;
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;&#13;
      }&#13;
      if (width != null) cm.display.wrapper.style.width = interpret(width);&#13;
      if (height != null) cm.display.wrapper.style.height = interpret(height);&#13;
      if (cm.options.lineWrapping) clearLineMeasurementCache(this);&#13;
      var lineNo = cm.display.viewFrom;&#13;
      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {&#13;
        if (line.widgets) for (var i = 0; i &lt; line.widgets.length; i++)&#13;
          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }&#13;
        ++lineNo;&#13;
      });&#13;
      cm.curOp.forceUpdate = true;&#13;
      signal(cm, "refresh", this);&#13;
    }),&#13;
&#13;
    operation: function(f){return runInOp(this, f);},&#13;
&#13;
    refresh: methodOp(function() {&#13;
      var oldHeight = this.display.cachedTextHeight;&#13;
      regChange(this);&#13;
      this.curOp.forceUpdate = true;&#13;
      clearCaches(this);&#13;
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);&#13;
      updateGutterSpace(this);&#13;
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) &gt; .5)&#13;
        estimateLineHeights(this);&#13;
      signal(this, "refresh", this);&#13;
    }),&#13;
&#13;
    swapDoc: methodOp(function(doc) {&#13;
      var old = this.doc;&#13;
      old.cm = null;&#13;
      attachDoc(this, doc);&#13;
      clearCaches(this);&#13;
      this.display.input.reset();&#13;
      this.scrollTo(doc.scrollLeft, doc.scrollTop);&#13;
      this.curOp.forceScroll = true;&#13;
      signalLater(this, "swapDoc", this, old);&#13;
      return old;&#13;
    }),&#13;
&#13;
    getInputField: function(){return this.display.input.getField();},&#13;
    getWrapperElement: function(){return this.display.wrapper;},&#13;
    getScrollerElement: function(){return this.display.scroller;},&#13;
    getGutterElement: function(){return this.display.gutters;}&#13;
  };&#13;
  eventMixin(CodeMirror);&#13;
&#13;
  // OPTION DEFAULTS&#13;
&#13;
  // The default configuration options.&#13;
  var defaults = CodeMirror.defaults = {};&#13;
  // Functions to run when options are changed.&#13;
  var optionHandlers = CodeMirror.optionHandlers = {};&#13;
&#13;
  function option(name, deflt, handle, notOnInit) {&#13;
    CodeMirror.defaults[name] = deflt;&#13;
    if (handle) optionHandlers[name] =&#13;
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;&#13;
  }&#13;
&#13;
  // Passed to option handlers when there is no old value.&#13;
  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};&#13;
&#13;
  // These two are, on init, called from the constructor because they&#13;
  // have to be initialized before the editor can start at all.&#13;
  option("value", "", function(cm, val) {&#13;
    cm.setValue(val);&#13;
  }, true);&#13;
  option("mode", null, function(cm, val) {&#13;
    cm.doc.modeOption = val;&#13;
    loadMode(cm);&#13;
  }, true);&#13;
&#13;
  option("indentUnit", 2, loadMode, true);&#13;
  option("indentWithTabs", false);&#13;
  option("smartIndent", true);&#13;
  option("tabSize", 4, function(cm) {&#13;
    resetModeState(cm);&#13;
    clearCaches(cm);&#13;
    regChange(cm);&#13;
  }, true);&#13;
  option("lineSeparator", null, function(cm, val) {&#13;
    cm.doc.lineSep = val;&#13;
    if (!val) return;&#13;
    var newBreaks = [], lineNo = cm.doc.first;&#13;
    cm.doc.iter(function(line) {&#13;
      for (var pos = 0;;) {&#13;
        var found = line.text.indexOf(val, pos);&#13;
        if (found == -1) break;&#13;
        pos = found + val.length;&#13;
        newBreaks.push(Pos(lineNo, found));&#13;
      }&#13;
      lineNo++;&#13;
    });&#13;
    for (var i = newBreaks.length - 1; i &gt;= 0; i--)&#13;
      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))&#13;
  });&#13;
  option("specialChars", /[\u0000-\u001f\u007f\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {&#13;
    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");&#13;
    if (old != CodeMirror.Init) cm.refresh();&#13;
  });&#13;
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);&#13;
  option("electricChars", true);&#13;
  option("inputStyle", mobile ? "contenteditable" : "textarea", function() {&#13;
    throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME&#13;
  }, true);&#13;
  option("rtlMoveVisually", !windows);&#13;
  option("wholeLineUpdateBefore", true);&#13;
&#13;
  option("theme", "default", function(cm) {&#13;
    themeChanged(cm);&#13;
    guttersChanged(cm);&#13;
  }, true);&#13;
  option("keyMap", "default", function(cm, val, old) {&#13;
    var next = getKeyMap(val);&#13;
    var prev = old != CodeMirror.Init &amp;&amp; getKeyMap(old);&#13;
    if (prev &amp;&amp; prev.detach) prev.detach(cm, next);&#13;
    if (next.attach) next.attach(cm, prev || null);&#13;
  });&#13;
  option("extraKeys", null);&#13;
&#13;
  option("lineWrapping", false, wrappingChanged, true);&#13;
  option("gutters", [], function(cm) {&#13;
    setGuttersForLineNumbers(cm.options);&#13;
    guttersChanged(cm);&#13;
  }, true);&#13;
  option("fixedGutter", true, function(cm, val) {&#13;
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";&#13;
    cm.refresh();&#13;
  }, true);&#13;
  option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);&#13;
  option("scrollbarStyle", "native", function(cm) {&#13;
    initScrollbars(cm);&#13;
    updateScrollbars(cm);&#13;
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);&#13;
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);&#13;
  }, true);&#13;
  option("lineNumbers", false, function(cm) {&#13;
    setGuttersForLineNumbers(cm.options);&#13;
    guttersChanged(cm);&#13;
  }, true);&#13;
  option("firstLineNumber", 1, guttersChanged, true);&#13;
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);&#13;
  option("showCursorWhenSelecting", false, updateSelection, true);&#13;
&#13;
  option("resetSelectionOnContextMenu", true);&#13;
  option("lineWiseCopyCut", true);&#13;
&#13;
  option("readOnly", false, function(cm, val) {&#13;
    if (val == "nocursor") {&#13;
      onBlur(cm);&#13;
      cm.display.input.blur();&#13;
      cm.display.disabled = true;&#13;
    } else {&#13;
      cm.display.disabled = false;&#13;
    }&#13;
    cm.display.input.readOnlyChanged(val)&#13;
  });&#13;
  option("disableInput", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);&#13;
  option("dragDrop", true, dragDropChanged);&#13;
  option("allowDropFileTypes", null);&#13;
&#13;
  option("cursorBlinkRate", 530);&#13;
  option("cursorScrollMargin", 0);&#13;
  option("cursorHeight", 1, updateSelection, true);&#13;
  option("singleCursorHeightPerLine", true, updateSelection, true);&#13;
  option("workTime", 100);&#13;
  option("workDelay", 100);&#13;
  option("flattenSpans", true, resetModeState, true);&#13;
  option("addModeClass", false, resetModeState, true);&#13;
  option("pollInterval", 100);&#13;
  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});&#13;
  option("historyEventDelay", 1250);&#13;
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);&#13;
  option("maxHighlightLength", 10000, resetModeState, true);&#13;
  option("moveInputWithCursor", true, function(cm, val) {&#13;
    if (!val) cm.display.input.resetPosition();&#13;
  });&#13;
&#13;
  option("tabindex", null, function(cm, val) {&#13;
    cm.display.input.getField().tabIndex = val || "";&#13;
  });&#13;
  option("autofocus", null);&#13;
&#13;
  // MODE DEFINITION AND QUERYING&#13;
&#13;
  // Known modes, by name and by MIME&#13;
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};&#13;
&#13;
  // Extra arguments are stored as the mode's dependencies, which is&#13;
  // used by (legacy) mechanisms like loadmode.js to automatically&#13;
  // load a mode. (Preferred mechanism is the require/define calls.)&#13;
  CodeMirror.defineMode = function(name, mode) {&#13;
    if (!CodeMirror.defaults.mode &amp;&amp; name != "null") CodeMirror.defaults.mode = name;&#13;
    if (arguments.length &gt; 2)&#13;
      mode.dependencies = Array.prototype.slice.call(arguments, 2);&#13;
    modes[name] = mode;&#13;
  };&#13;
&#13;
  CodeMirror.defineMIME = function(mime, spec) {&#13;
    mimeModes[mime] = spec;&#13;
  };&#13;
&#13;
  // Given a MIME type, a {name, ...options} config object, or a name&#13;
  // string, return a mode config object.&#13;
  CodeMirror.resolveMode = function(spec) {&#13;
    if (typeof spec == "string" &amp;&amp; mimeModes.hasOwnProperty(spec)) {&#13;
      spec = mimeModes[spec];&#13;
    } else if (spec &amp;&amp; typeof spec.name == "string" &amp;&amp; mimeModes.hasOwnProperty(spec.name)) {&#13;
      var found = mimeModes[spec.name];&#13;
      if (typeof found == "string") found = {name: found};&#13;
      spec = createObj(found, spec);&#13;
      spec.name = found.name;&#13;
    } else if (typeof spec == "string" &amp;&amp; /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {&#13;
      return CodeMirror.resolveMode("application/xml");&#13;
    }&#13;
    if (typeof spec == "string") return {name: spec};&#13;
    else return spec || {name: "null"};&#13;
  };&#13;
&#13;
  // Given a mode spec (anything that resolveMode accepts), find and&#13;
  // initialize an actual mode object.&#13;
  CodeMirror.getMode = function(options, spec) {&#13;
    var spec = CodeMirror.resolveMode(spec);&#13;
    var mfactory = modes[spec.name];&#13;
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");&#13;
    var modeObj = mfactory(options, spec);&#13;
    if (modeExtensions.hasOwnProperty(spec.name)) {&#13;
      var exts = modeExtensions[spec.name];&#13;
      for (var prop in exts) {&#13;
        if (!exts.hasOwnProperty(prop)) continue;&#13;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];&#13;
        modeObj[prop] = exts[prop];&#13;
      }&#13;
    }&#13;
    modeObj.name = spec.name;&#13;
    if (spec.helperType) modeObj.helperType = spec.helperType;&#13;
    if (spec.modeProps) for (var prop in spec.modeProps)&#13;
      modeObj[prop] = spec.modeProps[prop];&#13;
&#13;
    return modeObj;&#13;
  };&#13;
&#13;
  // Minimal default mode.&#13;
  CodeMirror.defineMode("null", function() {&#13;
    return {token: function(stream) {stream.skipToEnd();}};&#13;
  });&#13;
  CodeMirror.defineMIME("text/plain", "null");&#13;
&#13;
  // This can be used to attach properties to mode objects from&#13;
  // outside the actual mode definition.&#13;
  var modeExtensions = CodeMirror.modeExtensions = {};&#13;
  CodeMirror.extendMode = function(mode, properties) {&#13;
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});&#13;
    copyObj(properties, exts);&#13;
  };&#13;
&#13;
  // EXTENSIONS&#13;
&#13;
  CodeMirror.defineExtension = function(name, func) {&#13;
    CodeMirror.prototype[name] = func;&#13;
  };&#13;
  CodeMirror.defineDocExtension = function(name, func) {&#13;
    Doc.prototype[name] = func;&#13;
  };&#13;
  CodeMirror.defineOption = option;&#13;
&#13;
  var initHooks = [];&#13;
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};&#13;
&#13;
  var helpers = CodeMirror.helpers = {};&#13;
  CodeMirror.registerHelper = function(type, name, value) {&#13;
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};&#13;
    helpers[type][name] = value;&#13;
  };&#13;
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {&#13;
    CodeMirror.registerHelper(type, name, value);&#13;
    helpers[type]._global.push({pred: predicate, val: value});&#13;
  };&#13;
&#13;
  // MODE STATE HANDLING&#13;
&#13;
  // Utility functions for working with state. Exported because nested&#13;
  // modes need to do this for their inner modes.&#13;
&#13;
  var copyState = CodeMirror.copyState = function(mode, state) {&#13;
    if (state === true) return state;&#13;
    if (mode.copyState) return mode.copyState(state);&#13;
    var nstate = {};&#13;
    for (var n in state) {&#13;
      var val = state[n];&#13;
      if (val instanceof Array) val = val.concat([]);&#13;
      nstate[n] = val;&#13;
    }&#13;
    return nstate;&#13;
  };&#13;
&#13;
  var startState = CodeMirror.startState = function(mode, a1, a2) {&#13;
    return mode.startState ? mode.startState(a1, a2) : true;&#13;
  };&#13;
&#13;
  // Given a mode and a state (for that mode), find the inner mode and&#13;
  // state at the position that the state refers to.&#13;
  CodeMirror.innerMode = function(mode, state) {&#13;
    while (mode.innerMode) {&#13;
      var info = mode.innerMode(state);&#13;
      if (!info || info.mode == mode) break;&#13;
      state = info.state;&#13;
      mode = info.mode;&#13;
    }&#13;
    return info || {mode: mode, state: state};&#13;
  };&#13;
&#13;
  // STANDARD COMMANDS&#13;
&#13;
  // Commands are parameter-less actions that can be performed on an&#13;
  // editor, mostly used for keybindings.&#13;
  var commands = CodeMirror.commands = {&#13;
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},&#13;
    singleSelection: function(cm) {&#13;
      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);&#13;
    },&#13;
    killLine: function(cm) {&#13;
      deleteNearSelection(cm, function(range) {&#13;
        if (range.empty()) {&#13;
          var len = getLine(cm.doc, range.head.line).text.length;&#13;
          if (range.head.ch == len &amp;&amp; range.head.line &lt; cm.lastLine())&#13;
            return {from: range.head, to: Pos(range.head.line + 1, 0)};&#13;
          else&#13;
            return {from: range.head, to: Pos(range.head.line, len)};&#13;
        } else {&#13;
          return {from: range.from(), to: range.to()};&#13;
        }&#13;
      });&#13;
    },&#13;
    deleteLine: function(cm) {&#13;
      deleteNearSelection(cm, function(range) {&#13;
        return {from: Pos(range.from().line, 0),&#13;
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};&#13;
      });&#13;
    },&#13;
    delLineLeft: function(cm) {&#13;
      deleteNearSelection(cm, function(range) {&#13;
        return {from: Pos(range.from().line, 0), to: range.from()};&#13;
      });&#13;
    },&#13;
    delWrappedLineLeft: function(cm) {&#13;
      deleteNearSelection(cm, function(range) {&#13;
        var top = cm.charCoords(range.head, "div").top + 5;&#13;
        var leftPos = cm.coordsChar({left: 0, top: top}, "div");&#13;
        return {from: leftPos, to: range.from()};&#13;
      });&#13;
    },&#13;
    delWrappedLineRight: function(cm) {&#13;
      deleteNearSelection(cm, function(range) {&#13;
        var top = cm.charCoords(range.head, "div").top + 5;&#13;
        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");&#13;
        return {from: range.from(), to: rightPos };&#13;
      });&#13;
    },&#13;
    undo: function(cm) {cm.undo();},&#13;
    redo: function(cm) {cm.redo();},&#13;
    undoSelection: function(cm) {cm.undoSelection();},&#13;
    redoSelection: function(cm) {cm.redoSelection();},&#13;
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},&#13;
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},&#13;
    goLineStart: function(cm) {&#13;
      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },&#13;
                            {origin: "+move", bias: 1});&#13;
    },&#13;
    goLineStartSmart: function(cm) {&#13;
      cm.extendSelectionsBy(function(range) {&#13;
        return lineStartSmart(cm, range.head);&#13;
      }, {origin: "+move", bias: 1});&#13;
    },&#13;
    goLineEnd: function(cm) {&#13;
      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },&#13;
                            {origin: "+move", bias: -1});&#13;
    },&#13;
    goLineRight: function(cm) {&#13;
      cm.extendSelectionsBy(function(range) {&#13;
        var top = cm.charCoords(range.head, "div").top + 5;&#13;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");&#13;
      }, sel_move);&#13;
    },&#13;
    goLineLeft: function(cm) {&#13;
      cm.extendSelectionsBy(function(range) {&#13;
        var top = cm.charCoords(range.head, "div").top + 5;&#13;
        return cm.coordsChar({left: 0, top: top}, "div");&#13;
      }, sel_move);&#13;
    },&#13;
    goLineLeftSmart: function(cm) {&#13;
      cm.extendSelectionsBy(function(range) {&#13;
        var top = cm.charCoords(range.head, "div").top + 5;&#13;
        var pos = cm.coordsChar({left: 0, top: top}, "div");&#13;
        if (pos.ch &lt; cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);&#13;
        return pos;&#13;
      }, sel_move);&#13;
    },&#13;
    goLineUp: function(cm) {cm.moveV(-1, "line");},&#13;
    goLineDown: function(cm) {cm.moveV(1, "line");},&#13;
    goPageUp: function(cm) {cm.moveV(-1, "page");},&#13;
    goPageDown: function(cm) {cm.moveV(1, "page");},&#13;
    goCharLeft: function(cm) {cm.moveH(-1, "char");},&#13;
    goCharRight: function(cm) {cm.moveH(1, "char");},&#13;
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},&#13;
    goColumnRight: function(cm) {cm.moveH(1, "column");},&#13;
    goWordLeft: function(cm) {cm.moveH(-1, "word");},&#13;
    goGroupRight: function(cm) {cm.moveH(1, "group");},&#13;
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},&#13;
    goWordRight: function(cm) {cm.moveH(1, "word");},&#13;
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},&#13;
    delCharAfter: function(cm) {cm.deleteH(1, "char");},&#13;
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},&#13;
    delWordAfter: function(cm) {cm.deleteH(1, "word");},&#13;
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},&#13;
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},&#13;
    indentAuto: function(cm) {cm.indentSelection("smart");},&#13;
    indentMore: function(cm) {cm.indentSelection("add");},&#13;
    indentLess: function(cm) {cm.indentSelection("subtract");},&#13;
    insertTab: function(cm) {cm.replaceSelection("\t");},&#13;
    insertSoftTab: function(cm) {&#13;
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;&#13;
      for (var i = 0; i &lt; ranges.length; i++) {&#13;
        var pos = ranges[i].from();&#13;
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);&#13;
        spaces.push(spaceStr(tabSize - col % tabSize));&#13;
      }&#13;
      cm.replaceSelections(spaces);&#13;
    },&#13;
    defaultTab: function(cm) {&#13;
      if (cm.somethingSelected()) cm.indentSelection("add");&#13;
      else cm.execCommand("insertTab");&#13;
    },&#13;
    transposeChars: function(cm) {&#13;
      runInOp(cm, function() {&#13;
        var ranges = cm.listSelections(), newSel = [];&#13;
        for (var i = 0; i &lt; ranges.length; i++) {&#13;
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;&#13;
          if (line) {&#13;
            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);&#13;
            if (cur.ch &gt; 0) {&#13;
              cur = new Pos(cur.line, cur.ch + 1);&#13;
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),&#13;
                              Pos(cur.line, cur.ch - 2), cur, "+transpose");&#13;
            } else if (cur.line &gt; cm.doc.first) {&#13;
              var prev = getLine(cm.doc, cur.line - 1).text;&#13;
              if (prev)&#13;
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +&#13;
                                prev.charAt(prev.length - 1),&#13;
                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");&#13;
            }&#13;
          }&#13;
          newSel.push(new Range(cur, cur));&#13;
        }&#13;
        cm.setSelections(newSel);&#13;
      });&#13;
    },&#13;
    newlineAndIndent: function(cm) {&#13;
      runInOp(cm, function() {&#13;
        var len = cm.listSelections().length;&#13;
        for (var i = 0; i &lt; len; i++) {&#13;
          var range = cm.listSelections()[i];&#13;
          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, "+input");&#13;
          cm.indentLine(range.from().line + 1, null, true);&#13;
        }&#13;
        ensureCursorVisible(cm);&#13;
      });&#13;
    },&#13;
    openLine: function(cm) {cm.replaceSelection("\n", "start")},&#13;
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}&#13;
  };&#13;
&#13;
&#13;
  // STANDARD KEYMAPS&#13;
&#13;
  var keyMap = CodeMirror.keyMap = {};&#13;
&#13;
  keyMap.basic = {&#13;
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",&#13;
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",&#13;
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",&#13;
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",&#13;
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",&#13;
    "Esc": "singleSelection"&#13;
  };&#13;
  // Note that the save and find-related commands aren't defined by&#13;
  // default. User code or addons can define them. Unknown commands&#13;
  // are simply ignored.&#13;
  keyMap.pcDefault = {&#13;
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",&#13;
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",&#13;
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",&#13;
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",&#13;
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",&#13;
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",&#13;
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",&#13;
    fallthrough: "basic"&#13;
  };&#13;
  // Very basic readline/emacs-style bindings, which are standard on Mac.&#13;
  keyMap.emacsy = {&#13;
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",&#13;
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",&#13;
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",&#13;
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",&#13;
    "Ctrl-O": "openLine"&#13;
  };&#13;
  keyMap.macDefault = {&#13;
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",&#13;
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",&#13;
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",&#13;
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",&#13;
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",&#13;
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",&#13;
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",&#13;
    fallthrough: ["basic", "emacsy"]&#13;
  };&#13;
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;&#13;
&#13;
  // KEYMAP DISPATCH&#13;
&#13;
  function normalizeKeyName(name) {&#13;
    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];&#13;
    var alt, ctrl, shift, cmd;&#13;
    for (var i = 0; i &lt; parts.length - 1; i++) {&#13;
      var mod = parts[i];&#13;
      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;&#13;
      else if (/^a(lt)?$/i.test(mod)) alt = true;&#13;
      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;&#13;
      else if (/^s(hift)$/i.test(mod)) shift = true;&#13;
      else throw new Error("Unrecognized modifier name: " + mod);&#13;
    }&#13;
    if (alt) name = "Alt-" + name;&#13;
    if (ctrl) name = "Ctrl-" + name;&#13;
    if (cmd) name = "Cmd-" + name;&#13;
    if (shift) name = "Shift-" + name;&#13;
    return name;&#13;
  }&#13;
&#13;
  // This is a kludge to keep keymaps mostly working as raw objects&#13;
  // (backwards compatibility) while at the same time support features&#13;
  // like normalization and multi-stroke key bindings. It compiles a&#13;
  // new normalized keymap, and then updates the old object to reflect&#13;
  // this.&#13;
  CodeMirror.normalizeKeyMap = function(keymap) {&#13;
    var copy = {};&#13;
    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {&#13;
      var value = keymap[keyname];&#13;
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;&#13;
      if (value == "...") { delete keymap[keyname]; continue; }&#13;
&#13;
      var keys = map(keyname.split(" "), normalizeKeyName);&#13;
      for (var i = 0; i &lt; keys.length; i++) {&#13;
        var val, name;&#13;
        if (i == keys.length - 1) {&#13;
          name = keys.join(" ");&#13;
          val = value;&#13;
        } else {&#13;
          name = keys.slice(0, i + 1).join(" ");&#13;
          val = "...";&#13;
        }&#13;
        var prev = copy[name];&#13;
        if (!prev) copy[name] = val;&#13;
        else if (prev != val) throw new Error("Inconsistent bindings for " + name);&#13;
      }&#13;
      delete keymap[keyname];&#13;
    }&#13;
    for (var prop in copy) keymap[prop] = copy[prop];&#13;
    return keymap;&#13;
  };&#13;
&#13;
  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {&#13;
    map = getKeyMap(map);&#13;
    var found = map.call ? map.call(key, context) : map[key];&#13;
    if (found === false) return "nothing";&#13;
    if (found === "...") return "multi";&#13;
    if (found != null &amp;&amp; handle(found)) return "handled";&#13;
&#13;
    if (map.fallthrough) {&#13;
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")&#13;
        return lookupKey(key, map.fallthrough, handle, context);&#13;
      for (var i = 0; i &lt; map.fallthrough.length; i++) {&#13;
        var result = lookupKey(key, map.fallthrough[i], handle, context);&#13;
        if (result) return result;&#13;
      }&#13;
    }&#13;
  };&#13;
&#13;
  // Modifier key presses don't count as 'real' key presses for the&#13;
  // purpose of keymap fallthrough.&#13;
  var isModifierKey = CodeMirror.isModifierKey = function(value) {&#13;
    var name = typeof value == "string" ? value : keyNames[value.keyCode];&#13;
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";&#13;
  };&#13;
&#13;
  // Look up the name of a key as indicated by an event object.&#13;
  var keyName = CodeMirror.keyName = function(event, noShift) {&#13;
    if (presto &amp;&amp; event.keyCode == 34 &amp;&amp; event["char"]) return false;&#13;
    var base = keyNames[event.keyCode], name = base;&#13;
    if (name == null || event.altGraphKey) return false;&#13;
    if (event.altKey &amp;&amp; base != "Alt") name = "Alt-" + name;&#13;
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) &amp;&amp; base != "Ctrl") name = "Ctrl-" + name;&#13;
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) &amp;&amp; base != "Cmd") name = "Cmd-" + name;&#13;
    if (!noShift &amp;&amp; event.shiftKey &amp;&amp; base != "Shift") name = "Shift-" + name;&#13;
    return name;&#13;
  };&#13;
&#13;
  function getKeyMap(val) {&#13;
    return typeof val == "string" ? keyMap[val] : val;&#13;
  }&#13;
&#13;
  // FROMTEXTAREA&#13;
&#13;
  CodeMirror.fromTextArea = function(textarea, options) {&#13;
    options = options ? copyObj(options) : {};&#13;
    options.value = textarea.value;&#13;
    if (!options.tabindex &amp;&amp; textarea.tabIndex)&#13;
      options.tabindex = textarea.tabIndex;&#13;
    if (!options.placeholder &amp;&amp; textarea.placeholder)&#13;
      options.placeholder = textarea.placeholder;&#13;
    // Set autofocus to true if this textarea is focused, or if it has&#13;
    // autofocus and no other element is focused.&#13;
    if (options.autofocus == null) {&#13;
      var hasFocus = activeElt();&#13;
      options.autofocus = hasFocus == textarea ||&#13;
        textarea.getAttribute("autofocus") != null &amp;&amp; hasFocus == document.body;&#13;
    }&#13;
&#13;
    function save() {textarea.value = cm.getValue();}&#13;
    if (textarea.form) {&#13;
      on(textarea.form, "submit", save);&#13;
      // Deplorable hack to make the submit method do the right thing.&#13;
      if (!options.leaveSubmitMethodAlone) {&#13;
        var form = textarea.form, realSubmit = form.submit;&#13;
        try {&#13;
          var wrappedSubmit = form.submit = function() {&#13;
            save();&#13;
            form.submit = realSubmit;&#13;
            form.submit();&#13;
            form.submit = wrappedSubmit;&#13;
          };&#13;
        } catch(e) {}&#13;
      }&#13;
    }&#13;
&#13;
    options.finishInit = function(cm) {&#13;
      cm.save = save;&#13;
      cm.getTextArea = function() { return textarea; };&#13;
      cm.toTextArea = function() {&#13;
        cm.toTextArea = isNaN; // Prevent this from being ran twice&#13;
        save();&#13;
        textarea.parentNode.removeChild(cm.getWrapperElement());&#13;
        textarea.style.display = "";&#13;
        if (textarea.form) {&#13;
          off(textarea.form, "submit", save);&#13;
          if (typeof textarea.form.submit == "function")&#13;
            textarea.form.submit = realSubmit;&#13;
        }&#13;
      };&#13;
    };&#13;
&#13;
    textarea.style.display = "none";&#13;
    var cm = CodeMirror(function(node) {&#13;
      textarea.parentNode.insertBefore(node, textarea.nextSibling);&#13;
    }, options);&#13;
    return cm;&#13;
  };&#13;
&#13;
  // STRING STREAM&#13;
&#13;
  // Fed to the mode parsers, provides helper functions to make&#13;
  // parsers more succinct.&#13;
&#13;
  var StringStream = CodeMirror.StringStream = function(string, tabSize) {&#13;
    this.pos = this.start = 0;&#13;
    this.string = string;&#13;
    this.tabSize = tabSize || 8;&#13;
    this.lastColumnPos = this.lastColumnValue = 0;&#13;
    this.lineStart = 0;&#13;
  };&#13;
&#13;
  StringStream.prototype = {&#13;
    eol: function() {return this.pos &gt;= this.string.length;},&#13;
    sol: function() {return this.pos == this.lineStart;},&#13;
    peek: function() {return this.string.charAt(this.pos) || undefined;},&#13;
    next: function() {&#13;
      if (this.pos &lt; this.string.length)&#13;
        return this.string.charAt(this.pos++);&#13;
    },&#13;
    eat: function(match) {&#13;
      var ch = this.string.charAt(this.pos);&#13;
      if (typeof match == "string") var ok = ch == match;&#13;
      else var ok = ch &amp;&amp; (match.test ? match.test(ch) : match(ch));&#13;
      if (ok) {++this.pos; return ch;}&#13;
    },&#13;
    eatWhile: function(match) {&#13;
      var start = this.pos;&#13;
      while (this.eat(match)){}&#13;
      return this.pos &gt; start;&#13;
    },&#13;
    eatSpace: function() {&#13;
      var start = this.pos;&#13;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;&#13;
      return this.pos &gt; start;&#13;
    },&#13;
    skipToEnd: function() {this.pos = this.string.length;},&#13;
    skipTo: function(ch) {&#13;
      var found = this.string.indexOf(ch, this.pos);&#13;
      if (found &gt; -1) {this.pos = found; return true;}&#13;
    },&#13;
    backUp: function(n) {this.pos -= n;},&#13;
    column: function() {&#13;
      if (this.lastColumnPos &lt; this.start) {&#13;
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);&#13;
        this.lastColumnPos = this.start;&#13;
      }&#13;
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);&#13;
    },&#13;
    indentation: function() {&#13;
      return countColumn(this.string, null, this.tabSize) -&#13;
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);&#13;
    },&#13;
    match: function(pattern, consume, caseInsensitive) {&#13;
      if (typeof pattern == "string") {&#13;
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};&#13;
        var substr = this.string.substr(this.pos, pattern.length);&#13;
        if (cased(substr) == cased(pattern)) {&#13;
          if (consume !== false) this.pos += pattern.length;&#13;
          return true;&#13;
        }&#13;
      } else {&#13;
        var match = this.string.slice(this.pos).match(pattern);&#13;
        if (match &amp;&amp; match.index &gt; 0) return null;&#13;
        if (match &amp;&amp; consume !== false) this.pos += match[0].length;&#13;
        return match;&#13;
      }&#13;
    },&#13;
    current: function(){return this.string.slice(this.start, this.pos);},&#13;
    hideFirstChars: function(n, inner) {&#13;
      this.lineStart += n;&#13;
      try { return inner(); }&#13;
      finally { this.lineStart -= n; }&#13;
    }&#13;
  };&#13;
&#13;
  // TEXTMARKERS&#13;
&#13;
  // Created with markText and setBookmark methods. A TextMarker is a&#13;
  // handle that can be used to clear or find a marked position in the&#13;
  // document. Line objects hold arrays (markedSpans) containing&#13;
  // {from, to, marker} object pointing to such marker objects, and&#13;
  // indicating that such a marker is present on that line. Multiple&#13;
  // lines may point to the same marker when it spans across lines.&#13;
  // The spans will have null for their from/to properties when the&#13;
  // marker continues beyond the start/end of the line. Markers have&#13;
  // links back to the lines they currently touch.&#13;
&#13;
  var nextMarkerId = 0;&#13;
&#13;
  var TextMarker = CodeMirror.TextMarker = function(doc, type) {&#13;
    this.lines = [];&#13;
    this.type = type;&#13;
    this.doc = doc;&#13;
    this.id = ++nextMarkerId;&#13;
  };&#13;
  eventMixin(TextMarker);&#13;
&#13;
  // Clear the marker.&#13;
  TextMarker.prototype.clear = function() {&#13;
    if (this.explicitlyCleared) return;&#13;
    var cm = this.doc.cm, withOp = cm &amp;&amp; !cm.curOp;&#13;
    if (withOp) startOperation(cm);&#13;
    if (hasHandler(this, "clear")) {&#13;
      var found = this.find();&#13;
      if (found) signalLater(this, "clear", found.from, found.to);&#13;
    }&#13;
    var min = null, max = null;&#13;
    for (var i = 0; i &lt; this.lines.length; ++i) {&#13;
      var line = this.lines[i];&#13;
      var span = getMarkedSpanFor(line.markedSpans, this);&#13;
      if (cm &amp;&amp; !this.collapsed) regLineChange(cm, lineNo(line), "text");&#13;
      else if (cm) {&#13;
        if (span.to != null) max = lineNo(line);&#13;
        if (span.from != null) min = lineNo(line);&#13;
      }&#13;
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);&#13;
      if (span.from == null &amp;&amp; this.collapsed &amp;&amp; !lineIsHidden(this.doc, line) &amp;&amp; cm)&#13;
        updateLineHeight(line, textHeight(cm.display));&#13;
    }&#13;
    if (cm &amp;&amp; this.collapsed &amp;&amp; !cm.options.lineWrapping) for (var i = 0; i &lt; this.lines.length; ++i) {&#13;
      var visual = visualLine(this.lines[i]), len = lineLength(visual);&#13;
      if (len &gt; cm.display.maxLineLength) {&#13;
        cm.display.maxLine = visual;&#13;
        cm.display.maxLineLength = len;&#13;
        cm.display.maxLineChanged = true;&#13;
      }&#13;
    }&#13;
&#13;
    if (min != null &amp;&amp; cm &amp;&amp; this.collapsed) regChange(cm, min, max + 1);&#13;
    this.lines.length = 0;&#13;
    this.explicitlyCleared = true;&#13;
    if (this.atomic &amp;&amp; this.doc.cantEdit) {&#13;
      this.doc.cantEdit = false;&#13;
      if (cm) reCheckSelection(cm.doc);&#13;
    }&#13;
    if (cm) signalLater(cm, "markerCleared", cm, this);&#13;
    if (withOp) endOperation(cm);&#13;
    if (this.parent) this.parent.clear();&#13;
  };&#13;
&#13;
  // Find the position of the marker in the document. Returns a {from,&#13;
  // to} object by default. Side can be passed to get a specific side&#13;
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the&#13;
  // Pos objects returned contain a line object, rather than a line&#13;
  // number (used to prevent looking up the same line twice).&#13;
  TextMarker.prototype.find = function(side, lineObj) {&#13;
    if (side == null &amp;&amp; this.type == "bookmark") side = 1;&#13;
    var from, to;&#13;
    for (var i = 0; i &lt; this.lines.length; ++i) {&#13;
      var line = this.lines[i];&#13;
      var span = getMarkedSpanFor(line.markedSpans, this);&#13;
      if (span.from != null) {&#13;
        from = Pos(lineObj ? line : lineNo(line), span.from);&#13;
        if (side == -1) return from;&#13;
      }&#13;
      if (span.to != null) {&#13;
        to = Pos(lineObj ? line : lineNo(line), span.to);&#13;
        if (side == 1) return to;&#13;
      }&#13;
    }&#13;
    return from &amp;&amp; {from: from, to: to};&#13;
  };&#13;
&#13;
  // Signals that the marker's widget changed, and surrounding layout&#13;
  // should be recomputed.&#13;
  TextMarker.prototype.changed = function() {&#13;
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;&#13;
    if (!pos || !cm) return;&#13;
    runInOp(cm, function() {&#13;
      var line = pos.line, lineN = lineNo(pos.line);&#13;
      var view = findViewForLine(cm, lineN);&#13;
      if (view) {&#13;
        clearLineMeasurementCacheFor(view);&#13;
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;&#13;
      }&#13;
      cm.curOp.updateMaxLine = true;&#13;
      if (!lineIsHidden(widget.doc, line) &amp;&amp; widget.height != null) {&#13;
        var oldHeight = widget.height;&#13;
        widget.height = null;&#13;
        var dHeight = widgetHeight(widget) - oldHeight;&#13;
        if (dHeight)&#13;
          updateLineHeight(line, line.height + dHeight);&#13;
      }&#13;
    });&#13;
  };&#13;
&#13;
  TextMarker.prototype.attachLine = function(line) {&#13;
    if (!this.lines.length &amp;&amp; this.doc.cm) {&#13;
      var op = this.doc.cm.curOp;&#13;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)&#13;
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);&#13;
    }&#13;
    this.lines.push(line);&#13;
  };&#13;
  TextMarker.prototype.detachLine = function(line) {&#13;
    this.lines.splice(indexOf(this.lines, line), 1);&#13;
    if (!this.lines.length &amp;&amp; this.doc.cm) {&#13;
      var op = this.doc.cm.curOp;&#13;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);&#13;
    }&#13;
  };&#13;
&#13;
  // Collapsed markers have unique ids, in order to be able to order&#13;
  // them, which is needed for uniquely determining an outer marker&#13;
  // when they overlap (they may nest, but not partially overlap).&#13;
  var nextMarkerId = 0;&#13;
&#13;
  // Create a marker, wire it up to the right lines, and&#13;
  function markText(doc, from, to, options, type) {&#13;
    // Shared markers (across linked documents) are handled separately&#13;
    // (markTextShared will call out to this again, once per&#13;
    // document).&#13;
    if (options &amp;&amp; options.shared) return markTextShared(doc, from, to, options, type);&#13;
    // Ensure we are in an operation.&#13;
    if (doc.cm &amp;&amp; !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);&#13;
&#13;
    var marker = new TextMarker(doc, type), diff = cmp(from, to);&#13;
    if (options) copyObj(options, marker, false);&#13;
    // Don't connect empty markers unless clearWhenEmpty is false&#13;
    if (diff &gt; 0 || diff == 0 &amp;&amp; marker.clearWhenEmpty !== false)&#13;
      return marker;&#13;
    if (marker.replacedWith) {&#13;
      // Showing up as a widget implies collapsed (widget replaces text)&#13;
      marker.collapsed = true;&#13;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");&#13;
      if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");&#13;
      if (options.insertLeft) marker.widgetNode.insertLeft = true;&#13;
    }&#13;
    if (marker.collapsed) {&#13;
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||&#13;
          from.line != to.line &amp;&amp; conflictingCollapsedRange(doc, to.line, from, to, marker))&#13;
        throw new Error("Inserting collapsed marker partially overlapping an existing one");&#13;
      sawCollapsedSpans = true;&#13;
    }&#13;
&#13;
    if (marker.addToHistory)&#13;
      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);&#13;
&#13;
    var curLine = from.line, cm = doc.cm, updateMaxLine;&#13;
    doc.iter(curLine, to.line + 1, function(line) {&#13;
      if (cm &amp;&amp; marker.collapsed &amp;&amp; !cm.options.lineWrapping &amp;&amp; visualLine(line) == cm.display.maxLine)&#13;
        updateMaxLine = true;&#13;
      if (marker.collapsed &amp;&amp; curLine != from.line) updateLineHeight(line, 0);&#13;
      addMarkedSpan(line, new MarkedSpan(marker,&#13;
                                         curLine == from.line ? from.ch : null,&#13;
                                         curLine == to.line ? to.ch : null));&#13;
      ++curLine;&#13;
    });&#13;
    // lineIsHidden depends on the presence of the spans, so needs a second pass&#13;
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {&#13;
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);&#13;
    });&#13;
&#13;
    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });&#13;
&#13;
    if (marker.readOnly) {&#13;
      sawReadOnlySpans = true;&#13;
      if (doc.history.done.length || doc.history.undone.length)&#13;
        doc.clearHistory();&#13;
    }&#13;
    if (marker.collapsed) {&#13;
      marker.id = ++nextMarkerId;&#13;
      marker.atomic = true;&#13;
    }&#13;
    if (cm) {&#13;
      // Sync editor state&#13;
      if (updateMaxLine) cm.curOp.updateMaxLine = true;&#13;
      if (marker.collapsed)&#13;
        regChange(cm, from.line, to.line + 1);&#13;
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)&#13;
        for (var i = from.line; i &lt;= to.line; i++) regLineChange(cm, i, "text");&#13;
      if (marker.atomic) reCheckSelection(cm.doc);&#13;
      signalLater(cm, "markerAdded", cm, marker);&#13;
    }&#13;
    return marker;&#13;
  }&#13;
&#13;
  // SHARED TEXTMARKERS&#13;
&#13;
  // A shared marker spans multiple linked documents. It is&#13;
  // implemented as a meta-marker-object controlling multiple normal&#13;
  // markers.&#13;
  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {&#13;
    this.markers = markers;&#13;
    this.primary = primary;&#13;
    for (var i = 0; i &lt; markers.length; ++i)&#13;
      markers[i].parent = this;&#13;
  };&#13;
  eventMixin(SharedTextMarker);&#13;
&#13;
  SharedTextMarker.prototype.clear = function() {&#13;
    if (this.explicitlyCleared) return;&#13;
    this.explicitlyCleared = true;&#13;
    for (var i = 0; i &lt; this.markers.length; ++i)&#13;
      this.markers[i].clear();&#13;
    signalLater(this, "clear");&#13;
  };&#13;
  SharedTextMarker.prototype.find = function(side, lineObj) {&#13;
    return this.primary.find(side, lineObj);&#13;
  };&#13;
&#13;
  function markTextShared(doc, from, to, options, type) {&#13;
    options = copyObj(options);&#13;
    options.shared = false;&#13;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];&#13;
    var widget = options.widgetNode;&#13;
    linkedDocs(doc, function(doc) {&#13;
      if (widget) options.widgetNode = widget.cloneNode(true);&#13;
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));&#13;
      for (var i = 0; i &lt; doc.linked.length; ++i)&#13;
        if (doc.linked[i].isParent) return;&#13;
      primary = lst(markers);&#13;
    });&#13;
    return new SharedTextMarker(markers, primary);&#13;
  }&#13;
&#13;
  function findSharedMarkers(doc) {&#13;
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),&#13;
                         function(m) { return m.parent; });&#13;
  }&#13;
&#13;
  function copySharedMarkers(doc, markers) {&#13;
    for (var i = 0; i &lt; markers.length; i++) {&#13;
      var marker = markers[i], pos = marker.find();&#13;
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);&#13;
      if (cmp(mFrom, mTo)) {&#13;
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);&#13;
        marker.markers.push(subMark);&#13;
        subMark.parent = marker;&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function detachSharedMarkers(markers) {&#13;
    for (var i = 0; i &lt; markers.length; i++) {&#13;
      var marker = markers[i], linked = [marker.primary.doc];;&#13;
      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });&#13;
      for (var j = 0; j &lt; marker.markers.length; j++) {&#13;
        var subMarker = marker.markers[j];&#13;
        if (indexOf(linked, subMarker.doc) == -1) {&#13;
          subMarker.parent = null;&#13;
          marker.markers.splice(j--, 1);&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  // TEXTMARKER SPANS&#13;
&#13;
  function MarkedSpan(marker, from, to) {&#13;
    this.marker = marker;&#13;
    this.from = from; this.to = to;&#13;
  }&#13;
&#13;
  // Search an array of spans for a span matching the given marker.&#13;
  function getMarkedSpanFor(spans, marker) {&#13;
    if (spans) for (var i = 0; i &lt; spans.length; ++i) {&#13;
      var span = spans[i];&#13;
      if (span.marker == marker) return span;&#13;
    }&#13;
  }&#13;
  // Remove a span from an array, returning undefined if no spans are&#13;
  // left (we don't store arrays for lines without spans).&#13;
  function removeMarkedSpan(spans, span) {&#13;
    for (var r, i = 0; i &lt; spans.length; ++i)&#13;
      if (spans[i] != span) (r || (r = [])).push(spans[i]);&#13;
    return r;&#13;
  }&#13;
  // Add a span to a line.&#13;
  function addMarkedSpan(line, span) {&#13;
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];&#13;
    span.marker.attachLine(line);&#13;
  }&#13;
&#13;
  // Used for the algorithm that adjusts markers for a change in the&#13;
  // document. These functions cut an array of spans at a given&#13;
  // character position, returning an array of remaining chunks (or&#13;
  // undefined if nothing remains).&#13;
  function markedSpansBefore(old, startCh, isInsert) {&#13;
    if (old) for (var i = 0, nw; i &lt; old.length; ++i) {&#13;
      var span = old[i], marker = span.marker;&#13;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from &lt;= startCh : span.from &lt; startCh);&#13;
      if (startsBefore || span.from == startCh &amp;&amp; marker.type == "bookmark" &amp;&amp; (!isInsert || !span.marker.insertLeft)) {&#13;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to &gt;= startCh : span.to &gt; startCh);&#13;
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));&#13;
      }&#13;
    }&#13;
    return nw;&#13;
  }&#13;
  function markedSpansAfter(old, endCh, isInsert) {&#13;
    if (old) for (var i = 0, nw; i &lt; old.length; ++i) {&#13;
      var span = old[i], marker = span.marker;&#13;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to &gt;= endCh : span.to &gt; endCh);&#13;
      if (endsAfter || span.from == endCh &amp;&amp; marker.type == "bookmark" &amp;&amp; (!isInsert || span.marker.insertLeft)) {&#13;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from &lt;= endCh : span.from &lt; endCh);&#13;
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,&#13;
                                              span.to == null ? null : span.to - endCh));&#13;
      }&#13;
    }&#13;
    return nw;&#13;
  }&#13;
&#13;
  // Given a change object, compute the new set of marker spans that&#13;
  // cover the line in which the change took place. Removes spans&#13;
  // entirely within the change, reconnects spans belonging to the&#13;
  // same marker that appear on both sides of the change, and cuts off&#13;
  // spans partially within the change. Returns an array of span&#13;
  // arrays with one element for each line in (after) the change.&#13;
  function stretchSpansOverChange(doc, change) {&#13;
    if (change.full) return null;&#13;
    var oldFirst = isLine(doc, change.from.line) &amp;&amp; getLine(doc, change.from.line).markedSpans;&#13;
    var oldLast = isLine(doc, change.to.line) &amp;&amp; getLine(doc, change.to.line).markedSpans;&#13;
    if (!oldFirst &amp;&amp; !oldLast) return null;&#13;
&#13;
    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;&#13;
    // Get the spans that 'stick out' on both sides&#13;
    var first = markedSpansBefore(oldFirst, startCh, isInsert);&#13;
    var last = markedSpansAfter(oldLast, endCh, isInsert);&#13;
&#13;
    // Next, merge those two ends&#13;
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);&#13;
    if (first) {&#13;
      // Fix up .to properties of first&#13;
      for (var i = 0; i &lt; first.length; ++i) {&#13;
        var span = first[i];&#13;
        if (span.to == null) {&#13;
          var found = getMarkedSpanFor(last, span.marker);&#13;
          if (!found) span.to = startCh;&#13;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;&#13;
        }&#13;
      }&#13;
    }&#13;
    if (last) {&#13;
      // Fix up .from in last (or move them into first in case of sameLine)&#13;
      for (var i = 0; i &lt; last.length; ++i) {&#13;
        var span = last[i];&#13;
        if (span.to != null) span.to += offset;&#13;
        if (span.from == null) {&#13;
          var found = getMarkedSpanFor(first, span.marker);&#13;
          if (!found) {&#13;
            span.from = offset;&#13;
            if (sameLine) (first || (first = [])).push(span);&#13;
          }&#13;
        } else {&#13;
          span.from += offset;&#13;
          if (sameLine) (first || (first = [])).push(span);&#13;
        }&#13;
      }&#13;
    }&#13;
    // Make sure we didn't create any zero-length spans&#13;
    if (first) first = clearEmptySpans(first);&#13;
    if (last &amp;&amp; last != first) last = clearEmptySpans(last);&#13;
&#13;
    var newMarkers = [first];&#13;
    if (!sameLine) {&#13;
      // Fill gap with whole-line-spans&#13;
      var gap = change.text.length - 2, gapMarkers;&#13;
      if (gap &gt; 0 &amp;&amp; first)&#13;
        for (var i = 0; i &lt; first.length; ++i)&#13;
          if (first[i].to == null)&#13;
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));&#13;
      for (var i = 0; i &lt; gap; ++i)&#13;
        newMarkers.push(gapMarkers);&#13;
      newMarkers.push(last);&#13;
    }&#13;
    return newMarkers;&#13;
  }&#13;
&#13;
  // Remove spans that are empty and don't have a clearWhenEmpty&#13;
  // option of false.&#13;
  function clearEmptySpans(spans) {&#13;
    for (var i = 0; i &lt; spans.length; ++i) {&#13;
      var span = spans[i];&#13;
      if (span.from != null &amp;&amp; span.from == span.to &amp;&amp; span.marker.clearWhenEmpty !== false)&#13;
        spans.splice(i--, 1);&#13;
    }&#13;
    if (!spans.length) return null;&#13;
    return spans;&#13;
  }&#13;
&#13;
  // Used for un/re-doing changes from the history. Combines the&#13;
  // result of computing the existing spans with the set of spans that&#13;
  // existed in the history (so that deleting around a span and then&#13;
  // undoing brings back the span).&#13;
  function mergeOldSpans(doc, change) {&#13;
    var old = getOldSpans(doc, change);&#13;
    var stretched = stretchSpansOverChange(doc, change);&#13;
    if (!old) return stretched;&#13;
    if (!stretched) return old;&#13;
&#13;
    for (var i = 0; i &lt; old.length; ++i) {&#13;
      var oldCur = old[i], stretchCur = stretched[i];&#13;
      if (oldCur &amp;&amp; stretchCur) {&#13;
        spans: for (var j = 0; j &lt; stretchCur.length; ++j) {&#13;
          var span = stretchCur[j];&#13;
          for (var k = 0; k &lt; oldCur.length; ++k)&#13;
            if (oldCur[k].marker == span.marker) continue spans;&#13;
          oldCur.push(span);&#13;
        }&#13;
      } else if (stretchCur) {&#13;
        old[i] = stretchCur;&#13;
      }&#13;
    }&#13;
    return old;&#13;
  }&#13;
&#13;
  // Used to 'clip' out readOnly ranges when making a change.&#13;
  function removeReadOnlyRanges(doc, from, to) {&#13;
    var markers = null;&#13;
    doc.iter(from.line, to.line + 1, function(line) {&#13;
      if (line.markedSpans) for (var i = 0; i &lt; line.markedSpans.length; ++i) {&#13;
        var mark = line.markedSpans[i].marker;&#13;
        if (mark.readOnly &amp;&amp; (!markers || indexOf(markers, mark) == -1))&#13;
          (markers || (markers = [])).push(mark);&#13;
      }&#13;
    });&#13;
    if (!markers) return null;&#13;
    var parts = [{from: from, to: to}];&#13;
    for (var i = 0; i &lt; markers.length; ++i) {&#13;
      var mk = markers[i], m = mk.find(0);&#13;
      for (var j = 0; j &lt; parts.length; ++j) {&#13;
        var p = parts[j];&#13;
        if (cmp(p.to, m.from) &lt; 0 || cmp(p.from, m.to) &gt; 0) continue;&#13;
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);&#13;
        if (dfrom &lt; 0 || !mk.inclusiveLeft &amp;&amp; !dfrom)&#13;
          newParts.push({from: p.from, to: m.from});&#13;
        if (dto &gt; 0 || !mk.inclusiveRight &amp;&amp; !dto)&#13;
          newParts.push({from: m.to, to: p.to});&#13;
        parts.splice.apply(parts, newParts);&#13;
        j += newParts.length - 1;&#13;
      }&#13;
    }&#13;
    return parts;&#13;
  }&#13;
&#13;
  // Connect or disconnect spans from a line.&#13;
  function detachMarkedSpans(line) {&#13;
    var spans = line.markedSpans;&#13;
    if (!spans) return;&#13;
    for (var i = 0; i &lt; spans.length; ++i)&#13;
      spans[i].marker.detachLine(line);&#13;
    line.markedSpans = null;&#13;
  }&#13;
  function attachMarkedSpans(line, spans) {&#13;
    if (!spans) return;&#13;
    for (var i = 0; i &lt; spans.length; ++i)&#13;
      spans[i].marker.attachLine(line);&#13;
    line.markedSpans = spans;&#13;
  }&#13;
&#13;
  // Helpers used when computing which overlapping collapsed span&#13;
  // counts as the larger one.&#13;
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }&#13;
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }&#13;
&#13;
  // Returns a number indicating which of two overlapping collapsed&#13;
  // spans is larger (and thus includes the other). Falls back to&#13;
  // comparing ids when the spans cover exactly the same range.&#13;
  function compareCollapsedMarkers(a, b) {&#13;
    var lenDiff = a.lines.length - b.lines.length;&#13;
    if (lenDiff != 0) return lenDiff;&#13;
    var aPos = a.find(), bPos = b.find();&#13;
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);&#13;
    if (fromCmp) return -fromCmp;&#13;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);&#13;
    if (toCmp) return toCmp;&#13;
    return b.id - a.id;&#13;
  }&#13;
&#13;
  // Find out whether a line ends or starts in a collapsed span. If&#13;
  // so, return the marker for that span.&#13;
  function collapsedSpanAtSide(line, start) {&#13;
    var sps = sawCollapsedSpans &amp;&amp; line.markedSpans, found;&#13;
    if (sps) for (var sp, i = 0; i &lt; sps.length; ++i) {&#13;
      sp = sps[i];&#13;
      if (sp.marker.collapsed &amp;&amp; (start ? sp.from : sp.to) == null &amp;&amp;&#13;
          (!found || compareCollapsedMarkers(found, sp.marker) &lt; 0))&#13;
        found = sp.marker;&#13;
    }&#13;
    return found;&#13;
  }&#13;
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }&#13;
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }&#13;
&#13;
  // Test whether there exists a collapsed span that partially&#13;
  // overlaps (covers the start or end, but not both) of a new span.&#13;
  // Such overlap is not allowed.&#13;
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {&#13;
    var line = getLine(doc, lineNo);&#13;
    var sps = sawCollapsedSpans &amp;&amp; line.markedSpans;&#13;
    if (sps) for (var i = 0; i &lt; sps.length; ++i) {&#13;
      var sp = sps[i];&#13;
      if (!sp.marker.collapsed) continue;&#13;
      var found = sp.marker.find(0);&#13;
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);&#13;
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);&#13;
      if (fromCmp &gt;= 0 &amp;&amp; toCmp &lt;= 0 || fromCmp &lt;= 0 &amp;&amp; toCmp &gt;= 0) continue;&#13;
      if (fromCmp &lt;= 0 &amp;&amp; (sp.marker.inclusiveRight &amp;&amp; marker.inclusiveLeft ? cmp(found.to, from) &gt;= 0 : cmp(found.to, from) &gt; 0) ||&#13;
          fromCmp &gt;= 0 &amp;&amp; (sp.marker.inclusiveRight &amp;&amp; marker.inclusiveLeft ? cmp(found.from, to) &lt;= 0 : cmp(found.from, to) &lt; 0))&#13;
        return true;&#13;
    }&#13;
  }&#13;
&#13;
  // A visual line is a line as drawn on the screen. Folding, for&#13;
  // example, can cause multiple logical lines to appear on the same&#13;
  // visual line. This finds the start of the visual line that the&#13;
  // given line is part of (usually that is the line itself).&#13;
  function visualLine(line) {&#13;
    var merged;&#13;
    while (merged = collapsedSpanAtStart(line))&#13;
      line = merged.find(-1, true).line;&#13;
    return line;&#13;
  }&#13;
&#13;
  // Returns an array of logical lines that continue the visual line&#13;
  // started by the argument, or undefined if there are no such lines.&#13;
  function visualLineContinued(line) {&#13;
    var merged, lines;&#13;
    while (merged = collapsedSpanAtEnd(line)) {&#13;
      line = merged.find(1, true).line;&#13;
      (lines || (lines = [])).push(line);&#13;
    }&#13;
    return lines;&#13;
  }&#13;
&#13;
  // Get the line number of the start of the visual line that the&#13;
  // given line number is part of.&#13;
  function visualLineNo(doc, lineN) {&#13;
    var line = getLine(doc, lineN), vis = visualLine(line);&#13;
    if (line == vis) return lineN;&#13;
    return lineNo(vis);&#13;
  }&#13;
  // Get the line number of the start of the next visual line after&#13;
  // the given line.&#13;
  function visualLineEndNo(doc, lineN) {&#13;
    if (lineN &gt; doc.lastLine()) return lineN;&#13;
    var line = getLine(doc, lineN), merged;&#13;
    if (!lineIsHidden(doc, line)) return lineN;&#13;
    while (merged = collapsedSpanAtEnd(line))&#13;
      line = merged.find(1, true).line;&#13;
    return lineNo(line) + 1;&#13;
  }&#13;
&#13;
  // Compute whether a line is hidden. Lines count as hidden when they&#13;
  // are part of a visual line that starts with another line, or when&#13;
  // they are entirely covered by collapsed, non-widget span.&#13;
  function lineIsHidden(doc, line) {&#13;
    var sps = sawCollapsedSpans &amp;&amp; line.markedSpans;&#13;
    if (sps) for (var sp, i = 0; i &lt; sps.length; ++i) {&#13;
      sp = sps[i];&#13;
      if (!sp.marker.collapsed) continue;&#13;
      if (sp.from == null) return true;&#13;
      if (sp.marker.widgetNode) continue;&#13;
      if (sp.from == 0 &amp;&amp; sp.marker.inclusiveLeft &amp;&amp; lineIsHiddenInner(doc, line, sp))&#13;
        return true;&#13;
    }&#13;
  }&#13;
  function lineIsHiddenInner(doc, line, span) {&#13;
    if (span.to == null) {&#13;
      var end = span.marker.find(1, true);&#13;
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));&#13;
    }&#13;
    if (span.marker.inclusiveRight &amp;&amp; span.to == line.text.length)&#13;
      return true;&#13;
    for (var sp, i = 0; i &lt; line.markedSpans.length; ++i) {&#13;
      sp = line.markedSpans[i];&#13;
      if (sp.marker.collapsed &amp;&amp; !sp.marker.widgetNode &amp;&amp; sp.from == span.to &amp;&amp;&#13;
          (sp.to == null || sp.to != span.from) &amp;&amp;&#13;
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &amp;&amp;&#13;
          lineIsHiddenInner(doc, line, sp)) return true;&#13;
    }&#13;
  }&#13;
&#13;
  // LINE WIDGETS&#13;
&#13;
  // Line widgets are block elements displayed above or below a line.&#13;
&#13;
  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {&#13;
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))&#13;
      this[opt] = options[opt];&#13;
    this.doc = doc;&#13;
    this.node = node;&#13;
  };&#13;
  eventMixin(LineWidget);&#13;
&#13;
  function adjustScrollWhenAboveVisible(cm, line, diff) {&#13;
    if (heightAtLine(line) &lt; ((cm.curOp &amp;&amp; cm.curOp.scrollTop) || cm.doc.scrollTop))&#13;
      addToScrollPos(cm, null, diff);&#13;
  }&#13;
&#13;
  LineWidget.prototype.clear = function() {&#13;
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);&#13;
    if (no == null || !ws) return;&#13;
    for (var i = 0; i &lt; ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);&#13;
    if (!ws.length) line.widgets = null;&#13;
    var height = widgetHeight(this);&#13;
    updateLineHeight(line, Math.max(0, line.height - height));&#13;
    if (cm) runInOp(cm, function() {&#13;
      adjustScrollWhenAboveVisible(cm, line, -height);&#13;
      regLineChange(cm, no, "widget");&#13;
    });&#13;
  };&#13;
  LineWidget.prototype.changed = function() {&#13;
    var oldH = this.height, cm = this.doc.cm, line = this.line;&#13;
    this.height = null;&#13;
    var diff = widgetHeight(this) - oldH;&#13;
    if (!diff) return;&#13;
    updateLineHeight(line, line.height + diff);&#13;
    if (cm) runInOp(cm, function() {&#13;
      cm.curOp.forceUpdate = true;&#13;
      adjustScrollWhenAboveVisible(cm, line, diff);&#13;
    });&#13;
  };&#13;
&#13;
  function widgetHeight(widget) {&#13;
    if (widget.height != null) return widget.height;&#13;
    var cm = widget.doc.cm;&#13;
    if (!cm) return 0;&#13;
    if (!contains(document.body, widget.node)) {&#13;
      var parentStyle = "position: relative;";&#13;
      if (widget.coverGutter)&#13;
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";&#13;
      if (widget.noHScroll)&#13;
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";&#13;
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));&#13;
    }&#13;
    return widget.height = widget.node.parentNode.offsetHeight;&#13;
  }&#13;
&#13;
  function addLineWidget(doc, handle, node, options) {&#13;
    var widget = new LineWidget(doc, node, options);&#13;
    var cm = doc.cm;&#13;
    if (cm &amp;&amp; widget.noHScroll) cm.display.alignWidgets = true;&#13;
    changeLine(doc, handle, "widget", function(line) {&#13;
      var widgets = line.widgets || (line.widgets = []);&#13;
      if (widget.insertAt == null) widgets.push(widget);&#13;
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);&#13;
      widget.line = line;&#13;
      if (cm &amp;&amp; !lineIsHidden(doc, line)) {&#13;
        var aboveVisible = heightAtLine(line) &lt; doc.scrollTop;&#13;
        updateLineHeight(line, line.height + widgetHeight(widget));&#13;
        if (aboveVisible) addToScrollPos(cm, null, widget.height);&#13;
        cm.curOp.forceUpdate = true;&#13;
      }&#13;
      return true;&#13;
    });&#13;
    return widget;&#13;
  }&#13;
&#13;
  // LINE DATA STRUCTURE&#13;
&#13;
  // Line objects. These hold state related to a line, including&#13;
  // highlighting info (the styles array).&#13;
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {&#13;
    this.text = text;&#13;
    attachMarkedSpans(this, markedSpans);&#13;
    this.height = estimateHeight ? estimateHeight(this) : 1;&#13;
  };&#13;
  eventMixin(Line);&#13;
  Line.prototype.lineNo = function() { return lineNo(this); };&#13;
&#13;
  // Change the content (text, markers) of a line. Automatically&#13;
  // invalidates cached information and tries to re-estimate the&#13;
  // line's height.&#13;
  function updateLine(line, text, markedSpans, estimateHeight) {&#13;
    line.text = text;&#13;
    if (line.stateAfter) line.stateAfter = null;&#13;
    if (line.styles) line.styles = null;&#13;
    if (line.order != null) line.order = null;&#13;
    detachMarkedSpans(line);&#13;
    attachMarkedSpans(line, markedSpans);&#13;
    var estHeight = estimateHeight ? estimateHeight(line) : 1;&#13;
    if (estHeight != line.height) updateLineHeight(line, estHeight);&#13;
  }&#13;
&#13;
  // Detach a line from the document tree and its markers.&#13;
  function cleanUpLine(line) {&#13;
    line.parent = null;&#13;
    detachMarkedSpans(line);&#13;
  }&#13;
&#13;
  function extractLineClasses(type, output) {&#13;
    if (type) for (;;) {&#13;
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);&#13;
      if (!lineClass) break;&#13;
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);&#13;
      var prop = lineClass[1] ? "bgClass" : "textClass";&#13;
      if (output[prop] == null)&#13;
        output[prop] = lineClass[2];&#13;
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))&#13;
        output[prop] += " " + lineClass[2];&#13;
    }&#13;
    return type;&#13;
  }&#13;
&#13;
  function callBlankLine(mode, state) {&#13;
    if (mode.blankLine) return mode.blankLine(state);&#13;
    if (!mode.innerMode) return;&#13;
    var inner = CodeMirror.innerMode(mode, state);&#13;
    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);&#13;
  }&#13;
&#13;
  function readToken(mode, stream, state, inner) {&#13;
    for (var i = 0; i &lt; 10; i++) {&#13;
      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;&#13;
      var style = mode.token(stream, state);&#13;
      if (stream.pos &gt; stream.start) return style;&#13;
    }&#13;
    throw new Error("Mode " + mode.name + " failed to advance stream.");&#13;
  }&#13;
&#13;
  // Utility for getTokenAt and getLineTokens&#13;
  function takeToken(cm, pos, precise, asArray) {&#13;
    function getObj(copy) {&#13;
      return {start: stream.start, end: stream.pos,&#13;
              string: stream.current(),&#13;
              type: style || null,&#13;
              state: copy ? copyState(doc.mode, state) : state};&#13;
    }&#13;
&#13;
    var doc = cm.doc, mode = doc.mode, style;&#13;
    pos = clipPos(doc, pos);&#13;
    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);&#13;
    var stream = new StringStream(line.text, cm.options.tabSize), tokens;&#13;
    if (asArray) tokens = [];&#13;
    while ((asArray || stream.pos &lt; pos.ch) &amp;&amp; !stream.eol()) {&#13;
      stream.start = stream.pos;&#13;
      style = readToken(mode, stream, state);&#13;
      if (asArray) tokens.push(getObj(true));&#13;
    }&#13;
    return asArray ? tokens : getObj();&#13;
  }&#13;
&#13;
  // Run the given mode's parser over a line, calling f for each token.&#13;
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {&#13;
    var flattenSpans = mode.flattenSpans;&#13;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;&#13;
    var curStart = 0, curStyle = null;&#13;
    var stream = new StringStream(text, cm.options.tabSize), style;&#13;
    var inner = cm.options.addModeClass &amp;&amp; [null];&#13;
    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);&#13;
    while (!stream.eol()) {&#13;
      if (stream.pos &gt; cm.options.maxHighlightLength) {&#13;
        flattenSpans = false;&#13;
        if (forceToEnd) processLine(cm, text, state, stream.pos);&#13;
        stream.pos = text.length;&#13;
        style = null;&#13;
      } else {&#13;
        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);&#13;
      }&#13;
      if (inner) {&#13;
        var mName = inner[0].name;&#13;
        if (mName) style = "m-" + (style ? mName + " " + style : mName);&#13;
      }&#13;
      if (!flattenSpans || curStyle != style) {&#13;
        while (curStart &lt; stream.start) {&#13;
          curStart = Math.min(stream.start, curStart + 50000);&#13;
          f(curStart, curStyle);&#13;
        }&#13;
        curStyle = style;&#13;
      }&#13;
      stream.start = stream.pos;&#13;
    }&#13;
    while (curStart &lt; stream.pos) {&#13;
      // Webkit seems to refuse to render text nodes longer than 57444 characters&#13;
      var pos = Math.min(stream.pos, curStart + 50000);&#13;
      f(pos, curStyle);&#13;
      curStart = pos;&#13;
    }&#13;
  }&#13;
&#13;
  // Compute a style array (an array starting with a mode generation&#13;
  // -- for invalidation -- followed by pairs of end positions and&#13;
  // style strings), which is used to highlight the tokens on the&#13;
  // line.&#13;
  function highlightLine(cm, line, state, forceToEnd) {&#13;
    // A styles array always starts with a number identifying the&#13;
    // mode/overlays that it is based on (for easy invalidation).&#13;
    var st = [cm.state.modeGen], lineClasses = {};&#13;
    // Compute the base array of styles&#13;
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {&#13;
      st.push(end, style);&#13;
    }, lineClasses, forceToEnd);&#13;
&#13;
    // Run overlays, adjust style array.&#13;
    for (var o = 0; o &lt; cm.state.overlays.length; ++o) {&#13;
      var overlay = cm.state.overlays[o], i = 1, at = 0;&#13;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {&#13;
        var start = i;&#13;
        // Ensure there's a token end at the current position, and that i points at it&#13;
        while (at &lt; end) {&#13;
          var i_end = st[i];&#13;
          if (i_end &gt; end)&#13;
            st.splice(i, 1, end, st[i+1], i_end);&#13;
          i += 2;&#13;
          at = Math.min(end, i_end);&#13;
        }&#13;
        if (!style) return;&#13;
        if (overlay.opaque) {&#13;
          st.splice(start, i - start, end, "cm-overlay " + style);&#13;
          i = start + 2;&#13;
        } else {&#13;
          for (; start &lt; i; start += 2) {&#13;
            var cur = st[start+1];&#13;
            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;&#13;
          }&#13;
        }&#13;
      }, lineClasses);&#13;
    }&#13;
&#13;
    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};&#13;
  }&#13;
&#13;
  function getLineStyles(cm, line, updateFrontier) {&#13;
    if (!line.styles || line.styles[0] != cm.state.modeGen) {&#13;
      var state = getStateBefore(cm, lineNo(line));&#13;
      var result = highlightLine(cm, line, line.text.length &gt; cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);&#13;
      line.stateAfter = state;&#13;
      line.styles = result.styles;&#13;
      if (result.classes) line.styleClasses = result.classes;&#13;
      else if (line.styleClasses) line.styleClasses = null;&#13;
      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;&#13;
    }&#13;
    return line.styles;&#13;
  }&#13;
&#13;
  // Lightweight form of highlight -- proceed over this line and&#13;
  // update state, but don't save a style array. Used for lines that&#13;
  // aren't currently visible.&#13;
  function processLine(cm, text, state, startAt) {&#13;
    var mode = cm.doc.mode;&#13;
    var stream = new StringStream(text, cm.options.tabSize);&#13;
    stream.start = stream.pos = startAt || 0;&#13;
    if (text == "") callBlankLine(mode, state);&#13;
    while (!stream.eol()) {&#13;
      readToken(mode, stream, state);&#13;
      stream.start = stream.pos;&#13;
    }&#13;
  }&#13;
&#13;
  // Convert a style as returned by a mode (either null, or a string&#13;
  // containing one or more styles) to a CSS style. This is cached,&#13;
  // and also looks for line-wide styles.&#13;
  var styleToClassCache = {}, styleToClassCacheWithMode = {};&#13;
  function interpretTokenStyle(style, options) {&#13;
    if (!style || /^\s*$/.test(style)) return null;&#13;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;&#13;
    return cache[style] ||&#13;
      (cache[style] = style.replace(/\S+/g, "cm-$&amp;"));&#13;
  }&#13;
&#13;
  // Render the DOM representation of the text of a line. Also builds&#13;
  // up a 'line map', which points at the DOM nodes that represent&#13;
  // specific stretches of text, and is used by the measuring code.&#13;
  // The returned object contains the DOM node, this map, and&#13;
  // information about line-wide styles that were set by the mode.&#13;
  function buildLineContent(cm, lineView) {&#13;
    // The padding-right forces the element to have a 'border', which&#13;
    // is needed on Webkit to be able to get line-level bounding&#13;
    // rectangles for it (in measureChar).&#13;
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);&#13;
    var builder = {pre: elt("pre", [content], "CodeMirror-line"), content: content,&#13;
                   col: 0, pos: 0, cm: cm,&#13;
                   splitSpaces: (ie || webkit) &amp;&amp; cm.getOption("lineWrapping")};&#13;
    lineView.measure = {};&#13;
&#13;
    // Iterate over the logical lines that make up this visual line.&#13;
    for (var i = 0; i &lt;= (lineView.rest ? lineView.rest.length : 0); i++) {&#13;
      var line = i ? lineView.rest[i - 1] : lineView.line, order;&#13;
      builder.pos = 0;&#13;
      builder.addToken = buildToken;&#13;
      // Optionally wire in some hacks into the token-rendering&#13;
      // algorithm, to deal with browser quirks.&#13;
      if (hasBadBidiRects(cm.display.measure) &amp;&amp; (order = getOrder(line)))&#13;
        builder.addToken = buildTokenBadBidi(builder.addToken, order);&#13;
      builder.map = [];&#13;
      var allowFrontierUpdate = lineView != cm.display.externalMeasured &amp;&amp; lineNo(line);&#13;
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));&#13;
      if (line.styleClasses) {&#13;
        if (line.styleClasses.bgClass)&#13;
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");&#13;
        if (line.styleClasses.textClass)&#13;
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");&#13;
      }&#13;
&#13;
      // Ensure at least a single node is present, for measuring.&#13;
      if (builder.map.length == 0)&#13;
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));&#13;
&#13;
      // Store the map and a cache object for the current logical line&#13;
      if (i == 0) {&#13;
        lineView.measure.map = builder.map;&#13;
        lineView.measure.cache = {};&#13;
      } else {&#13;
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);&#13;
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});&#13;
      }&#13;
    }&#13;
&#13;
    // See issue #2901&#13;
    if (webkit) {&#13;
      var last = builder.content.lastChild&#13;
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector &amp;&amp; last.querySelector(".cm-tab")))&#13;
        builder.content.className = "cm-tab-wrap-hack";&#13;
    }&#13;
&#13;
    signal(cm, "renderLine", cm, lineView.line, builder.pre);&#13;
    if (builder.pre.className)&#13;
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");&#13;
&#13;
    return builder;&#13;
  }&#13;
&#13;
  function defaultSpecialCharPlaceholder(ch) {&#13;
    var token = elt("span", "\u2022", "cm-invalidchar");&#13;
    token.title = "\\u" + ch.charCodeAt(0).toString(16);&#13;
    token.setAttribute("aria-label", token.title);&#13;
    return token;&#13;
  }&#13;
&#13;
  // Build up the DOM representation for a single token, and add it to&#13;
  // the line map. Takes care to render special characters separately.&#13;
  function buildToken(builder, text, style, startStyle, endStyle, title, css) {&#13;
    if (!text) return;&#13;
    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;&#13;
    var special = builder.cm.state.specialChars, mustWrap = false;&#13;
    if (!special.test(text)) {&#13;
      builder.col += text.length;&#13;
      var content = document.createTextNode(displayText);&#13;
      builder.map.push(builder.pos, builder.pos + text.length, content);&#13;
      if (ie &amp;&amp; ie_version &lt; 9) mustWrap = true;&#13;
      builder.pos += text.length;&#13;
    } else {&#13;
      var content = document.createDocumentFragment(), pos = 0;&#13;
      while (true) {&#13;
        special.lastIndex = pos;&#13;
        var m = special.exec(text);&#13;
        var skipped = m ? m.index - pos : text.length - pos;&#13;
        if (skipped) {&#13;
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));&#13;
          if (ie &amp;&amp; ie_version &lt; 9) content.appendChild(elt("span", [txt]));&#13;
          else content.appendChild(txt);&#13;
          builder.map.push(builder.pos, builder.pos + skipped, txt);&#13;
          builder.col += skipped;&#13;
          builder.pos += skipped;&#13;
        }&#13;
        if (!m) break;&#13;
        pos += skipped + 1;&#13;
        if (m[0] == "\t") {&#13;
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;&#13;
          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));&#13;
          txt.setAttribute("role", "presentation");&#13;
          txt.setAttribute("cm-text", "\t");&#13;
          builder.col += tabWidth;&#13;
        } else if (m[0] == "\r" || m[0] == "\n") {&#13;
          var txt = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));&#13;
          txt.setAttribute("cm-text", m[0]);&#13;
          builder.col += 1;&#13;
        } else {&#13;
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);&#13;
          txt.setAttribute("cm-text", m[0]);&#13;
          if (ie &amp;&amp; ie_version &lt; 9) content.appendChild(elt("span", [txt]));&#13;
          else content.appendChild(txt);&#13;
          builder.col += 1;&#13;
        }&#13;
        builder.map.push(builder.pos, builder.pos + 1, txt);&#13;
        builder.pos++;&#13;
      }&#13;
    }&#13;
    if (style || startStyle || endStyle || mustWrap || css) {&#13;
      var fullStyle = style || "";&#13;
      if (startStyle) fullStyle += startStyle;&#13;
      if (endStyle) fullStyle += endStyle;&#13;
      var token = elt("span", [content], fullStyle, css);&#13;
      if (title) token.title = title;&#13;
      return builder.content.appendChild(token);&#13;
    }&#13;
    builder.content.appendChild(content);&#13;
  }&#13;
&#13;
  function splitSpaces(old) {&#13;
    var out = " ";&#13;
    for (var i = 0; i &lt; old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";&#13;
    out += " ";&#13;
    return out;&#13;
  }&#13;
&#13;
  // Work around nonsense dimensions being reported for stretches of&#13;
  // right-to-left text.&#13;
  function buildTokenBadBidi(inner, order) {&#13;
    return function(builder, text, style, startStyle, endStyle, title, css) {&#13;
      style = style ? style + " cm-force-border" : "cm-force-border";&#13;
      var start = builder.pos, end = start + text.length;&#13;
      for (;;) {&#13;
        // Find the part that overlaps with the start of this text&#13;
        for (var i = 0; i &lt; order.length; i++) {&#13;
          var part = order[i];&#13;
          if (part.to &gt; start &amp;&amp; part.from &lt;= start) break;&#13;
        }&#13;
        if (part.to &gt;= end) return inner(builder, text, style, startStyle, endStyle, title, css);&#13;
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);&#13;
        startStyle = null;&#13;
        text = text.slice(part.to - start);&#13;
        start = part.to;&#13;
      }&#13;
    };&#13;
  }&#13;
&#13;
  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {&#13;
    var widget = !ignoreWidget &amp;&amp; marker.widgetNode;&#13;
    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);&#13;
    if (!ignoreWidget &amp;&amp; builder.cm.display.input.needsContentAttribute) {&#13;
      if (!widget)&#13;
        widget = builder.content.appendChild(document.createElement("span"));&#13;
      widget.setAttribute("cm-marker", marker.id);&#13;
    }&#13;
    if (widget) {&#13;
      builder.cm.display.input.setUneditable(widget);&#13;
      builder.content.appendChild(widget);&#13;
    }&#13;
    builder.pos += size;&#13;
  }&#13;
&#13;
  // Outputs a number of spans to make up a line, taking highlighting&#13;
  // and marked text into account.&#13;
  function insertLineContent(line, builder, styles) {&#13;
    var spans = line.markedSpans, allText = line.text, at = 0;&#13;
    if (!spans) {&#13;
      for (var i = 1; i &lt; styles.length; i+=2)&#13;
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));&#13;
      return;&#13;
    }&#13;
&#13;
    var len = allText.length, pos = 0, i = 1, text = "", style, css;&#13;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;&#13;
    for (;;) {&#13;
      if (nextChange == pos) { // Update current marker set&#13;
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";&#13;
        collapsed = null; nextChange = Infinity;&#13;
        var foundBookmarks = [], endStyles&#13;
        for (var j = 0; j &lt; spans.length; ++j) {&#13;
          var sp = spans[j], m = sp.marker;&#13;
          if (m.type == "bookmark" &amp;&amp; sp.from == pos &amp;&amp; m.widgetNode) {&#13;
            foundBookmarks.push(m);&#13;
          } else if (sp.from &lt;= pos &amp;&amp; (sp.to == null || sp.to &gt; pos || m.collapsed &amp;&amp; sp.to == pos &amp;&amp; sp.from == pos)) {&#13;
            if (sp.to != null &amp;&amp; sp.to != pos &amp;&amp; nextChange &gt; sp.to) {&#13;
              nextChange = sp.to;&#13;
              spanEndStyle = "";&#13;
            }&#13;
            if (m.className) spanStyle += " " + m.className;&#13;
            if (m.css) css = (css ? css + ";" : "") + m.css;&#13;
            if (m.startStyle &amp;&amp; sp.from == pos) spanStartStyle += " " + m.startStyle;&#13;
            if (m.endStyle &amp;&amp; sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)&#13;
            if (m.title &amp;&amp; !title) title = m.title;&#13;
            if (m.collapsed &amp;&amp; (!collapsed || compareCollapsedMarkers(collapsed.marker, m) &lt; 0))&#13;
              collapsed = sp;&#13;
          } else if (sp.from &gt; pos &amp;&amp; nextChange &gt; sp.from) {&#13;
            nextChange = sp.from;&#13;
          }&#13;
        }&#13;
        if (endStyles) for (var j = 0; j &lt; endStyles.length; j += 2)&#13;
          if (endStyles[j + 1] == nextChange) spanEndStyle += " " + endStyles[j]&#13;
&#13;
        if (!collapsed || collapsed.from == pos) for (var j = 0; j &lt; foundBookmarks.length; ++j)&#13;
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);&#13;
        if (collapsed &amp;&amp; (collapsed.from || 0) == pos) {&#13;
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,&#13;
                             collapsed.marker, collapsed.from == null);&#13;
          if (collapsed.to == null) return;&#13;
          if (collapsed.to == pos) collapsed = false;&#13;
        }&#13;
      }&#13;
      if (pos &gt;= len) break;&#13;
&#13;
      var upto = Math.min(len, nextChange);&#13;
      while (true) {&#13;
        if (text) {&#13;
          var end = pos + text.length;&#13;
          if (!collapsed) {&#13;
            var tokenText = end &gt; upto ? text.slice(0, upto - pos) : text;&#13;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,&#13;
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);&#13;
          }&#13;
          if (end &gt;= upto) {text = text.slice(upto - pos); pos = upto; break;}&#13;
          pos = end;&#13;
          spanStartStyle = "";&#13;
        }&#13;
        text = allText.slice(at, at = styles[i++]);&#13;
        style = interpretTokenStyle(styles[i++], builder.cm.options);&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  // DOCUMENT DATA STRUCTURE&#13;
&#13;
  // By default, updates that start and end at the beginning of a line&#13;
  // are treated specially, in order to make the association of line&#13;
  // widgets and marker elements with the text behave more intuitive.&#13;
  function isWholeLineUpdate(doc, change) {&#13;
    return change.from.ch == 0 &amp;&amp; change.to.ch == 0 &amp;&amp; lst(change.text) == "" &amp;&amp;&#13;
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);&#13;
  }&#13;
&#13;
  // Perform a change on the document data structure.&#13;
  function updateDoc(doc, change, markedSpans, estimateHeight) {&#13;
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}&#13;
    function update(line, text, spans) {&#13;
      updateLine(line, text, spans, estimateHeight);&#13;
      signalLater(line, "change", line, change);&#13;
    }&#13;
    function linesFor(start, end) {&#13;
      for (var i = start, result = []; i &lt; end; ++i)&#13;
        result.push(new Line(text[i], spansFor(i), estimateHeight));&#13;
      return result;&#13;
    }&#13;
&#13;
    var from = change.from, to = change.to, text = change.text;&#13;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);&#13;
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;&#13;
&#13;
    // Adjust the line structure&#13;
    if (change.full) {&#13;
      doc.insert(0, linesFor(0, text.length));&#13;
      doc.remove(text.length, doc.size - text.length);&#13;
    } else if (isWholeLineUpdate(doc, change)) {&#13;
      // This is a whole-line replace. Treated specially to make&#13;
      // sure line objects move the way they are supposed to.&#13;
      var added = linesFor(0, text.length - 1);&#13;
      update(lastLine, lastLine.text, lastSpans);&#13;
      if (nlines) doc.remove(from.line, nlines);&#13;
      if (added.length) doc.insert(from.line, added);&#13;
    } else if (firstLine == lastLine) {&#13;
      if (text.length == 1) {&#13;
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);&#13;
      } else {&#13;
        var added = linesFor(1, text.length - 1);&#13;
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));&#13;
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));&#13;
        doc.insert(from.line + 1, added);&#13;
      }&#13;
    } else if (text.length == 1) {&#13;
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));&#13;
      doc.remove(from.line + 1, nlines);&#13;
    } else {&#13;
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));&#13;
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);&#13;
      var added = linesFor(1, text.length - 1);&#13;
      if (nlines &gt; 1) doc.remove(from.line + 1, nlines - 1);&#13;
      doc.insert(from.line + 1, added);&#13;
    }&#13;
&#13;
    signalLater(doc, "change", doc, change);&#13;
  }&#13;
&#13;
  // The document is represented as a BTree consisting of leaves, with&#13;
  // chunk of lines in them, and branches, with up to ten leaves or&#13;
  // other branch nodes below them. The top node is always a branch&#13;
  // node, and is the document object itself (meaning it has&#13;
  // additional methods and properties).&#13;
  //&#13;
  // All nodes have parent links. The tree is used both to go from&#13;
  // line numbers to line objects, and to go from objects to numbers.&#13;
  // It also indexes by height, and is used to convert between height&#13;
  // and line object, and to find the total height of the document.&#13;
  //&#13;
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html&#13;
&#13;
  function LeafChunk(lines) {&#13;
    this.lines = lines;&#13;
    this.parent = null;&#13;
    for (var i = 0, height = 0; i &lt; lines.length; ++i) {&#13;
      lines[i].parent = this;&#13;
      height += lines[i].height;&#13;
    }&#13;
    this.height = height;&#13;
  }&#13;
&#13;
  LeafChunk.prototype = {&#13;
    chunkSize: function() { return this.lines.length; },&#13;
    // Remove the n lines at offset 'at'.&#13;
    removeInner: function(at, n) {&#13;
      for (var i = at, e = at + n; i &lt; e; ++i) {&#13;
        var line = this.lines[i];&#13;
        this.height -= line.height;&#13;
        cleanUpLine(line);&#13;
        signalLater(line, "delete");&#13;
      }&#13;
      this.lines.splice(at, n);&#13;
    },&#13;
    // Helper used to collapse a small branch into a single leaf.&#13;
    collapse: function(lines) {&#13;
      lines.push.apply(lines, this.lines);&#13;
    },&#13;
    // Insert the given array of lines at offset 'at', count them as&#13;
    // having the given height.&#13;
    insertInner: function(at, lines, height) {&#13;
      this.height += height;&#13;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));&#13;
      for (var i = 0; i &lt; lines.length; ++i) lines[i].parent = this;&#13;
    },&#13;
    // Used to iterate over a part of the tree.&#13;
    iterN: function(at, n, op) {&#13;
      for (var e = at + n; at &lt; e; ++at)&#13;
        if (op(this.lines[at])) return true;&#13;
    }&#13;
  };&#13;
&#13;
  function BranchChunk(children) {&#13;
    this.children = children;&#13;
    var size = 0, height = 0;&#13;
    for (var i = 0; i &lt; children.length; ++i) {&#13;
      var ch = children[i];&#13;
      size += ch.chunkSize(); height += ch.height;&#13;
      ch.parent = this;&#13;
    }&#13;
    this.size = size;&#13;
    this.height = height;&#13;
    this.parent = null;&#13;
  }&#13;
&#13;
  BranchChunk.prototype = {&#13;
    chunkSize: function() { return this.size; },&#13;
    removeInner: function(at, n) {&#13;
      this.size -= n;&#13;
      for (var i = 0; i &lt; this.children.length; ++i) {&#13;
        var child = this.children[i], sz = child.chunkSize();&#13;
        if (at &lt; sz) {&#13;
          var rm = Math.min(n, sz - at), oldHeight = child.height;&#13;
          child.removeInner(at, rm);&#13;
          this.height -= oldHeight - child.height;&#13;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }&#13;
          if ((n -= rm) == 0) break;&#13;
          at = 0;&#13;
        } else at -= sz;&#13;
      }&#13;
      // If the result is smaller than 25 lines, ensure that it is a&#13;
      // single leaf node.&#13;
      if (this.size - n &lt; 25 &amp;&amp;&#13;
          (this.children.length &gt; 1 || !(this.children[0] instanceof LeafChunk))) {&#13;
        var lines = [];&#13;
        this.collapse(lines);&#13;
        this.children = [new LeafChunk(lines)];&#13;
        this.children[0].parent = this;&#13;
      }&#13;
    },&#13;
    collapse: function(lines) {&#13;
      for (var i = 0; i &lt; this.children.length; ++i) this.children[i].collapse(lines);&#13;
    },&#13;
    insertInner: function(at, lines, height) {&#13;
      this.size += lines.length;&#13;
      this.height += height;&#13;
      for (var i = 0; i &lt; this.children.length; ++i) {&#13;
        var child = this.children[i], sz = child.chunkSize();&#13;
        if (at &lt;= sz) {&#13;
          child.insertInner(at, lines, height);&#13;
          if (child.lines &amp;&amp; child.lines.length &gt; 50) {&#13;
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.&#13;
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.&#13;
            var remaining = child.lines.length % 25 + 25&#13;
            for (var pos = remaining; pos &lt; child.lines.length;) {&#13;
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));&#13;
              child.height -= leaf.height;&#13;
              this.children.splice(++i, 0, leaf);&#13;
              leaf.parent = this;&#13;
            }&#13;
            child.lines = child.lines.slice(0, remaining);&#13;
            this.maybeSpill();&#13;
          }&#13;
          break;&#13;
        }&#13;
        at -= sz;&#13;
      }&#13;
    },&#13;
    // When a node has grown, check whether it should be split.&#13;
    maybeSpill: function() {&#13;
      if (this.children.length &lt;= 10) return;&#13;
      var me = this;&#13;
      do {&#13;
        var spilled = me.children.splice(me.children.length - 5, 5);&#13;
        var sibling = new BranchChunk(spilled);&#13;
        if (!me.parent) { // Become the parent node&#13;
          var copy = new BranchChunk(me.children);&#13;
          copy.parent = me;&#13;
          me.children = [copy, sibling];&#13;
          me = copy;&#13;
       } else {&#13;
          me.size -= sibling.size;&#13;
          me.height -= sibling.height;&#13;
          var myIndex = indexOf(me.parent.children, me);&#13;
          me.parent.children.splice(myIndex + 1, 0, sibling);&#13;
        }&#13;
        sibling.parent = me.parent;&#13;
      } while (me.children.length &gt; 10);&#13;
      me.parent.maybeSpill();&#13;
    },&#13;
    iterN: function(at, n, op) {&#13;
      for (var i = 0; i &lt; this.children.length; ++i) {&#13;
        var child = this.children[i], sz = child.chunkSize();&#13;
        if (at &lt; sz) {&#13;
          var used = Math.min(n, sz - at);&#13;
          if (child.iterN(at, used, op)) return true;&#13;
          if ((n -= used) == 0) break;&#13;
          at = 0;&#13;
        } else at -= sz;&#13;
      }&#13;
    }&#13;
  };&#13;
&#13;
  var nextDocId = 0;&#13;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {&#13;
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);&#13;
    if (firstLine == null) firstLine = 0;&#13;
&#13;
    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);&#13;
    this.first = firstLine;&#13;
    this.scrollTop = this.scrollLeft = 0;&#13;
    this.cantEdit = false;&#13;
    this.cleanGeneration = 1;&#13;
    this.frontier = firstLine;&#13;
    var start = Pos(firstLine, 0);&#13;
    this.sel = simpleSelection(start);&#13;
    this.history = new History(null);&#13;
    this.id = ++nextDocId;&#13;
    this.modeOption = mode;&#13;
    this.lineSep = lineSep;&#13;
    this.extend = false;&#13;
&#13;
    if (typeof text == "string") text = this.splitLines(text);&#13;
    updateDoc(this, {from: start, to: start, text: text});&#13;
    setSelection(this, simpleSelection(start), sel_dontScroll);&#13;
  };&#13;
&#13;
  Doc.prototype = createObj(BranchChunk.prototype, {&#13;
    constructor: Doc,&#13;
    // Iterate over the document. Supports two forms -- with only one&#13;
    // argument, it calls that for each line in the document. With&#13;
    // three, it iterates over the range given by the first two (with&#13;
    // the second being non-inclusive).&#13;
    iter: function(from, to, op) {&#13;
      if (op) this.iterN(from - this.first, to - from, op);&#13;
      else this.iterN(this.first, this.first + this.size, from);&#13;
    },&#13;
&#13;
    // Non-public interface for adding and removing lines.&#13;
    insert: function(at, lines) {&#13;
      var height = 0;&#13;
      for (var i = 0; i &lt; lines.length; ++i) height += lines[i].height;&#13;
      this.insertInner(at - this.first, lines, height);&#13;
    },&#13;
    remove: function(at, n) { this.removeInner(at - this.first, n); },&#13;
&#13;
    // From here, the methods are part of the public interface. Most&#13;
    // are also available from CodeMirror (editor) instances.&#13;
&#13;
    getValue: function(lineSep) {&#13;
      var lines = getLines(this, this.first, this.first + this.size);&#13;
      if (lineSep === false) return lines;&#13;
      return lines.join(lineSep || this.lineSeparator());&#13;
    },&#13;
    setValue: docMethodOp(function(code) {&#13;
      var top = Pos(this.first, 0), last = this.first + this.size - 1;&#13;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),&#13;
                        text: this.splitLines(code), origin: "setValue", full: true}, true);&#13;
      setSelection(this, simpleSelection(top));&#13;
    }),&#13;
    replaceRange: function(code, from, to, origin) {&#13;
      from = clipPos(this, from);&#13;
      to = to ? clipPos(this, to) : from;&#13;
      replaceRange(this, code, from, to, origin);&#13;
    },&#13;
    getRange: function(from, to, lineSep) {&#13;
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));&#13;
      if (lineSep === false) return lines;&#13;
      return lines.join(lineSep || this.lineSeparator());&#13;
    },&#13;
&#13;
    getLine: function(line) {var l = this.getLineHandle(line); return l &amp;&amp; l.text;},&#13;
&#13;
    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},&#13;
    getLineNumber: function(line) {return lineNo(line);},&#13;
&#13;
    getLineHandleVisualStart: function(line) {&#13;
      if (typeof line == "number") line = getLine(this, line);&#13;
      return visualLine(line);&#13;
    },&#13;
&#13;
    lineCount: function() {return this.size;},&#13;
    firstLine: function() {return this.first;},&#13;
    lastLine: function() {return this.first + this.size - 1;},&#13;
&#13;
    clipPos: function(pos) {return clipPos(this, pos);},&#13;
&#13;
    getCursor: function(start) {&#13;
      var range = this.sel.primary(), pos;&#13;
      if (start == null || start == "head") pos = range.head;&#13;
      else if (start == "anchor") pos = range.anchor;&#13;
      else if (start == "end" || start == "to" || start === false) pos = range.to();&#13;
      else pos = range.from();&#13;
      return pos;&#13;
    },&#13;
    listSelections: function() { return this.sel.ranges; },&#13;
    somethingSelected: function() {return this.sel.somethingSelected();},&#13;
&#13;
    setCursor: docMethodOp(function(line, ch, options) {&#13;
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);&#13;
    }),&#13;
    setSelection: docMethodOp(function(anchor, head, options) {&#13;
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);&#13;
    }),&#13;
    extendSelection: docMethodOp(function(head, other, options) {&#13;
      extendSelection(this, clipPos(this, head), other &amp;&amp; clipPos(this, other), options);&#13;
    }),&#13;
    extendSelections: docMethodOp(function(heads, options) {&#13;
      extendSelections(this, clipPosArray(this, heads), options);&#13;
    }),&#13;
    extendSelectionsBy: docMethodOp(function(f, options) {&#13;
      var heads = map(this.sel.ranges, f);&#13;
      extendSelections(this, clipPosArray(this, heads), options);&#13;
    }),&#13;
    setSelections: docMethodOp(function(ranges, primary, options) {&#13;
      if (!ranges.length) return;&#13;
      for (var i = 0, out = []; i &lt; ranges.length; i++)&#13;
        out[i] = new Range(clipPos(this, ranges[i].anchor),&#13;
                           clipPos(this, ranges[i].head));&#13;
      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);&#13;
      setSelection(this, normalizeSelection(out, primary), options);&#13;
    }),&#13;
    addSelection: docMethodOp(function(anchor, head, options) {&#13;
      var ranges = this.sel.ranges.slice(0);&#13;
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));&#13;
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);&#13;
    }),&#13;
&#13;
    getSelection: function(lineSep) {&#13;
      var ranges = this.sel.ranges, lines;&#13;
      for (var i = 0; i &lt; ranges.length; i++) {&#13;
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());&#13;
        lines = lines ? lines.concat(sel) : sel;&#13;
      }&#13;
      if (lineSep === false) return lines;&#13;
      else return lines.join(lineSep || this.lineSeparator());&#13;
    },&#13;
    getSelections: function(lineSep) {&#13;
      var parts = [], ranges = this.sel.ranges;&#13;
      for (var i = 0; i &lt; ranges.length; i++) {&#13;
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());&#13;
        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());&#13;
        parts[i] = sel;&#13;
      }&#13;
      return parts;&#13;
    },&#13;
    replaceSelection: function(code, collapse, origin) {&#13;
      var dup = [];&#13;
      for (var i = 0; i &lt; this.sel.ranges.length; i++)&#13;
        dup[i] = code;&#13;
      this.replaceSelections(dup, collapse, origin || "+input");&#13;
    },&#13;
    replaceSelections: docMethodOp(function(code, collapse, origin) {&#13;
      var changes = [], sel = this.sel;&#13;
      for (var i = 0; i &lt; sel.ranges.length; i++) {&#13;
        var range = sel.ranges[i];&#13;
        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};&#13;
      }&#13;
      var newSel = collapse &amp;&amp; collapse != "end" &amp;&amp; computeReplacedSel(this, changes, collapse);&#13;
      for (var i = changes.length - 1; i &gt;= 0; i--)&#13;
        makeChange(this, changes[i]);&#13;
      if (newSel) setSelectionReplaceHistory(this, newSel);&#13;
      else if (this.cm) ensureCursorVisible(this.cm);&#13;
    }),&#13;
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),&#13;
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),&#13;
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),&#13;
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),&#13;
&#13;
    setExtending: function(val) {this.extend = val;},&#13;
    getExtending: function() {return this.extend;},&#13;
&#13;
    historySize: function() {&#13;
      var hist = this.history, done = 0, undone = 0;&#13;
      for (var i = 0; i &lt; hist.done.length; i++) if (!hist.done[i].ranges) ++done;&#13;
      for (var i = 0; i &lt; hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;&#13;
      return {undo: done, redo: undone};&#13;
    },&#13;
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},&#13;
&#13;
    markClean: function() {&#13;
      this.cleanGeneration = this.changeGeneration(true);&#13;
    },&#13;
    changeGeneration: function(forceSplit) {&#13;
      if (forceSplit)&#13;
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;&#13;
      return this.history.generation;&#13;
    },&#13;
    isClean: function (gen) {&#13;
      return this.history.generation == (gen || this.cleanGeneration);&#13;
    },&#13;
&#13;
    getHistory: function() {&#13;
      return {done: copyHistoryArray(this.history.done),&#13;
              undone: copyHistoryArray(this.history.undone)};&#13;
    },&#13;
    setHistory: function(histData) {&#13;
      var hist = this.history = new History(this.history.maxGeneration);&#13;
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);&#13;
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);&#13;
    },&#13;
&#13;
    addLineClass: docMethodOp(function(handle, where, cls) {&#13;
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {&#13;
        var prop = where == "text" ? "textClass"&#13;
                 : where == "background" ? "bgClass"&#13;
                 : where == "gutter" ? "gutterClass" : "wrapClass";&#13;
        if (!line[prop]) line[prop] = cls;&#13;
        else if (classTest(cls).test(line[prop])) return false;&#13;
        else line[prop] += " " + cls;&#13;
        return true;&#13;
      });&#13;
    }),&#13;
    removeLineClass: docMethodOp(function(handle, where, cls) {&#13;
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {&#13;
        var prop = where == "text" ? "textClass"&#13;
                 : where == "background" ? "bgClass"&#13;
                 : where == "gutter" ? "gutterClass" : "wrapClass";&#13;
        var cur = line[prop];&#13;
        if (!cur) return false;&#13;
        else if (cls == null) line[prop] = null;&#13;
        else {&#13;
          var found = cur.match(classTest(cls));&#13;
          if (!found) return false;&#13;
          var end = found.index + found[0].length;&#13;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;&#13;
        }&#13;
        return true;&#13;
      });&#13;
    }),&#13;
&#13;
    addLineWidget: docMethodOp(function(handle, node, options) {&#13;
      return addLineWidget(this, handle, node, options);&#13;
    }),&#13;
    removeLineWidget: function(widget) { widget.clear(); },&#13;
&#13;
    markText: function(from, to, options) {&#13;
      return markText(this, clipPos(this, from), clipPos(this, to), options, options &amp;&amp; options.type || "range");&#13;
    },&#13;
    setBookmark: function(pos, options) {&#13;
      var realOpts = {replacedWith: options &amp;&amp; (options.nodeType == null ? options.widget : options),&#13;
                      insertLeft: options &amp;&amp; options.insertLeft,&#13;
                      clearWhenEmpty: false, shared: options &amp;&amp; options.shared,&#13;
                      handleMouseEvents: options &amp;&amp; options.handleMouseEvents};&#13;
      pos = clipPos(this, pos);&#13;
      return markText(this, pos, pos, realOpts, "bookmark");&#13;
    },&#13;
    findMarksAt: function(pos) {&#13;
      pos = clipPos(this, pos);&#13;
      var markers = [], spans = getLine(this, pos.line).markedSpans;&#13;
      if (spans) for (var i = 0; i &lt; spans.length; ++i) {&#13;
        var span = spans[i];&#13;
        if ((span.from == null || span.from &lt;= pos.ch) &amp;&amp;&#13;
            (span.to == null || span.to &gt;= pos.ch))&#13;
          markers.push(span.marker.parent || span.marker);&#13;
      }&#13;
      return markers;&#13;
    },&#13;
    findMarks: function(from, to, filter) {&#13;
      from = clipPos(this, from); to = clipPos(this, to);&#13;
      var found = [], lineNo = from.line;&#13;
      this.iter(from.line, to.line + 1, function(line) {&#13;
        var spans = line.markedSpans;&#13;
        if (spans) for (var i = 0; i &lt; spans.length; i++) {&#13;
          var span = spans[i];&#13;
          if (!(span.to != null &amp;&amp; lineNo == from.line &amp;&amp; from.ch &gt;= span.to ||&#13;
                span.from == null &amp;&amp; lineNo != from.line ||&#13;
                span.from != null &amp;&amp; lineNo == to.line &amp;&amp; span.from &gt;= to.ch) &amp;&amp;&#13;
              (!filter || filter(span.marker)))&#13;
            found.push(span.marker.parent || span.marker);&#13;
        }&#13;
        ++lineNo;&#13;
      });&#13;
      return found;&#13;
    },&#13;
    getAllMarks: function() {&#13;
      var markers = [];&#13;
      this.iter(function(line) {&#13;
        var sps = line.markedSpans;&#13;
        if (sps) for (var i = 0; i &lt; sps.length; ++i)&#13;
          if (sps[i].from != null) markers.push(sps[i].marker);&#13;
      });&#13;
      return markers;&#13;
    },&#13;
&#13;
    posFromIndex: function(off) {&#13;
      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;&#13;
      this.iter(function(line) {&#13;
        var sz = line.text.length + sepSize;&#13;
        if (sz &gt; off) { ch = off; return true; }&#13;
        off -= sz;&#13;
        ++lineNo;&#13;
      });&#13;
      return clipPos(this, Pos(lineNo, ch));&#13;
    },&#13;
    indexFromPos: function (coords) {&#13;
      coords = clipPos(this, coords);&#13;
      var index = coords.ch;&#13;
      if (coords.line &lt; this.first || coords.ch &lt; 0) return 0;&#13;
      var sepSize = this.lineSeparator().length;&#13;
      this.iter(this.first, coords.line, function (line) {&#13;
        index += line.text.length + sepSize;&#13;
      });&#13;
      return index;&#13;
    },&#13;
&#13;
    copy: function(copyHistory) {&#13;
      var doc = new Doc(getLines(this, this.first, this.first + this.size),&#13;
                        this.modeOption, this.first, this.lineSep);&#13;
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;&#13;
      doc.sel = this.sel;&#13;
      doc.extend = false;&#13;
      if (copyHistory) {&#13;
        doc.history.undoDepth = this.history.undoDepth;&#13;
        doc.setHistory(this.getHistory());&#13;
      }&#13;
      return doc;&#13;
    },&#13;
&#13;
    linkedDoc: function(options) {&#13;
      if (!options) options = {};&#13;
      var from = this.first, to = this.first + this.size;&#13;
      if (options.from != null &amp;&amp; options.from &gt; from) from = options.from;&#13;
      if (options.to != null &amp;&amp; options.to &lt; to) to = options.to;&#13;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);&#13;
      if (options.sharedHist) copy.history = this.history;&#13;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});&#13;
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];&#13;
      copySharedMarkers(copy, findSharedMarkers(this));&#13;
      return copy;&#13;
    },&#13;
    unlinkDoc: function(other) {&#13;
      if (other instanceof CodeMirror) other = other.doc;&#13;
      if (this.linked) for (var i = 0; i &lt; this.linked.length; ++i) {&#13;
        var link = this.linked[i];&#13;
        if (link.doc != other) continue;&#13;
        this.linked.splice(i, 1);&#13;
        other.unlinkDoc(this);&#13;
        detachSharedMarkers(findSharedMarkers(this));&#13;
        break;&#13;
      }&#13;
      // If the histories were shared, split them again&#13;
      if (other.history == this.history) {&#13;
        var splitIds = [other.id];&#13;
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);&#13;
        other.history = new History(null);&#13;
        other.history.done = copyHistoryArray(this.history.done, splitIds);&#13;
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);&#13;
      }&#13;
    },&#13;
    iterLinkedDocs: function(f) {linkedDocs(this, f);},&#13;
&#13;
    getMode: function() {return this.mode;},&#13;
    getEditor: function() {return this.cm;},&#13;
&#13;
    splitLines: function(str) {&#13;
      if (this.lineSep) return str.split(this.lineSep);&#13;
      return splitLinesAuto(str);&#13;
    },&#13;
    lineSeparator: function() { return this.lineSep || "\n"; }&#13;
  });&#13;
&#13;
  // Public alias.&#13;
  Doc.prototype.eachLine = Doc.prototype.iter;&#13;
&#13;
  // Set up methods on CodeMirror's prototype to redirect to the editor's document.&#13;
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");&#13;
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) &amp;&amp; indexOf(dontDelegate, prop) &lt; 0)&#13;
    CodeMirror.prototype[prop] = (function(method) {&#13;
      return function() {return method.apply(this.doc, arguments);};&#13;
    })(Doc.prototype[prop]);&#13;
&#13;
  eventMixin(Doc);&#13;
&#13;
  // Call f for all linked documents.&#13;
  function linkedDocs(doc, f, sharedHistOnly) {&#13;
    function propagate(doc, skip, sharedHist) {&#13;
      if (doc.linked) for (var i = 0; i &lt; doc.linked.length; ++i) {&#13;
        var rel = doc.linked[i];&#13;
        if (rel.doc == skip) continue;&#13;
        var shared = sharedHist &amp;&amp; rel.sharedHist;&#13;
        if (sharedHistOnly &amp;&amp; !shared) continue;&#13;
        f(rel.doc, shared);&#13;
        propagate(rel.doc, doc, shared);&#13;
      }&#13;
    }&#13;
    propagate(doc, null, true);&#13;
  }&#13;
&#13;
  // Attach a document to an editor.&#13;
  function attachDoc(cm, doc) {&#13;
    if (doc.cm) throw new Error("This document is already in use.");&#13;
    cm.doc = doc;&#13;
    doc.cm = cm;&#13;
    estimateLineHeights(cm);&#13;
    loadMode(cm);&#13;
    if (!cm.options.lineWrapping) findMaxLine(cm);&#13;
    cm.options.mode = doc.modeOption;&#13;
    regChange(cm);&#13;
  }&#13;
&#13;
  // LINE UTILITIES&#13;
&#13;
  // Find the line object corresponding to the given line number.&#13;
  function getLine(doc, n) {&#13;
    n -= doc.first;&#13;
    if (n &lt; 0 || n &gt;= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");&#13;
    for (var chunk = doc; !chunk.lines;) {&#13;
      for (var i = 0;; ++i) {&#13;
        var child = chunk.children[i], sz = child.chunkSize();&#13;
        if (n &lt; sz) { chunk = child; break; }&#13;
        n -= sz;&#13;
      }&#13;
    }&#13;
    return chunk.lines[n];&#13;
  }&#13;
&#13;
  // Get the part of a document between two positions, as an array of&#13;
  // strings.&#13;
  function getBetween(doc, start, end) {&#13;
    var out = [], n = start.line;&#13;
    doc.iter(start.line, end.line + 1, function(line) {&#13;
      var text = line.text;&#13;
      if (n == end.line) text = text.slice(0, end.ch);&#13;
      if (n == start.line) text = text.slice(start.ch);&#13;
      out.push(text);&#13;
      ++n;&#13;
    });&#13;
    return out;&#13;
  }&#13;
  // Get the lines between from and to, as array of strings.&#13;
  function getLines(doc, from, to) {&#13;
    var out = [];&#13;
    doc.iter(from, to, function(line) { out.push(line.text); });&#13;
    return out;&#13;
  }&#13;
&#13;
  // Update the height of a line, propagating the height change&#13;
  // upwards to parent nodes.&#13;
  function updateLineHeight(line, height) {&#13;
    var diff = height - line.height;&#13;
    if (diff) for (var n = line; n; n = n.parent) n.height += diff;&#13;
  }&#13;
&#13;
  // Given a line object, find its line number by walking up through&#13;
  // its parent links.&#13;
  function lineNo(line) {&#13;
    if (line.parent == null) return null;&#13;
    var cur = line.parent, no = indexOf(cur.lines, line);&#13;
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {&#13;
      for (var i = 0;; ++i) {&#13;
        if (chunk.children[i] == cur) break;&#13;
        no += chunk.children[i].chunkSize();&#13;
      }&#13;
    }&#13;
    return no + cur.first;&#13;
  }&#13;
&#13;
  // Find the line at the given vertical position, using the height&#13;
  // information in the document tree.&#13;
  function lineAtHeight(chunk, h) {&#13;
    var n = chunk.first;&#13;
    outer: do {&#13;
      for (var i = 0; i &lt; chunk.children.length; ++i) {&#13;
        var child = chunk.children[i], ch = child.height;&#13;
        if (h &lt; ch) { chunk = child; continue outer; }&#13;
        h -= ch;&#13;
        n += child.chunkSize();&#13;
      }&#13;
      return n;&#13;
    } while (!chunk.lines);&#13;
    for (var i = 0; i &lt; chunk.lines.length; ++i) {&#13;
      var line = chunk.lines[i], lh = line.height;&#13;
      if (h &lt; lh) break;&#13;
      h -= lh;&#13;
    }&#13;
    return n + i;&#13;
  }&#13;
&#13;
&#13;
  // Find the height above the given line.&#13;
  function heightAtLine(lineObj) {&#13;
    lineObj = visualLine(lineObj);&#13;
&#13;
    var h = 0, chunk = lineObj.parent;&#13;
    for (var i = 0; i &lt; chunk.lines.length; ++i) {&#13;
      var line = chunk.lines[i];&#13;
      if (line == lineObj) break;&#13;
      else h += line.height;&#13;
    }&#13;
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {&#13;
      for (var i = 0; i &lt; p.children.length; ++i) {&#13;
        var cur = p.children[i];&#13;
        if (cur == chunk) break;&#13;
        else h += cur.height;&#13;
      }&#13;
    }&#13;
    return h;&#13;
  }&#13;
&#13;
  // Get the bidi ordering for the given line (and cache it). Returns&#13;
  // false for lines that are fully left-to-right, and an array of&#13;
  // BidiSpan objects otherwise.&#13;
  function getOrder(line) {&#13;
    var order = line.order;&#13;
    if (order == null) order = line.order = bidiOrdering(line.text);&#13;
    return order;&#13;
  }&#13;
&#13;
  // HISTORY&#13;
&#13;
  function History(startGen) {&#13;
    // Arrays of change events and selections. Doing something adds an&#13;
    // event to done and clears undo. Undoing moves events from done&#13;
    // to undone, redoing moves them in the other direction.&#13;
    this.done = []; this.undone = [];&#13;
    this.undoDepth = Infinity;&#13;
    // Used to track when changes can be merged into a single undo&#13;
    // event&#13;
    this.lastModTime = this.lastSelTime = 0;&#13;
    this.lastOp = this.lastSelOp = null;&#13;
    this.lastOrigin = this.lastSelOrigin = null;&#13;
    // Used by the isClean() method&#13;
    this.generation = this.maxGeneration = startGen || 1;&#13;
  }&#13;
&#13;
  // Create a history change event from an updateDoc-style change&#13;
  // object.&#13;
  function historyChangeFromChange(doc, change) {&#13;
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};&#13;
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);&#13;
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);&#13;
    return histChange;&#13;
  }&#13;
&#13;
  // Pop all selection events off the end of a history array. Stop at&#13;
  // a change event.&#13;
  function clearSelectionEvents(array) {&#13;
    while (array.length) {&#13;
      var last = lst(array);&#13;
      if (last.ranges) array.pop();&#13;
      else break;&#13;
    }&#13;
  }&#13;
&#13;
  // Find the top change event in the history. Pop off selection&#13;
  // events that are in the way.&#13;
  function lastChangeEvent(hist, force) {&#13;
    if (force) {&#13;
      clearSelectionEvents(hist.done);&#13;
      return lst(hist.done);&#13;
    } else if (hist.done.length &amp;&amp; !lst(hist.done).ranges) {&#13;
      return lst(hist.done);&#13;
    } else if (hist.done.length &gt; 1 &amp;&amp; !hist.done[hist.done.length - 2].ranges) {&#13;
      hist.done.pop();&#13;
      return lst(hist.done);&#13;
    }&#13;
  }&#13;
&#13;
  // Register a change in the history. Merges changes that are within&#13;
  // a single operation, ore are close together with an origin that&#13;
  // allows merging (starting with "+") into a single event.&#13;
  function addChangeToHistory(doc, change, selAfter, opId) {&#13;
    var hist = doc.history;&#13;
    hist.undone.length = 0;&#13;
    var time = +new Date, cur;&#13;
&#13;
    if ((hist.lastOp == opId ||&#13;
         hist.lastOrigin == change.origin &amp;&amp; change.origin &amp;&amp;&#13;
         ((change.origin.charAt(0) == "+" &amp;&amp; doc.cm &amp;&amp; hist.lastModTime &gt; time - doc.cm.options.historyEventDelay) ||&#13;
          change.origin.charAt(0) == "*")) &amp;&amp;&#13;
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {&#13;
      // Merge this change into the last event&#13;
      var last = lst(cur.changes);&#13;
      if (cmp(change.from, change.to) == 0 &amp;&amp; cmp(change.from, last.to) == 0) {&#13;
        // Optimized case for simple insertion -- don't want to add&#13;
        // new changesets for every character typed&#13;
        last.to = changeEnd(change);&#13;
      } else {&#13;
        // Add new sub-event&#13;
        cur.changes.push(historyChangeFromChange(doc, change));&#13;
      }&#13;
    } else {&#13;
      // Can not be merged, start a new event.&#13;
      var before = lst(hist.done);&#13;
      if (!before || !before.ranges)&#13;
        pushSelectionToHistory(doc.sel, hist.done);&#13;
      cur = {changes: [historyChangeFromChange(doc, change)],&#13;
             generation: hist.generation};&#13;
      hist.done.push(cur);&#13;
      while (hist.done.length &gt; hist.undoDepth) {&#13;
        hist.done.shift();&#13;
        if (!hist.done[0].ranges) hist.done.shift();&#13;
      }&#13;
    }&#13;
    hist.done.push(selAfter);&#13;
    hist.generation = ++hist.maxGeneration;&#13;
    hist.lastModTime = hist.lastSelTime = time;&#13;
    hist.lastOp = hist.lastSelOp = opId;&#13;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;&#13;
&#13;
    if (!last) signal(doc, "historyAdded");&#13;
  }&#13;
&#13;
  function selectionEventCanBeMerged(doc, origin, prev, sel) {&#13;
    var ch = origin.charAt(0);&#13;
    return ch == "*" ||&#13;
      ch == "+" &amp;&amp;&#13;
      prev.ranges.length == sel.ranges.length &amp;&amp;&#13;
      prev.somethingSelected() == sel.somethingSelected() &amp;&amp;&#13;
      new Date - doc.history.lastSelTime &lt;= (doc.cm ? doc.cm.options.historyEventDelay : 500);&#13;
  }&#13;
&#13;
  // Called whenever the selection changes, sets the new selection as&#13;
  // the pending selection in the history, and pushes the old pending&#13;
  // selection into the 'done' array when it was significantly&#13;
  // different (in number of selected ranges, emptiness, or time).&#13;
  function addSelectionToHistory(doc, sel, opId, options) {&#13;
    var hist = doc.history, origin = options &amp;&amp; options.origin;&#13;
&#13;
    // A new event is started when the previous origin does not match&#13;
    // the current, or the origins don't allow matching. Origins&#13;
    // starting with * are always merged, those starting with + are&#13;
    // merged when similar and close together in time.&#13;
    if (opId == hist.lastSelOp ||&#13;
        (origin &amp;&amp; hist.lastSelOrigin == origin &amp;&amp;&#13;
         (hist.lastModTime == hist.lastSelTime &amp;&amp; hist.lastOrigin == origin ||&#13;
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))&#13;
      hist.done[hist.done.length - 1] = sel;&#13;
    else&#13;
      pushSelectionToHistory(sel, hist.done);&#13;
&#13;
    hist.lastSelTime = +new Date;&#13;
    hist.lastSelOrigin = origin;&#13;
    hist.lastSelOp = opId;&#13;
    if (options &amp;&amp; options.clearRedo !== false)&#13;
      clearSelectionEvents(hist.undone);&#13;
  }&#13;
&#13;
  function pushSelectionToHistory(sel, dest) {&#13;
    var top = lst(dest);&#13;
    if (!(top &amp;&amp; top.ranges &amp;&amp; top.equals(sel)))&#13;
      dest.push(sel);&#13;
  }&#13;
&#13;
  // Used to store marked span information in the history.&#13;
  function attachLocalSpans(doc, change, from, to) {&#13;
    var existing = change["spans_" + doc.id], n = 0;&#13;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {&#13;
      if (line.markedSpans)&#13;
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;&#13;
      ++n;&#13;
    });&#13;
  }&#13;
&#13;
  // When un/re-doing restores text containing marked spans, those&#13;
  // that have been explicitly cleared should not be restored.&#13;
  function removeClearedSpans(spans) {&#13;
    if (!spans) return null;&#13;
    for (var i = 0, out; i &lt; spans.length; ++i) {&#13;
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }&#13;
      else if (out) out.push(spans[i]);&#13;
    }&#13;
    return !out ? spans : out.length ? out : null;&#13;
  }&#13;
&#13;
  // Retrieve and filter the old marked spans stored in a change event.&#13;
  function getOldSpans(doc, change) {&#13;
    var found = change["spans_" + doc.id];&#13;
    if (!found) return null;&#13;
    for (var i = 0, nw = []; i &lt; change.text.length; ++i)&#13;
      nw.push(removeClearedSpans(found[i]));&#13;
    return nw;&#13;
  }&#13;
&#13;
  // Used both to provide a JSON-safe object in .getHistory, and, when&#13;
  // detaching a document, to split the history in two&#13;
  function copyHistoryArray(events, newGroup, instantiateSel) {&#13;
    for (var i = 0, copy = []; i &lt; events.length; ++i) {&#13;
      var event = events[i];&#13;
      if (event.ranges) {&#13;
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);&#13;
        continue;&#13;
      }&#13;
      var changes = event.changes, newChanges = [];&#13;
      copy.push({changes: newChanges});&#13;
      for (var j = 0; j &lt; changes.length; ++j) {&#13;
        var change = changes[j], m;&#13;
        newChanges.push({from: change.from, to: change.to, text: change.text});&#13;
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {&#13;
          if (indexOf(newGroup, Number(m[1])) &gt; -1) {&#13;
            lst(newChanges)[prop] = change[prop];&#13;
            delete change[prop];&#13;
          }&#13;
        }&#13;
      }&#13;
    }&#13;
    return copy;&#13;
  }&#13;
&#13;
  // Rebasing/resetting history to deal with externally-sourced changes&#13;
&#13;
  function rebaseHistSelSingle(pos, from, to, diff) {&#13;
    if (to &lt; pos.line) {&#13;
      pos.line += diff;&#13;
    } else if (from &lt; pos.line) {&#13;
      pos.line = from;&#13;
      pos.ch = 0;&#13;
    }&#13;
  }&#13;
&#13;
  // Tries to rebase an array of history events given a change in the&#13;
  // document. If the change touches the same lines as the event, the&#13;
  // event, and everything 'behind' it, is discarded. If the change is&#13;
  // before the event, the event's positions are updated. Uses a&#13;
  // copy-on-write scheme for the positions, to avoid having to&#13;
  // reallocate them all on every rebase, but also avoid problems with&#13;
  // shared position objects being unsafely updated.&#13;
  function rebaseHistArray(array, from, to, diff) {&#13;
    for (var i = 0; i &lt; array.length; ++i) {&#13;
      var sub = array[i], ok = true;&#13;
      if (sub.ranges) {&#13;
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }&#13;
        for (var j = 0; j &lt; sub.ranges.length; j++) {&#13;
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);&#13;
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);&#13;
        }&#13;
        continue;&#13;
      }&#13;
      for (var j = 0; j &lt; sub.changes.length; ++j) {&#13;
        var cur = sub.changes[j];&#13;
        if (to &lt; cur.from.line) {&#13;
          cur.from = Pos(cur.from.line + diff, cur.from.ch);&#13;
          cur.to = Pos(cur.to.line + diff, cur.to.ch);&#13;
        } else if (from &lt;= cur.to.line) {&#13;
          ok = false;&#13;
          break;&#13;
        }&#13;
      }&#13;
      if (!ok) {&#13;
        array.splice(0, i + 1);&#13;
        i = 0;&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function rebaseHist(hist, change) {&#13;
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;&#13;
    rebaseHistArray(hist.done, from, to, diff);&#13;
    rebaseHistArray(hist.undone, from, to, diff);&#13;
  }&#13;
&#13;
  // EVENT UTILITIES&#13;
&#13;
  // Due to the fact that we still support jurassic IE versions, some&#13;
  // compatibility wrappers are needed.&#13;
&#13;
  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {&#13;
    if (e.preventDefault) e.preventDefault();&#13;
    else e.returnValue = false;&#13;
  };&#13;
  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {&#13;
    if (e.stopPropagation) e.stopPropagation();&#13;
    else e.cancelBubble = true;&#13;
  };&#13;
  function e_defaultPrevented(e) {&#13;
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;&#13;
  }&#13;
  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};&#13;
&#13;
  function e_target(e) {return e.target || e.srcElement;}&#13;
  function e_button(e) {&#13;
    var b = e.which;&#13;
    if (b == null) {&#13;
      if (e.button &amp; 1) b = 1;&#13;
      else if (e.button &amp; 2) b = 3;&#13;
      else if (e.button &amp; 4) b = 2;&#13;
    }&#13;
    if (mac &amp;&amp; e.ctrlKey &amp;&amp; b == 1) b = 3;&#13;
    return b;&#13;
  }&#13;
&#13;
  // EVENT HANDLING&#13;
&#13;
  // Lightweight event framework. on/off also work on DOM nodes,&#13;
  // registering native DOM handlers.&#13;
&#13;
  var on = CodeMirror.on = function(emitter, type, f) {&#13;
    if (emitter.addEventListener)&#13;
      emitter.addEventListener(type, f, false);&#13;
    else if (emitter.attachEvent)&#13;
      emitter.attachEvent("on" + type, f);&#13;
    else {&#13;
      var map = emitter._handlers || (emitter._handlers = {});&#13;
      var arr = map[type] || (map[type] = []);&#13;
      arr.push(f);&#13;
    }&#13;
  };&#13;
&#13;
  var noHandlers = []&#13;
  function getHandlers(emitter, type, copy) {&#13;
    var arr = emitter._handlers &amp;&amp; emitter._handlers[type]&#13;
    if (copy) return arr &amp;&amp; arr.length &gt; 0 ? arr.slice() : noHandlers&#13;
    else return arr || noHandlers&#13;
  }&#13;
&#13;
  var off = CodeMirror.off = function(emitter, type, f) {&#13;
    if (emitter.removeEventListener)&#13;
      emitter.removeEventListener(type, f, false);&#13;
    else if (emitter.detachEvent)&#13;
      emitter.detachEvent("on" + type, f);&#13;
    else {&#13;
      var handlers = getHandlers(emitter, type, false)&#13;
      for (var i = 0; i &lt; handlers.length; ++i)&#13;
        if (handlers[i] == f) { handlers.splice(i, 1); break; }&#13;
    }&#13;
  };&#13;
&#13;
  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {&#13;
    var handlers = getHandlers(emitter, type, true)&#13;
    if (!handlers.length) return;&#13;
    var args = Array.prototype.slice.call(arguments, 2);&#13;
    for (var i = 0; i &lt; handlers.length; ++i) handlers[i].apply(null, args);&#13;
  };&#13;
&#13;
  var orphanDelayedCallbacks = null;&#13;
&#13;
  // Often, we want to signal events at a point where we are in the&#13;
  // middle of some work, but don't want the handler to start calling&#13;
  // other methods on the editor, which might be in an inconsistent&#13;
  // state or simply not expect any other events to happen.&#13;
  // signalLater looks whether there are any handlers, and schedules&#13;
  // them to be executed when the last operation ends, or, if no&#13;
  // operation is active, when a timeout fires.&#13;
  function signalLater(emitter, type /*, values...*/) {&#13;
    var arr = getHandlers(emitter, type, false)&#13;
    if (!arr.length) return;&#13;
    var args = Array.prototype.slice.call(arguments, 2), list;&#13;
    if (operationGroup) {&#13;
      list = operationGroup.delayedCallbacks;&#13;
    } else if (orphanDelayedCallbacks) {&#13;
      list = orphanDelayedCallbacks;&#13;
    } else {&#13;
      list = orphanDelayedCallbacks = [];&#13;
      setTimeout(fireOrphanDelayed, 0);&#13;
    }&#13;
    function bnd(f) {return function(){f.apply(null, args);};};&#13;
    for (var i = 0; i &lt; arr.length; ++i)&#13;
      list.push(bnd(arr[i]));&#13;
  }&#13;
&#13;
  function fireOrphanDelayed() {&#13;
    var delayed = orphanDelayedCallbacks;&#13;
    orphanDelayedCallbacks = null;&#13;
    for (var i = 0; i &lt; delayed.length; ++i) delayed[i]();&#13;
  }&#13;
&#13;
  // The DOM events that CodeMirror handles can be overridden by&#13;
  // registering a (non-DOM) handler on the editor for the event name,&#13;
  // and preventDefault-ing the event in that handler.&#13;
  function signalDOMEvent(cm, e, override) {&#13;
    if (typeof e == "string")&#13;
      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};&#13;
    signal(cm, override || e.type, cm, e);&#13;
    return e_defaultPrevented(e) || e.codemirrorIgnore;&#13;
  }&#13;
&#13;
  function signalCursorActivity(cm) {&#13;
    var arr = cm._handlers &amp;&amp; cm._handlers.cursorActivity;&#13;
    if (!arr) return;&#13;
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);&#13;
    for (var i = 0; i &lt; arr.length; ++i) if (indexOf(set, arr[i]) == -1)&#13;
      set.push(arr[i]);&#13;
  }&#13;
&#13;
  function hasHandler(emitter, type) {&#13;
    return getHandlers(emitter, type).length &gt; 0&#13;
  }&#13;
&#13;
  // Add on and off methods to a constructor's prototype, to make&#13;
  // registering events on such objects more convenient.&#13;
  function eventMixin(ctor) {&#13;
    ctor.prototype.on = function(type, f) {on(this, type, f);};&#13;
    ctor.prototype.off = function(type, f) {off(this, type, f);};&#13;
  }&#13;
&#13;
  // MISC UTILITIES&#13;
&#13;
  // Number of pixels added to scroller and sizer to hide scrollbar&#13;
  var scrollerGap = 30;&#13;
&#13;
  // Returned or thrown by various protocols to signal 'I'm not&#13;
  // handling this'.&#13;
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};&#13;
&#13;
  // Reused option objects for setSelection &amp; friends&#13;
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};&#13;
&#13;
  function Delayed() {this.id = null;}&#13;
  Delayed.prototype.set = function(ms, f) {&#13;
    clearTimeout(this.id);&#13;
    this.id = setTimeout(f, ms);&#13;
  };&#13;
&#13;
  // Counts the column offset in a string, taking tabs into account.&#13;
  // Used mostly to find indentation.&#13;
  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {&#13;
    if (end == null) {&#13;
      end = string.search(/[^\s\u00a0]/);&#13;
      if (end == -1) end = string.length;&#13;
    }&#13;
    for (var i = startIndex || 0, n = startValue || 0;;) {&#13;
      var nextTab = string.indexOf("\t", i);&#13;
      if (nextTab &lt; 0 || nextTab &gt;= end)&#13;
        return n + (end - i);&#13;
      n += nextTab - i;&#13;
      n += tabSize - (n % tabSize);&#13;
      i = nextTab + 1;&#13;
    }&#13;
  };&#13;
&#13;
  // The inverse of countColumn -- find the offset that corresponds to&#13;
  // a particular column.&#13;
  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {&#13;
    for (var pos = 0, col = 0;;) {&#13;
      var nextTab = string.indexOf("\t", pos);&#13;
      if (nextTab == -1) nextTab = string.length;&#13;
      var skipped = nextTab - pos;&#13;
      if (nextTab == string.length || col + skipped &gt;= goal)&#13;
        return pos + Math.min(skipped, goal - col);&#13;
      col += nextTab - pos;&#13;
      col += tabSize - (col % tabSize);&#13;
      pos = nextTab + 1;&#13;
      if (col &gt;= goal) return pos;&#13;
    }&#13;
  }&#13;
&#13;
  var spaceStrs = [""];&#13;
  function spaceStr(n) {&#13;
    while (spaceStrs.length &lt;= n)&#13;
      spaceStrs.push(lst(spaceStrs) + " ");&#13;
    return spaceStrs[n];&#13;
  }&#13;
&#13;
  function lst(arr) { return arr[arr.length-1]; }&#13;
&#13;
  var selectInput = function(node) { node.select(); };&#13;
  if (ios) // Mobile Safari apparently has a bug where select() is broken.&#13;
    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };&#13;
  else if (ie) // Suppress mysterious IE10 errors&#13;
    selectInput = function(node) { try { node.select(); } catch(_e) {} };&#13;
&#13;
  function indexOf(array, elt) {&#13;
    for (var i = 0; i &lt; array.length; ++i)&#13;
      if (array[i] == elt) return i;&#13;
    return -1;&#13;
  }&#13;
  function map(array, f) {&#13;
    var out = [];&#13;
    for (var i = 0; i &lt; array.length; i++) out[i] = f(array[i], i);&#13;
    return out;&#13;
  }&#13;
&#13;
  function nothing() {}&#13;
&#13;
  function createObj(base, props) {&#13;
    var inst;&#13;
    if (Object.create) {&#13;
      inst = Object.create(base);&#13;
    } else {&#13;
      nothing.prototype = base;&#13;
      inst = new nothing();&#13;
    }&#13;
    if (props) copyObj(props, inst);&#13;
    return inst;&#13;
  };&#13;
&#13;
  function copyObj(obj, target, overwrite) {&#13;
    if (!target) target = {};&#13;
    for (var prop in obj)&#13;
      if (obj.hasOwnProperty(prop) &amp;&amp; (overwrite !== false || !target.hasOwnProperty(prop)))&#13;
        target[prop] = obj[prop];&#13;
    return target;&#13;
  }&#13;
&#13;
  function bind(f) {&#13;
    var args = Array.prototype.slice.call(arguments, 1);&#13;
    return function(){return f.apply(null, args);};&#13;
  }&#13;
&#13;
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;&#13;
  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {&#13;
    return /\w/.test(ch) || ch &gt; "\x80" &amp;&amp;&#13;
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));&#13;
  };&#13;
  function isWordChar(ch, helper) {&#13;
    if (!helper) return isWordCharBasic(ch);&#13;
    if (helper.source.indexOf("\\w") &gt; -1 &amp;&amp; isWordCharBasic(ch)) return true;&#13;
    return helper.test(ch);&#13;
  }&#13;
&#13;
  function isEmpty(obj) {&#13;
    for (var n in obj) if (obj.hasOwnProperty(n) &amp;&amp; obj[n]) return false;&#13;
    return true;&#13;
  }&#13;
&#13;
  // Extending unicode characters. A series of a non-extending char +&#13;
  // any number of extending chars is treated as a single unit as far&#13;
  // as editing and measuring is concerned. This is not fully correct,&#13;
  // since some scripts/fonts/browsers also treat other configurations&#13;
  // of code points as a group.&#13;
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;&#13;
  function isExtendingChar(ch) { return ch.charCodeAt(0) &gt;= 768 &amp;&amp; extendingChars.test(ch); }&#13;
&#13;
  // DOM UTILITIES&#13;
&#13;
  function elt(tag, content, className, style) {&#13;
    var e = document.createElement(tag);&#13;
    if (className) e.className = className;&#13;
    if (style) e.style.cssText = style;&#13;
    if (typeof content == "string") e.appendChild(document.createTextNode(content));&#13;
    else if (content) for (var i = 0; i &lt; content.length; ++i) e.appendChild(content[i]);&#13;
    return e;&#13;
  }&#13;
&#13;
  var range;&#13;
  if (document.createRange) range = function(node, start, end, endNode) {&#13;
    var r = document.createRange();&#13;
    r.setEnd(endNode || node, end);&#13;
    r.setStart(node, start);&#13;
    return r;&#13;
  };&#13;
  else range = function(node, start, end) {&#13;
    var r = document.body.createTextRange();&#13;
    try { r.moveToElementText(node.parentNode); }&#13;
    catch(e) { return r; }&#13;
    r.collapse(true);&#13;
    r.moveEnd("character", end);&#13;
    r.moveStart("character", start);&#13;
    return r;&#13;
  };&#13;
&#13;
  function removeChildren(e) {&#13;
    for (var count = e.childNodes.length; count &gt; 0; --count)&#13;
      e.removeChild(e.firstChild);&#13;
    return e;&#13;
  }&#13;
&#13;
  function removeChildrenAndAdd(parent, e) {&#13;
    return removeChildren(parent).appendChild(e);&#13;
  }&#13;
&#13;
  var contains = CodeMirror.contains = function(parent, child) {&#13;
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode&#13;
      child = child.parentNode;&#13;
    if (parent.contains)&#13;
      return parent.contains(child);&#13;
    do {&#13;
      if (child.nodeType == 11) child = child.host;&#13;
      if (child == parent) return true;&#13;
    } while (child = child.parentNode);&#13;
  };&#13;
&#13;
  function activeElt() {&#13;
    var activeElement = document.activeElement;&#13;
    while (activeElement &amp;&amp; activeElement.root &amp;&amp; activeElement.root.activeElement)&#13;
      activeElement = activeElement.root.activeElement;&#13;
    return activeElement;&#13;
  }&#13;
  // Older versions of IE throws unspecified error when touching&#13;
  // document.activeElement in some cases (during loading, in iframe)&#13;
  if (ie &amp;&amp; ie_version &lt; 11) activeElt = function() {&#13;
    try { return document.activeElement; }&#13;
    catch(e) { return document.body; }&#13;
  };&#13;
&#13;
  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*"); }&#13;
  var rmClass = CodeMirror.rmClass = function(node, cls) {&#13;
    var current = node.className;&#13;
    var match = classTest(cls).exec(current);&#13;
    if (match) {&#13;
      var after = current.slice(match.index + match[0].length);&#13;
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");&#13;
    }&#13;
  };&#13;
  var addClass = CodeMirror.addClass = function(node, cls) {&#13;
    var current = node.className;&#13;
    if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;&#13;
  };&#13;
  function joinClasses(a, b) {&#13;
    var as = a.split(" ");&#13;
    for (var i = 0; i &lt; as.length; i++)&#13;
      if (as[i] &amp;&amp; !classTest(as[i]).test(b)) b += " " + as[i];&#13;
    return b;&#13;
  }&#13;
&#13;
  // WINDOW-WIDE EVENTS&#13;
&#13;
  // These must be handled carefully, because naively registering a&#13;
  // handler for each editor will cause the editors to never be&#13;
  // garbage collected.&#13;
&#13;
  function forEachCodeMirror(f) {&#13;
    if (!document.body.getElementsByClassName) return;&#13;
    var byClass = document.body.getElementsByClassName("CodeMirror");&#13;
    for (var i = 0; i &lt; byClass.length; i++) {&#13;
      var cm = byClass[i].CodeMirror;&#13;
      if (cm) f(cm);&#13;
    }&#13;
  }&#13;
&#13;
  var globalsRegistered = false;&#13;
  function ensureGlobalHandlers() {&#13;
    if (globalsRegistered) return;&#13;
    registerGlobalHandlers();&#13;
    globalsRegistered = true;&#13;
  }&#13;
  function registerGlobalHandlers() {&#13;
    // When the window resizes, we need to refresh active editors.&#13;
    var resizeTimer;&#13;
    on(window, "resize", function() {&#13;
      if (resizeTimer == null) resizeTimer = setTimeout(function() {&#13;
        resizeTimer = null;&#13;
        forEachCodeMirror(onResize);&#13;
      }, 100);&#13;
    });&#13;
    // When the window loses focus, we want to show the editor as blurred&#13;
    on(window, "blur", function() {&#13;
      forEachCodeMirror(onBlur);&#13;
    });&#13;
  }&#13;
&#13;
  // FEATURE DETECTION&#13;
&#13;
  // Detect drag-and-drop&#13;
  var dragAndDrop = function() {&#13;
    // There is *some* kind of drag-and-drop support in IE6-8, but I&#13;
    // couldn't get it to work yet.&#13;
    if (ie &amp;&amp; ie_version &lt; 9) return false;&#13;
    var div = elt('div');&#13;
    return "draggable" in div || "dragDrop" in div;&#13;
  }();&#13;
&#13;
  var zwspSupported;&#13;
  function zeroWidthElement(measure) {&#13;
    if (zwspSupported == null) {&#13;
      var test = elt("span", "\u200b");&#13;
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));&#13;
      if (measure.firstChild.offsetHeight != 0)&#13;
        zwspSupported = test.offsetWidth &lt;= 1 &amp;&amp; test.offsetHeight &gt; 2 &amp;&amp; !(ie &amp;&amp; ie_version &lt; 8);&#13;
    }&#13;
    var node = zwspSupported ? elt("span", "\u200b") :&#13;
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");&#13;
    node.setAttribute("cm-text", "");&#13;
    return node;&#13;
  }&#13;
&#13;
  // Feature-detect IE's crummy client rect reporting for bidi text&#13;
  var badBidiRects;&#13;
  function hasBadBidiRects(measure) {&#13;
    if (badBidiRects != null) return badBidiRects;&#13;
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));&#13;
    var r0 = range(txt, 0, 1).getBoundingClientRect();&#13;
    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)&#13;
    var r1 = range(txt, 1, 2).getBoundingClientRect();&#13;
    return badBidiRects = (r1.right - r0.right &lt; 3);&#13;
  }&#13;
&#13;
  // See if "".split is the broken IE version, if so, provide an&#13;
  // alternative way to split lines.&#13;
  var splitLinesAuto = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {&#13;
    var pos = 0, result = [], l = string.length;&#13;
    while (pos &lt;= l) {&#13;
      var nl = string.indexOf("\n", pos);&#13;
      if (nl == -1) nl = string.length;&#13;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);&#13;
      var rt = line.indexOf("\r");&#13;
      if (rt != -1) {&#13;
        result.push(line.slice(0, rt));&#13;
        pos += rt + 1;&#13;
      } else {&#13;
        result.push(line);&#13;
        pos = nl + 1;&#13;
      }&#13;
    }&#13;
    return result;&#13;
  } : function(string){return string.split(/\r\n?|\n/);};&#13;
&#13;
  var hasSelection = window.getSelection ? function(te) {&#13;
    try { return te.selectionStart != te.selectionEnd; }&#13;
    catch(e) { return false; }&#13;
  } : function(te) {&#13;
    try {var range = te.ownerDocument.selection.createRange();}&#13;
    catch(e) {}&#13;
    if (!range || range.parentElement() != te) return false;&#13;
    return range.compareEndPoints("StartToEnd", range) != 0;&#13;
  };&#13;
&#13;
  var hasCopyEvent = (function() {&#13;
    var e = elt("div");&#13;
    if ("oncopy" in e) return true;&#13;
    e.setAttribute("oncopy", "return;");&#13;
    return typeof e.oncopy == "function";&#13;
  })();&#13;
&#13;
  var badZoomedRects = null;&#13;
  function hasBadZoomedRects(measure) {&#13;
    if (badZoomedRects != null) return badZoomedRects;&#13;
    var node = removeChildrenAndAdd(measure, elt("span", "x"));&#13;
    var normal = node.getBoundingClientRect();&#13;
    var fromRange = range(node, 0, 1).getBoundingClientRect();&#13;
    return badZoomedRects = Math.abs(normal.left - fromRange.left) &gt; 1;&#13;
  }&#13;
&#13;
  // KEY NAMES&#13;
&#13;
  var keyNames = CodeMirror.keyNames = {&#13;
    3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",&#13;
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",&#13;
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",&#13;
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",&#13;
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",&#13;
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",&#13;
    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",&#13;
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"&#13;
  };&#13;
  (function() {&#13;
    // Number keys&#13;
    for (var i = 0; i &lt; 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);&#13;
    // Alphabetic keys&#13;
    for (var i = 65; i &lt;= 90; i++) keyNames[i] = String.fromCharCode(i);&#13;
    // Function keys&#13;
    for (var i = 1; i &lt;= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;&#13;
  })();&#13;
&#13;
  // BIDI HELPERS&#13;
&#13;
  function iterateBidiSections(order, from, to, f) {&#13;
    if (!order) return f(from, to, "ltr");&#13;
    var found = false;&#13;
    for (var i = 0; i &lt; order.length; ++i) {&#13;
      var part = order[i];&#13;
      if (part.from &lt; to &amp;&amp; part.to &gt; from || from == to &amp;&amp; part.to == from) {&#13;
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");&#13;
        found = true;&#13;
      }&#13;
    }&#13;
    if (!found) f(from, to, "ltr");&#13;
  }&#13;
&#13;
  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }&#13;
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }&#13;
&#13;
  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }&#13;
  function lineRight(line) {&#13;
    var order = getOrder(line);&#13;
    if (!order) return line.text.length;&#13;
    return bidiRight(lst(order));&#13;
  }&#13;
&#13;
  function lineStart(cm, lineN) {&#13;
    var line = getLine(cm.doc, lineN);&#13;
    var visual = visualLine(line);&#13;
    if (visual != line) lineN = lineNo(visual);&#13;
    var order = getOrder(visual);&#13;
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);&#13;
    return Pos(lineN, ch);&#13;
  }&#13;
  function lineEnd(cm, lineN) {&#13;
    var merged, line = getLine(cm.doc, lineN);&#13;
    while (merged = collapsedSpanAtEnd(line)) {&#13;
      line = merged.find(1, true).line;&#13;
      lineN = null;&#13;
    }&#13;
    var order = getOrder(line);&#13;
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);&#13;
    return Pos(lineN == null ? lineNo(line) : lineN, ch);&#13;
  }&#13;
  function lineStartSmart(cm, pos) {&#13;
    var start = lineStart(cm, pos.line);&#13;
    var line = getLine(cm.doc, start.line);&#13;
    var order = getOrder(line);&#13;
    if (!order || order[0].level == 0) {&#13;
      var firstNonWS = Math.max(0, line.text.search(/\S/));&#13;
      var inWS = pos.line == start.line &amp;&amp; pos.ch &lt;= firstNonWS &amp;&amp; pos.ch;&#13;
      return Pos(start.line, inWS ? 0 : firstNonWS);&#13;
    }&#13;
    return start;&#13;
  }&#13;
&#13;
  function compareBidiLevel(order, a, b) {&#13;
    var linedir = order[0].level;&#13;
    if (a == linedir) return true;&#13;
    if (b == linedir) return false;&#13;
    return a &lt; b;&#13;
  }&#13;
  var bidiOther;&#13;
  function getBidiPartAt(order, pos) {&#13;
    bidiOther = null;&#13;
    for (var i = 0, found; i &lt; order.length; ++i) {&#13;
      var cur = order[i];&#13;
      if (cur.from &lt; pos &amp;&amp; cur.to &gt; pos) return i;&#13;
      if ((cur.from == pos || cur.to == pos)) {&#13;
        if (found == null) {&#13;
          found = i;&#13;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {&#13;
          if (cur.from != cur.to) bidiOther = found;&#13;
          return i;&#13;
        } else {&#13;
          if (cur.from != cur.to) bidiOther = i;&#13;
          return found;&#13;
        }&#13;
      }&#13;
    }&#13;
    return found;&#13;
  }&#13;
&#13;
  function moveInLine(line, pos, dir, byUnit) {&#13;
    if (!byUnit) return pos + dir;&#13;
    do pos += dir;&#13;
    while (pos &gt; 0 &amp;&amp; isExtendingChar(line.text.charAt(pos)));&#13;
    return pos;&#13;
  }&#13;
&#13;
  // This is needed in order to move 'visually' through bi-directional&#13;
  // text -- i.e., pressing left should make the cursor go left, even&#13;
  // when in RTL text. The tricky part is the 'jumps', where RTL and&#13;
  // LTR text touch each other. This often requires the cursor offset&#13;
  // to move more than one unit, in order to visually move one unit.&#13;
  function moveVisually(line, start, dir, byUnit) {&#13;
    var bidi = getOrder(line);&#13;
    if (!bidi) return moveLogically(line, start, dir, byUnit);&#13;
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];&#13;
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);&#13;
&#13;
    for (;;) {&#13;
      if (target &gt; part.from &amp;&amp; target &lt; part.to) return target;&#13;
      if (target == part.from || target == part.to) {&#13;
        if (getBidiPartAt(bidi, target) == pos) return target;&#13;
        part = bidi[pos += dir];&#13;
        return (dir &gt; 0) == part.level % 2 ? part.to : part.from;&#13;
      } else {&#13;
        part = bidi[pos += dir];&#13;
        if (!part) return null;&#13;
        if ((dir &gt; 0) == part.level % 2)&#13;
          target = moveInLine(line, part.to, -1, byUnit);&#13;
        else&#13;
          target = moveInLine(line, part.from, 1, byUnit);&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  function moveLogically(line, start, dir, byUnit) {&#13;
    var target = start + dir;&#13;
    if (byUnit) while (target &gt; 0 &amp;&amp; isExtendingChar(line.text.charAt(target))) target += dir;&#13;
    return target &lt; 0 || target &gt; line.text.length ? null : target;&#13;
  }&#13;
&#13;
  // Bidirectional ordering algorithm&#13;
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm&#13;
  // that this (partially) implements.&#13;
&#13;
  // One-char codes used for character types:&#13;
  // L (L):   Left-to-Right&#13;
  // R (R):   Right-to-Left&#13;
  // r (AL):  Right-to-Left Arabic&#13;
  // 1 (EN):  European Number&#13;
  // + (ES):  European Number Separator&#13;
  // % (ET):  European Number Terminator&#13;
  // n (AN):  Arabic Number&#13;
  // , (CS):  Common Number Separator&#13;
  // m (NSM): Non-Spacing Mark&#13;
  // b (BN):  Boundary Neutral&#13;
  // s (B):   Paragraph Separator&#13;
  // t (S):   Segment Separator&#13;
  // w (WS):  Whitespace&#13;
  // N (ON):  Other Neutrals&#13;
&#13;
  // Returns null if characters are ordered as they appear&#13;
  // (left-to-right), or an array of sections ({from, to, level}&#13;
  // objects) in the order in which they occur visually.&#13;
  var bidiOrdering = (function() {&#13;
    // Character types for codepoints 0 to 0xff&#13;
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";&#13;
    // Character types for codepoints 0x600 to 0x6ff&#13;
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";&#13;
    function charType(code) {&#13;
      if (code &lt;= 0xf7) return lowTypes.charAt(code);&#13;
      else if (0x590 &lt;= code &amp;&amp; code &lt;= 0x5f4) return "R";&#13;
      else if (0x600 &lt;= code &amp;&amp; code &lt;= 0x6ed) return arabicTypes.charAt(code - 0x600);&#13;
      else if (0x6ee &lt;= code &amp;&amp; code &lt;= 0x8ac) return "r";&#13;
      else if (0x2000 &lt;= code &amp;&amp; code &lt;= 0x200b) return "w";&#13;
      else if (code == 0x200c) return "b";&#13;
      else return "L";&#13;
    }&#13;
&#13;
    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;&#13;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;&#13;
    // Browsers seem to always treat the boundaries of block elements as being L.&#13;
    var outerType = "L";&#13;
&#13;
    function BidiSpan(level, from, to) {&#13;
      this.level = level;&#13;
      this.from = from; this.to = to;&#13;
    }&#13;
&#13;
    return function(str) {&#13;
      if (!bidiRE.test(str)) return false;&#13;
      var len = str.length, types = [];&#13;
      for (var i = 0, type; i &lt; len; ++i)&#13;
        types.push(type = charType(str.charCodeAt(i)));&#13;
&#13;
      // W1. Examine each non-spacing mark (NSM) in the level run, and&#13;
      // change the type of the NSM to the type of the previous&#13;
      // character. If the NSM is at the start of the level run, it will&#13;
      // get the type of sor.&#13;
      for (var i = 0, prev = outerType; i &lt; len; ++i) {&#13;
        var type = types[i];&#13;
        if (type == "m") types[i] = prev;&#13;
        else prev = type;&#13;
      }&#13;
&#13;
      // W2. Search backwards from each instance of a European number&#13;
      // until the first strong type (R, L, AL, or sor) is found. If an&#13;
      // AL is found, change the type of the European number to Arabic&#13;
      // number.&#13;
      // W3. Change all ALs to R.&#13;
      for (var i = 0, cur = outerType; i &lt; len; ++i) {&#13;
        var type = types[i];&#13;
        if (type == "1" &amp;&amp; cur == "r") types[i] = "n";&#13;
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }&#13;
      }&#13;
&#13;
      // W4. A single European separator between two European numbers&#13;
      // changes to a European number. A single common separator between&#13;
      // two numbers of the same type changes to that type.&#13;
      for (var i = 1, prev = types[0]; i &lt; len - 1; ++i) {&#13;
        var type = types[i];&#13;
        if (type == "+" &amp;&amp; prev == "1" &amp;&amp; types[i+1] == "1") types[i] = "1";&#13;
        else if (type == "," &amp;&amp; prev == types[i+1] &amp;&amp;&#13;
                 (prev == "1" || prev == "n")) types[i] = prev;&#13;
        prev = type;&#13;
      }&#13;
&#13;
      // W5. A sequence of European terminators adjacent to European&#13;
      // numbers changes to all European numbers.&#13;
      // W6. Otherwise, separators and terminators change to Other&#13;
      // Neutral.&#13;
      for (var i = 0; i &lt; len; ++i) {&#13;
        var type = types[i];&#13;
        if (type == ",") types[i] = "N";&#13;
        else if (type == "%") {&#13;
          for (var end = i + 1; end &lt; len &amp;&amp; types[end] == "%"; ++end) {}&#13;
          var replace = (i &amp;&amp; types[i-1] == "!") || (end &lt; len &amp;&amp; types[end] == "1") ? "1" : "N";&#13;
          for (var j = i; j &lt; end; ++j) types[j] = replace;&#13;
          i = end - 1;&#13;
        }&#13;
      }&#13;
&#13;
      // W7. Search backwards from each instance of a European number&#13;
      // until the first strong type (R, L, or sor) is found. If an L is&#13;
      // found, then change the type of the European number to L.&#13;
      for (var i = 0, cur = outerType; i &lt; len; ++i) {&#13;
        var type = types[i];&#13;
        if (cur == "L" &amp;&amp; type == "1") types[i] = "L";&#13;
        else if (isStrong.test(type)) cur = type;&#13;
      }&#13;
&#13;
      // N1. A sequence of neutrals takes the direction of the&#13;
      // surrounding strong text if the text on both sides has the same&#13;
      // direction. European and Arabic numbers act as if they were R in&#13;
      // terms of their influence on neutrals. Start-of-level-run (sor)&#13;
      // and end-of-level-run (eor) are used at level run boundaries.&#13;
      // N2. Any remaining neutrals take the embedding direction.&#13;
      for (var i = 0; i &lt; len; ++i) {&#13;
        if (isNeutral.test(types[i])) {&#13;
          for (var end = i + 1; end &lt; len &amp;&amp; isNeutral.test(types[end]); ++end) {}&#13;
          var before = (i ? types[i-1] : outerType) == "L";&#13;
          var after = (end &lt; len ? types[end] : outerType) == "L";&#13;
          var replace = before || after ? "L" : "R";&#13;
          for (var j = i; j &lt; end; ++j) types[j] = replace;&#13;
          i = end - 1;&#13;
        }&#13;
      }&#13;
&#13;
      // Here we depart from the documented algorithm, in order to avoid&#13;
      // building up an actual levels array. Since there are only three&#13;
      // levels (0, 1, 2) in an implementation that doesn't take&#13;
      // explicit embedding into account, we can build up the order on&#13;
      // the fly, without following the level-based algorithm.&#13;
      var order = [], m;&#13;
      for (var i = 0; i &lt; len;) {&#13;
        if (countsAsLeft.test(types[i])) {&#13;
          var start = i;&#13;
          for (++i; i &lt; len &amp;&amp; countsAsLeft.test(types[i]); ++i) {}&#13;
          order.push(new BidiSpan(0, start, i));&#13;
        } else {&#13;
          var pos = i, at = order.length;&#13;
          for (++i; i &lt; len &amp;&amp; types[i] != "L"; ++i) {}&#13;
          for (var j = pos; j &lt; i;) {&#13;
            if (countsAsNum.test(types[j])) {&#13;
              if (pos &lt; j) order.splice(at, 0, new BidiSpan(1, pos, j));&#13;
              var nstart = j;&#13;
              for (++j; j &lt; i &amp;&amp; countsAsNum.test(types[j]); ++j) {}&#13;
              order.splice(at, 0, new BidiSpan(2, nstart, j));&#13;
              pos = j;&#13;
            } else ++j;&#13;
          }&#13;
          if (pos &lt; i) order.splice(at, 0, new BidiSpan(1, pos, i));&#13;
        }&#13;
      }&#13;
      if (order[0].level == 1 &amp;&amp; (m = str.match(/^\s+/))) {&#13;
        order[0].from = m[0].length;&#13;
        order.unshift(new BidiSpan(0, 0, m[0].length));&#13;
      }&#13;
      if (lst(order).level == 1 &amp;&amp; (m = str.match(/\s+$/))) {&#13;
        lst(order).to -= m[0].length;&#13;
        order.push(new BidiSpan(0, len - m[0].length, len));&#13;
      }&#13;
      if (order[0].level == 2)&#13;
        order.unshift(new BidiSpan(1, order[0].to, order[0].to));&#13;
      if (order[0].level != lst(order).level)&#13;
        order.push(new BidiSpan(order[0].level, len, len));&#13;
&#13;
      return order;&#13;
    };&#13;
  })();&#13;
&#13;
  // THE END&#13;
&#13;
  CodeMirror.version = "5.15.2";&#13;
&#13;
  return CodeMirror;&#13;
});&#13;
&#13;
},{}],11:[function(require,module,exports){&#13;
// CodeMirror, copyright (c) by Marijn Haverbeke and others&#13;
// Distributed under an MIT license: http://codemirror.net/LICENSE&#13;
&#13;
(function(mod) {&#13;
  if (typeof exports == "object" &amp;&amp; typeof module == "object") // CommonJS&#13;
    mod(require("../../lib/codemirror"), require("../markdown/markdown"), require("../../addon/mode/overlay"));&#13;
  else if (typeof define == "function" &amp;&amp; define.amd) // AMD&#13;
    define(["../../lib/codemirror", "../markdown/markdown", "../../addon/mode/overlay"], mod);&#13;
  else // Plain browser env&#13;
    mod(CodeMirror);&#13;
})(function(CodeMirror) {&#13;
"use strict";&#13;
&#13;
var urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()&lt;&gt;]|\([^\s()&lt;&gt;]*\))+(?:\([^\s()&lt;&gt;]*\)|[^\s`*!()\[\]{};:'".,&lt;&gt;?""'']))/i&#13;
&#13;
CodeMirror.defineMode("gfm", function(config, modeConfig) {&#13;
  var codeDepth = 0;&#13;
  function blankLine(state) {&#13;
    state.code = false;&#13;
    return null;&#13;
  }&#13;
  var gfmOverlay = {&#13;
    startState: function() {&#13;
      return {&#13;
        code: false,&#13;
        codeBlock: false,&#13;
        ateSpace: false&#13;
      };&#13;
    },&#13;
    copyState: function(s) {&#13;
      return {&#13;
        code: s.code,&#13;
        codeBlock: s.codeBlock,&#13;
        ateSpace: s.ateSpace&#13;
      };&#13;
    },&#13;
    token: function(stream, state) {&#13;
      state.combineTokens = null;&#13;
&#13;
      // Hack to prevent formatting override inside code blocks (block and inline)&#13;
      if (state.codeBlock) {&#13;
        if (stream.match(/^```+/)) {&#13;
          state.codeBlock = false;&#13;
          return null;&#13;
        }&#13;
        stream.skipToEnd();&#13;
        return null;&#13;
      }&#13;
      if (stream.sol()) {&#13;
        state.code = false;&#13;
      }&#13;
      if (stream.sol() &amp;&amp; stream.match(/^```+/)) {&#13;
        stream.skipToEnd();&#13;
        state.codeBlock = true;&#13;
        return null;&#13;
      }&#13;
      // If this block is changed, it may need to be updated in Markdown mode&#13;
      if (stream.peek() === '`') {&#13;
        stream.next();&#13;
        var before = stream.pos;&#13;
        stream.eatWhile('`');&#13;
        var difference = 1 + stream.pos - before;&#13;
        if (!state.code) {&#13;
          codeDepth = difference;&#13;
          state.code = true;&#13;
        } else {&#13;
          if (difference === codeDepth) { // Must be exact&#13;
            state.code = false;&#13;
          }&#13;
        }&#13;
        return null;&#13;
      } else if (state.code) {&#13;
        stream.next();&#13;
        return null;&#13;
      }&#13;
      // Check if space. If so, links can be formatted later on&#13;
      if (stream.eatSpace()) {&#13;
        state.ateSpace = true;&#13;
        return null;&#13;
      }&#13;
      if (stream.sol() || state.ateSpace) {&#13;
        state.ateSpace = false;&#13;
        if (modeConfig.gitHubSpice !== false) {&#13;
          if(stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?:[a-f0-9]{7,40}\b)/)) {&#13;
            // User/Project@SHA&#13;
            // User@SHA&#13;
            // SHA&#13;
            state.combineTokens = true;&#13;
            return "link";&#13;
          } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {&#13;
            // User/Project#Num&#13;
            // User#Num&#13;
            // #Num&#13;
            state.combineTokens = true;&#13;
            return "link";&#13;
          }&#13;
        }&#13;
      }&#13;
      if (stream.match(urlRE) &amp;&amp;&#13;
          stream.string.slice(stream.start - 2, stream.start) != "](" &amp;&amp;&#13;
          (stream.start == 0 || /\W/.test(stream.string.charAt(stream.start - 1)))) {&#13;
        // URLs&#13;
        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls&#13;
        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine&#13;
        // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL&#13;
        state.combineTokens = true;&#13;
        return "link";&#13;
      }&#13;
      stream.next();&#13;
      return null;&#13;
    },&#13;
    blankLine: blankLine&#13;
  };&#13;
&#13;
  var markdownConfig = {&#13;
    underscoresBreakWords: false,&#13;
    taskLists: true,&#13;
    fencedCodeBlocks: '```',&#13;
    strikethrough: true&#13;
  };&#13;
  for (var attr in modeConfig) {&#13;
    markdownConfig[attr] = modeConfig[attr];&#13;
  }&#13;
  markdownConfig.name = "markdown";&#13;
  return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);&#13;
&#13;
}, "markdown");&#13;
&#13;
  CodeMirror.defineMIME("text/x-gfm", "gfm");&#13;
});&#13;
&#13;
},{"../../addon/mode/overlay":8,"../../lib/codemirror":10,"../markdown/markdown":12}],12:[function(require,module,exports){&#13;
// CodeMirror, copyright (c) by Marijn Haverbeke and others&#13;
// Distributed under an MIT license: http://codemirror.net/LICENSE&#13;
&#13;
(function(mod) {&#13;
  if (typeof exports == "object" &amp;&amp; typeof module == "object") // CommonJS&#13;
    mod(require("../../lib/codemirror"), require("../xml/xml"), require("../meta"));&#13;
  else if (typeof define == "function" &amp;&amp; define.amd) // AMD&#13;
    define(["../../lib/codemirror", "../xml/xml", "../meta"], mod);&#13;
  else // Plain browser env&#13;
    mod(CodeMirror);&#13;
})(function(CodeMirror) {&#13;
"use strict";&#13;
&#13;
CodeMirror.defineMode("markdown", function(cmCfg, modeCfg) {&#13;
&#13;
  var htmlMode = CodeMirror.getMode(cmCfg, "text/html");&#13;
  var htmlModeMissing = htmlMode.name == "null"&#13;
&#13;
  function getMode(name) {&#13;
    if (CodeMirror.findModeByName) {&#13;
      var found = CodeMirror.findModeByName(name);&#13;
      if (found) name = found.mime || found.mimes[0];&#13;
    }&#13;
    var mode = CodeMirror.getMode(cmCfg, name);&#13;
    return mode.name == "null" ? null : mode;&#13;
  }&#13;
&#13;
  // Should characters that affect highlighting be highlighted separate?&#13;
  // Does not include characters that will be output (such as `1.` and `-` for lists)&#13;
  if (modeCfg.highlightFormatting === undefined)&#13;
    modeCfg.highlightFormatting = false;&#13;
&#13;
  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.&#13;
  // Excess `&gt;` will emit `error` token.&#13;
  if (modeCfg.maxBlockquoteDepth === undefined)&#13;
    modeCfg.maxBlockquoteDepth = 0;&#13;
&#13;
  // Should underscores in words open/close em/strong?&#13;
  if (modeCfg.underscoresBreakWords === undefined)&#13;
    modeCfg.underscoresBreakWords = true;&#13;
&#13;
  // Use `fencedCodeBlocks` to configure fenced code blocks. false to&#13;
  // disable, string to specify a precise regexp that the fence should&#13;
  // match, and true to allow three or more backticks or tildes (as&#13;
  // per CommonMark).&#13;
&#13;
  // Turn on task lists? ("- [ ] " and "- [x] ")&#13;
  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;&#13;
&#13;
  // Turn on strikethrough syntax&#13;
  if (modeCfg.strikethrough === undefined)&#13;
    modeCfg.strikethrough = false;&#13;
&#13;
  // Allow token types to be overridden by user-provided token types.&#13;
  if (modeCfg.tokenTypeOverrides === undefined)&#13;
    modeCfg.tokenTypeOverrides = {};&#13;
&#13;
  var tokenTypes = {&#13;
    header: "header",&#13;
    code: "comment",&#13;
    quote: "quote",&#13;
    list1: "variable-2",&#13;
    list2: "variable-3",&#13;
    list3: "keyword",&#13;
    hr: "hr",&#13;
    image: "tag",&#13;
    formatting: "formatting",&#13;
    linkInline: "link",&#13;
    linkEmail: "link",&#13;
    linkText: "link",&#13;
    linkHref: "string",&#13;
    em: "em",&#13;
    strong: "strong",&#13;
    strikethrough: "strikethrough"&#13;
  };&#13;
&#13;
  for (var tokenType in tokenTypes) {&#13;
    if (tokenTypes.hasOwnProperty(tokenType) &amp;&amp; modeCfg.tokenTypeOverrides[tokenType]) {&#13;
      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];&#13;
    }&#13;
  }&#13;
&#13;
  var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/&#13;
  ,   ulRE = /^[*\-+]\s+/&#13;
  ,   olRE = /^[0-9]+([.)])\s+/&#13;
  ,   taskListRE = /^\[(x| )\](?=\s)/ // Must follow ulRE or olRE&#13;
  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/&#13;
  ,   setextHeaderRE = /^ *(?:\={1,}|-{1,})\s*$/&#13;
  ,   textRE = /^[^#!\[\]*_\\&lt;&gt;` "'(~]+/&#13;
  ,   fencedCodeRE = new RegExp("^(" + (modeCfg.fencedCodeBlocks === true ? "~~~+|```+" : modeCfg.fencedCodeBlocks) +&#13;
                                ")[ \\t]*([\\w+#\-]*)");&#13;
&#13;
  function switchInline(stream, state, f) {&#13;
    state.f = state.inline = f;&#13;
    return f(stream, state);&#13;
  }&#13;
&#13;
  function switchBlock(stream, state, f) {&#13;
    state.f = state.block = f;&#13;
    return f(stream, state);&#13;
  }&#13;
&#13;
  function lineIsEmpty(line) {&#13;
    return !line || !/\S/.test(line.string)&#13;
  }&#13;
&#13;
  // Blocks&#13;
&#13;
  function blankLine(state) {&#13;
    // Reset linkTitle state&#13;
    state.linkTitle = false;&#13;
    // Reset EM state&#13;
    state.em = false;&#13;
    // Reset STRONG state&#13;
    state.strong = false;&#13;
    // Reset strikethrough state&#13;
    state.strikethrough = false;&#13;
    // Reset state.quote&#13;
    state.quote = 0;&#13;
    // Reset state.indentedCode&#13;
    state.indentedCode = false;&#13;
    if (htmlModeMissing &amp;&amp; state.f == htmlBlock) {&#13;
      state.f = inlineNormal;&#13;
      state.block = blockNormal;&#13;
    }&#13;
    // Reset state.trailingSpace&#13;
    state.trailingSpace = 0;&#13;
    state.trailingSpaceNewLine = false;&#13;
    // Mark this line as blank&#13;
    state.prevLine = state.thisLine&#13;
    state.thisLine = null&#13;
    return null;&#13;
  }&#13;
&#13;
  function blockNormal(stream, state) {&#13;
&#13;
    var sol = stream.sol();&#13;
&#13;
    var prevLineIsList = state.list !== false,&#13;
        prevLineIsIndentedCode = state.indentedCode;&#13;
&#13;
    state.indentedCode = false;&#13;
&#13;
    if (prevLineIsList) {&#13;
      if (state.indentationDiff &gt;= 0) { // Continued list&#13;
        if (state.indentationDiff &lt; 4) { // Only adjust indentation if *not* a code block&#13;
          state.indentation -= state.indentationDiff;&#13;
        }&#13;
        state.list = null;&#13;
      } else if (state.indentation &gt; 0) {&#13;
        state.list = null;&#13;
      } else { // No longer a list&#13;
        state.list = false;&#13;
      }&#13;
    }&#13;
&#13;
    var match = null;&#13;
    if (state.indentationDiff &gt;= 4) {&#13;
      stream.skipToEnd();&#13;
      if (prevLineIsIndentedCode || lineIsEmpty(state.prevLine)) {&#13;
        state.indentation -= 4;&#13;
        state.indentedCode = true;&#13;
        return tokenTypes.code;&#13;
      } else {&#13;
        return null;&#13;
      }&#13;
    } else if (stream.eatSpace()) {&#13;
      return null;&#13;
    } else if ((match = stream.match(atxHeaderRE)) &amp;&amp; match[1].length &lt;= 6) {&#13;
      state.header = match[1].length;&#13;
      if (modeCfg.highlightFormatting) state.formatting = "header";&#13;
      state.f = state.inline;&#13;
      return getType(state);&#13;
    } else if (!lineIsEmpty(state.prevLine) &amp;&amp; !state.quote &amp;&amp; !prevLineIsList &amp;&amp;&#13;
               !prevLineIsIndentedCode &amp;&amp; (match = stream.match(setextHeaderRE))) {&#13;
      state.header = match[0].charAt(0) == '=' ? 1 : 2;&#13;
      if (modeCfg.highlightFormatting) state.formatting = "header";&#13;
      state.f = state.inline;&#13;
      return getType(state);&#13;
    } else if (stream.eat('&gt;')) {&#13;
      state.quote = sol ? 1 : state.quote + 1;&#13;
      if (modeCfg.highlightFormatting) state.formatting = "quote";&#13;
      stream.eatSpace();&#13;
      return getType(state);&#13;
    } else if (stream.peek() === '[') {&#13;
      return switchInline(stream, state, footnoteLink);&#13;
    } else if (stream.match(hrRE, true)) {&#13;
      state.hr = true;&#13;
      return tokenTypes.hr;&#13;
    } else if ((lineIsEmpty(state.prevLine) || prevLineIsList) &amp;&amp; (stream.match(ulRE, false) || stream.match(olRE, false))) {&#13;
      var listType = null;&#13;
      if (stream.match(ulRE, true)) {&#13;
        listType = 'ul';&#13;
      } else {&#13;
        stream.match(olRE, true);&#13;
        listType = 'ol';&#13;
      }&#13;
      state.indentation = stream.column() + stream.current().length;&#13;
      state.list = true;&#13;
&#13;
      // While this list item's marker's indentation&#13;
      // is less than the deepest list item's content's indentation,&#13;
      // pop the deepest list item indentation off the stack.&#13;
      while (state.listStack &amp;&amp; stream.column() &lt; state.listStack[state.listStack.length - 1]) {&#13;
        state.listStack.pop();&#13;
      }&#13;
&#13;
      // Add this list item's content's indentation to the stack&#13;
      state.listStack.push(state.indentation);&#13;
&#13;
      if (modeCfg.taskLists &amp;&amp; stream.match(taskListRE, false)) {&#13;
        state.taskList = true;&#13;
      }&#13;
      state.f = state.inline;&#13;
      if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];&#13;
      return getType(state);&#13;
    } else if (modeCfg.fencedCodeBlocks &amp;&amp; (match = stream.match(fencedCodeRE, true))) {&#13;
      state.fencedChars = match[1]&#13;
      // try switching mode&#13;
      state.localMode = getMode(match[2]);&#13;
      if (state.localMode) state.localState = CodeMirror.startState(state.localMode);&#13;
      state.f = state.block = local;&#13;
      if (modeCfg.highlightFormatting) state.formatting = "code-block";&#13;
      state.code = -1&#13;
      return getType(state);&#13;
    }&#13;
&#13;
    return switchInline(stream, state, state.inline);&#13;
  }&#13;
&#13;
  function htmlBlock(stream, state) {&#13;
    var style = htmlMode.token(stream, state.htmlState);&#13;
    if (!htmlModeMissing) {&#13;
      var inner = CodeMirror.innerMode(htmlMode, state.htmlState)&#13;
      if ((inner.mode.name == "xml" &amp;&amp; inner.state.tagStart === null &amp;&amp;&#13;
           (!inner.state.context &amp;&amp; inner.state.tokenize.isInText)) ||&#13;
          (state.md_inside &amp;&amp; stream.current().indexOf("&gt;") &gt; -1)) {&#13;
        state.f = inlineNormal;&#13;
        state.block = blockNormal;&#13;
        state.htmlState = null;&#13;
      }&#13;
    }&#13;
    return style;&#13;
  }&#13;
&#13;
  function local(stream, state) {&#13;
    if (state.fencedChars &amp;&amp; stream.match(state.fencedChars, false)) {&#13;
      state.localMode = state.localState = null;&#13;
      state.f = state.block = leavingLocal;&#13;
      return null;&#13;
    } else if (state.localMode) {&#13;
      return state.localMode.token(stream, state.localState);&#13;
    } else {&#13;
      stream.skipToEnd();&#13;
      return tokenTypes.code;&#13;
    }&#13;
  }&#13;
&#13;
  function leavingLocal(stream, state) {&#13;
    stream.match(state.fencedChars);&#13;
    state.block = blockNormal;&#13;
    state.f = inlineNormal;&#13;
    state.fencedChars = null;&#13;
    if (modeCfg.highlightFormatting) state.formatting = "code-block";&#13;
    state.code = 1&#13;
    var returnType = getType(state);&#13;
    state.code = 0&#13;
    return returnType;&#13;
  }&#13;
&#13;
  // Inline&#13;
  function getType(state) {&#13;
    var styles = [];&#13;
&#13;
    if (state.formatting) {&#13;
      styles.push(tokenTypes.formatting);&#13;
&#13;
      if (typeof state.formatting === "string") state.formatting = [state.formatting];&#13;
&#13;
      for (var i = 0; i &lt; state.formatting.length; i++) {&#13;
        styles.push(tokenTypes.formatting + "-" + state.formatting[i]);&#13;
&#13;
        if (state.formatting[i] === "header") {&#13;
          styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.header);&#13;
        }&#13;
&#13;
        // Add `formatting-quote` and `formatting-quote-#` for blockquotes&#13;
        // Add `error` instead if the maximum blockquote nesting depth is passed&#13;
        if (state.formatting[i] === "quote") {&#13;
          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth &gt;= state.quote) {&#13;
            styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.quote);&#13;
          } else {&#13;
            styles.push("error");&#13;
          }&#13;
        }&#13;
      }&#13;
    }&#13;
&#13;
    if (state.taskOpen) {&#13;
      styles.push("meta");&#13;
      return styles.length ? styles.join(' ') : null;&#13;
    }&#13;
    if (state.taskClosed) {&#13;
      styles.push("property");&#13;
      return styles.length ? styles.join(' ') : null;&#13;
    }&#13;
&#13;
    if (state.linkHref) {&#13;
      styles.push(tokenTypes.linkHref, "url");&#13;
    } else { // Only apply inline styles to non-url text&#13;
      if (state.strong) { styles.push(tokenTypes.strong); }&#13;
      if (state.em) { styles.push(tokenTypes.em); }&#13;
      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }&#13;
      if (state.linkText) { styles.push(tokenTypes.linkText); }&#13;
      if (state.code) { styles.push(tokenTypes.code); }&#13;
    }&#13;
&#13;
    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header); }&#13;
&#13;
    if (state.quote) {&#13;
      styles.push(tokenTypes.quote);&#13;
&#13;
      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth&#13;
      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth &gt;= state.quote) {&#13;
        styles.push(tokenTypes.quote + "-" + state.quote);&#13;
      } else {&#13;
        styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);&#13;
      }&#13;
    }&#13;
&#13;
    if (state.list !== false) {&#13;
      var listMod = (state.listStack.length - 1) % 3;&#13;
      if (!listMod) {&#13;
        styles.push(tokenTypes.list1);&#13;
      } else if (listMod === 1) {&#13;
        styles.push(tokenTypes.list2);&#13;
      } else {&#13;
        styles.push(tokenTypes.list3);&#13;
      }&#13;
    }&#13;
&#13;
    if (state.trailingSpaceNewLine) {&#13;
      styles.push("trailing-space-new-line");&#13;
    } else if (state.trailingSpace) {&#13;
      styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));&#13;
    }&#13;
&#13;
    return styles.length ? styles.join(' ') : null;&#13;
  }&#13;
&#13;
  function handleText(stream, state) {&#13;
    if (stream.match(textRE, true)) {&#13;
      return getType(state);&#13;
    }&#13;
    return undefined;&#13;
  }&#13;
&#13;
  function inlineNormal(stream, state) {&#13;
    var style = state.text(stream, state);&#13;
    if (typeof style !== 'undefined')&#13;
      return style;&#13;
&#13;
    if (state.list) { // List marker (*, +, -, 1., etc)&#13;
      state.list = null;&#13;
      return getType(state);&#13;
    }&#13;
&#13;
    if (state.taskList) {&#13;
      var taskOpen = stream.match(taskListRE, true)[1] !== "x";&#13;
      if (taskOpen) state.taskOpen = true;&#13;
      else state.taskClosed = true;&#13;
      if (modeCfg.highlightFormatting) state.formatting = "task";&#13;
      state.taskList = false;&#13;
      return getType(state);&#13;
    }&#13;
&#13;
    state.taskOpen = false;&#13;
    state.taskClosed = false;&#13;
&#13;
    if (state.header &amp;&amp; stream.match(/^#+$/, true)) {&#13;
      if (modeCfg.highlightFormatting) state.formatting = "header";&#13;
      return getType(state);&#13;
    }&#13;
&#13;
    // Get sol() value now, before character is consumed&#13;
    var sol = stream.sol();&#13;
&#13;
    var ch = stream.next();&#13;
&#13;
    // Matches link titles present on next line&#13;
    if (state.linkTitle) {&#13;
      state.linkTitle = false;&#13;
      var matchCh = ch;&#13;
      if (ch === '(') {&#13;
        matchCh = ')';&#13;
      }&#13;
      matchCh = (matchCh+'').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");&#13;
      var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;&#13;
      if (stream.match(new RegExp(regex), true)) {&#13;
        return tokenTypes.linkHref;&#13;
      }&#13;
    }&#13;
&#13;
    // If this block is changed, it may need to be updated in GFM mode&#13;
    if (ch === '`') {&#13;
      var previousFormatting = state.formatting;&#13;
      if (modeCfg.highlightFormatting) state.formatting = "code";&#13;
      stream.eatWhile('`');&#13;
      var count = stream.current().length&#13;
      if (state.code == 0) {&#13;
        state.code = count&#13;
        return getType(state)&#13;
      } else if (count == state.code) { // Must be exact&#13;
        var t = getType(state)&#13;
        state.code = 0&#13;
        return t&#13;
      } else {&#13;
        state.formatting = previousFormatting&#13;
        return getType(state)&#13;
      }&#13;
    } else if (state.code) {&#13;
      return getType(state);&#13;
    }&#13;
&#13;
    if (ch === '\\') {&#13;
      stream.next();&#13;
      if (modeCfg.highlightFormatting) {&#13;
        var type = getType(state);&#13;
        var formattingEscape = tokenTypes.formatting + "-escape";&#13;
        return type ? type + " " + formattingEscape : formattingEscape;&#13;
      }&#13;
    }&#13;
&#13;
    if (ch === '!' &amp;&amp; stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {&#13;
      stream.match(/\[[^\]]*\]/);&#13;
      state.inline = state.f = linkHref;&#13;
      return tokenTypes.image;&#13;
    }&#13;
&#13;
    if (ch === '[' &amp;&amp; stream.match(/[^\]]*\](\(.*\)| ?\[.*?\])/, false)) {&#13;
      state.linkText = true;&#13;
      if (modeCfg.highlightFormatting) state.formatting = "link";&#13;
      return getType(state);&#13;
    }&#13;
&#13;
    if (ch === ']' &amp;&amp; state.linkText &amp;&amp; stream.match(/\(.*?\)| ?\[.*?\]/, false)) {&#13;
      if (modeCfg.highlightFormatting) state.formatting = "link";&#13;
      var type = getType(state);&#13;
      state.linkText = false;&#13;
      state.inline = state.f = linkHref;&#13;
      return type;&#13;
    }&#13;
&#13;
    if (ch === '&lt;' &amp;&amp; stream.match(/^(https?|ftps?):\/\/(?:[^\\&gt;]|\\.)+&gt;/, false)) {&#13;
      state.f = state.inline = linkInline;&#13;
      if (modeCfg.highlightFormatting) state.formatting = "link";&#13;
      var type = getType(state);&#13;
      if (type){&#13;
        type += " ";&#13;
      } else {&#13;
        type = "";&#13;
      }&#13;
      return type + tokenTypes.linkInline;&#13;
    }&#13;
&#13;
    if (ch === '&lt;' &amp;&amp; stream.match(/^[^&gt; \\]+@(?:[^\\&gt;]|\\.)+&gt;/, false)) {&#13;
      state.f = state.inline = linkInline;&#13;
      if (modeCfg.highlightFormatting) state.formatting = "link";&#13;
      var type = getType(state);&#13;
      if (type){&#13;
        type += " ";&#13;
      } else {&#13;
        type = "";&#13;
      }&#13;
      return type + tokenTypes.linkEmail;&#13;
    }&#13;
&#13;
    if (ch === '&lt;' &amp;&amp; stream.match(/^(!--|\w)/, false)) {&#13;
      var end = stream.string.indexOf("&gt;", stream.pos);&#13;
      if (end != -1) {&#13;
        var atts = stream.string.substring(stream.start, end);&#13;
        if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) state.md_inside = true;&#13;
      }&#13;
      stream.backUp(1);&#13;
      state.htmlState = CodeMirror.startState(htmlMode);&#13;
      return switchBlock(stream, state, htmlBlock);&#13;
    }&#13;
&#13;
    if (ch === '&lt;' &amp;&amp; stream.match(/^\/\w*?&gt;/)) {&#13;
      state.md_inside = false;&#13;
      return "tag";&#13;
    }&#13;
&#13;
    var ignoreUnderscore = false;&#13;
    if (!modeCfg.underscoresBreakWords) {&#13;
      if (ch === '_' &amp;&amp; stream.peek() !== '_' &amp;&amp; stream.match(/(\w)/, false)) {&#13;
        var prevPos = stream.pos - 2;&#13;
        if (prevPos &gt;= 0) {&#13;
          var prevCh = stream.string.charAt(prevPos);&#13;
          if (prevCh !== '_' &amp;&amp; prevCh.match(/(\w)/, false)) {&#13;
            ignoreUnderscore = true;&#13;
          }&#13;
        }&#13;
      }&#13;
    }&#13;
    if (ch === '*' || (ch === '_' &amp;&amp; !ignoreUnderscore)) {&#13;
      if (sol &amp;&amp; stream.peek() === ' ') {&#13;
        // Do nothing, surrounded by newline and space&#13;
      } else if (state.strong === ch &amp;&amp; stream.eat(ch)) { // Remove STRONG&#13;
        if (modeCfg.highlightFormatting) state.formatting = "strong";&#13;
        var t = getType(state);&#13;
        state.strong = false;&#13;
        return t;&#13;
      } else if (!state.strong &amp;&amp; stream.eat(ch)) { // Add STRONG&#13;
        state.strong = ch;&#13;
        if (modeCfg.highlightFormatting) state.formatting = "strong";&#13;
        return getType(state);&#13;
      } else if (state.em === ch) { // Remove EM&#13;
        if (modeCfg.highlightFormatting) state.formatting = "em";&#13;
        var t = getType(state);&#13;
        state.em = false;&#13;
        return t;&#13;
      } else if (!state.em) { // Add EM&#13;
        state.em = ch;&#13;
        if (modeCfg.highlightFormatting) state.formatting = "em";&#13;
        return getType(state);&#13;
      }&#13;
    } else if (ch === ' ') {&#13;
      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces&#13;
        if (stream.peek() === ' ') { // Surrounded by spaces, ignore&#13;
          return getType(state);&#13;
        } else { // Not surrounded by spaces, back up pointer&#13;
          stream.backUp(1);&#13;
        }&#13;
      }&#13;
    }&#13;
&#13;
    if (modeCfg.strikethrough) {&#13;
      if (ch === '~' &amp;&amp; stream.eatWhile(ch)) {&#13;
        if (state.strikethrough) {// Remove strikethrough&#13;
          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";&#13;
          var t = getType(state);&#13;
          state.strikethrough = false;&#13;
          return t;&#13;
        } else if (stream.match(/^[^\s]/, false)) {// Add strikethrough&#13;
          state.strikethrough = true;&#13;
          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";&#13;
          return getType(state);&#13;
        }&#13;
      } else if (ch === ' ') {&#13;
        if (stream.match(/^~~/, true)) { // Probably surrounded by space&#13;
          if (stream.peek() === ' ') { // Surrounded by spaces, ignore&#13;
            return getType(state);&#13;
          } else { // Not surrounded by spaces, back up pointer&#13;
            stream.backUp(2);&#13;
          }&#13;
        }&#13;
      }&#13;
    }&#13;
&#13;
    if (ch === ' ') {&#13;
      if (stream.match(/ +$/, false)) {&#13;
        state.trailingSpace++;&#13;
      } else if (state.trailingSpace) {&#13;
        state.trailingSpaceNewLine = true;&#13;
      }&#13;
    }&#13;
&#13;
    return getType(state);&#13;
  }&#13;
&#13;
  function linkInline(stream, state) {&#13;
    var ch = stream.next();&#13;
&#13;
    if (ch === "&gt;") {&#13;
      state.f = state.inline = inlineNormal;&#13;
      if (modeCfg.highlightFormatting) state.formatting = "link";&#13;
      var type = getType(state);&#13;
      if (type){&#13;
        type += " ";&#13;
      } else {&#13;
        type = "";&#13;
      }&#13;
      return type + tokenTypes.linkInline;&#13;
    }&#13;
&#13;
    stream.match(/^[^&gt;]+/, true);&#13;
&#13;
    return tokenTypes.linkInline;&#13;
  }&#13;
&#13;
  function linkHref(stream, state) {&#13;
    // Check if space, and return NULL if so (to avoid marking the space)&#13;
    if(stream.eatSpace()){&#13;
      return null;&#13;
    }&#13;
    var ch = stream.next();&#13;
    if (ch === '(' || ch === '[') {&#13;
      state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]", 0);&#13;
      if (modeCfg.highlightFormatting) state.formatting = "link-string";&#13;
      state.linkHref = true;&#13;
      return getType(state);&#13;
    }&#13;
    return 'error';&#13;
  }&#13;
&#13;
  var linkRE = {&#13;
    ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,&#13;
    "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\\]]|\\.)*\])*?(?=\])/&#13;
  }&#13;
&#13;
  function getLinkHrefInside(endChar) {&#13;
    return function(stream, state) {&#13;
      var ch = stream.next();&#13;
&#13;
      if (ch === endChar) {&#13;
        state.f = state.inline = inlineNormal;&#13;
        if (modeCfg.highlightFormatting) state.formatting = "link-string";&#13;
        var returnState = getType(state);&#13;
        state.linkHref = false;&#13;
        return returnState;&#13;
      }&#13;
&#13;
      stream.match(linkRE[endChar])&#13;
      state.linkHref = true;&#13;
      return getType(state);&#13;
    };&#13;
  }&#13;
&#13;
  function footnoteLink(stream, state) {&#13;
    if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {&#13;
      state.f = footnoteLinkInside;&#13;
      stream.next(); // Consume [&#13;
      if (modeCfg.highlightFormatting) state.formatting = "link";&#13;
      state.linkText = true;&#13;
      return getType(state);&#13;
    }&#13;
    return switchInline(stream, state, inlineNormal);&#13;
  }&#13;
&#13;
  function footnoteLinkInside(stream, state) {&#13;
    if (stream.match(/^\]:/, true)) {&#13;
      state.f = state.inline = footnoteUrl;&#13;
      if (modeCfg.highlightFormatting) state.formatting = "link";&#13;
      var returnType = getType(state);&#13;
      state.linkText = false;&#13;
      return returnType;&#13;
    }&#13;
&#13;
    stream.match(/^([^\]\\]|\\.)+/, true);&#13;
&#13;
    return tokenTypes.linkText;&#13;
  }&#13;
&#13;
  function footnoteUrl(stream, state) {&#13;
    // Check if space, and return NULL if so (to avoid marking the space)&#13;
    if(stream.eatSpace()){&#13;
      return null;&#13;
    }&#13;
    // Match URL&#13;
    stream.match(/^[^\s]+/, true);&#13;
    // Check for link title&#13;
    if (stream.peek() === undefined) { // End of line, set flag to check next line&#13;
      state.linkTitle = true;&#13;
    } else { // More content on line, check if link title&#13;
      stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);&#13;
    }&#13;
    state.f = state.inline = inlineNormal;&#13;
    return tokenTypes.linkHref + " url";&#13;
  }&#13;
&#13;
  var mode = {&#13;
    startState: function() {&#13;
      return {&#13;
        f: blockNormal,&#13;
&#13;
        prevLine: null,&#13;
        thisLine: null,&#13;
&#13;
        block: blockNormal,&#13;
        htmlState: null,&#13;
        indentation: 0,&#13;
&#13;
        inline: inlineNormal,&#13;
        text: handleText,&#13;
&#13;
        formatting: false,&#13;
        linkText: false,&#13;
        linkHref: false,&#13;
        linkTitle: false,&#13;
        code: 0,&#13;
        em: false,&#13;
        strong: false,&#13;
        header: 0,&#13;
        hr: false,&#13;
        taskList: false,&#13;
        list: false,&#13;
        listStack: [],&#13;
        quote: 0,&#13;
        trailingSpace: 0,&#13;
        trailingSpaceNewLine: false,&#13;
        strikethrough: false,&#13;
        fencedChars: null&#13;
      };&#13;
    },&#13;
&#13;
    copyState: function(s) {&#13;
      return {&#13;
        f: s.f,&#13;
&#13;
        prevLine: s.prevLine,&#13;
        thisLine: s.thisLine,&#13;
&#13;
        block: s.block,&#13;
        htmlState: s.htmlState &amp;&amp; CodeMirror.copyState(htmlMode, s.htmlState),&#13;
        indentation: s.indentation,&#13;
&#13;
        localMode: s.localMode,&#13;
        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,&#13;
&#13;
        inline: s.inline,&#13;
        text: s.text,&#13;
        formatting: false,&#13;
        linkTitle: s.linkTitle,&#13;
        code: s.code,&#13;
        em: s.em,&#13;
        strong: s.strong,&#13;
        strikethrough: s.strikethrough,&#13;
        header: s.header,&#13;
        hr: s.hr,&#13;
        taskList: s.taskList,&#13;
        list: s.list,&#13;
        listStack: s.listStack.slice(0),&#13;
        quote: s.quote,&#13;
        indentedCode: s.indentedCode,&#13;
        trailingSpace: s.trailingSpace,&#13;
        trailingSpaceNewLine: s.trailingSpaceNewLine,&#13;
        md_inside: s.md_inside,&#13;
        fencedChars: s.fencedChars&#13;
      };&#13;
    },&#13;
&#13;
    token: function(stream, state) {&#13;
&#13;
      // Reset state.formatting&#13;
      state.formatting = false;&#13;
&#13;
      if (stream != state.thisLine) {&#13;
        var forceBlankLine = state.header || state.hr;&#13;
&#13;
        // Reset state.header and state.hr&#13;
        state.header = 0;&#13;
        state.hr = false;&#13;
&#13;
        if (stream.match(/^\s*$/, true) || forceBlankLine) {&#13;
          blankLine(state);&#13;
          if (!forceBlankLine) return null&#13;
          state.prevLine = null&#13;
        }&#13;
&#13;
        state.prevLine = state.thisLine&#13;
        state.thisLine = stream&#13;
&#13;
        // Reset state.taskList&#13;
        state.taskList = false;&#13;
&#13;
        // Reset state.trailingSpace&#13;
        state.trailingSpace = 0;&#13;
        state.trailingSpaceNewLine = false;&#13;
&#13;
        state.f = state.block;&#13;
        var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, '    ').length;&#13;
        state.indentationDiff = Math.min(indentation - state.indentation, 4);&#13;
        state.indentation = state.indentation + state.indentationDiff;&#13;
        if (indentation &gt; 0) return null;&#13;
      }&#13;
      return state.f(stream, state);&#13;
    },&#13;
&#13;
    innerMode: function(state) {&#13;
      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};&#13;
      if (state.localState) return {state: state.localState, mode: state.localMode};&#13;
      return {state: state, mode: mode};&#13;
    },&#13;
&#13;
    blankLine: blankLine,&#13;
&#13;
    getType: getType,&#13;
&#13;
    fold: "markdown"&#13;
  };&#13;
  return mode;&#13;
}, "xml");&#13;
&#13;
CodeMirror.defineMIME("text/x-markdown", "markdown");&#13;
&#13;
});&#13;
&#13;
},{"../../lib/codemirror":10,"../meta":13,"../xml/xml":14}],13:[function(require,module,exports){&#13;
// CodeMirror, copyright (c) by Marijn Haverbeke and others&#13;
// Distributed under an MIT license: http://codemirror.net/LICENSE&#13;
&#13;
(function(mod) {&#13;
  if (typeof exports == "object" &amp;&amp; typeof module == "object") // CommonJS&#13;
    mod(require("../lib/codemirror"));&#13;
  else if (typeof define == "function" &amp;&amp; define.amd) // AMD&#13;
    define(["../lib/codemirror"], mod);&#13;
  else // Plain browser env&#13;
    mod(CodeMirror);&#13;
})(function(CodeMirror) {&#13;
  "use strict";&#13;
&#13;
  CodeMirror.modeInfo = [&#13;
    {name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"]},&#13;
    {name: "PGP", mimes: ["application/pgp", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["pgp"]},&#13;
    {name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"]},&#13;
    {name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i},&#13;
    {name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"]},&#13;
    {name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h"]},&#13;
    {name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"]},&#13;
    {name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy"]},&#13;
    {name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp"]},&#13;
    {name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"]},&#13;
    {name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"]},&#13;
    {name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"]},&#13;
    {name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists.txt$/},&#13;
    {name: "CoffeeScript", mime: "text/x-coffeescript", mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"]},&#13;
    {name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"]},&#13;
    {name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"]},&#13;
    {name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"]},&#13;
    {name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"]},&#13;
    {name: "CSS", mime: "text/css", mode: "css", ext: ["css"]},&#13;
    {name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"]},&#13;
    {name: "D", mime: "text/x-d", mode: "d", ext: ["d"]},&#13;
    {name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"]},&#13;
    {name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"]},&#13;
    {name: "Django", mime: "text/x-django", mode: "django"},&#13;
    {name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/},&#13;
    {name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"]},&#13;
    {name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"]},&#13;
    {name: "EBNF", mime: "text/x-ebnf", mode: "ebnf"},&#13;
    {name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"]},&#13;
    {name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"]},&#13;
    {name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"]},&#13;
    {name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"]},&#13;
    {name: "Embedded Javascript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"]},&#13;
    {name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"]},&#13;
    {name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"]},&#13;
    {name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"]},&#13;
    {name: "FCL", mime: "text/x-fcl", mode: "fcl"},&#13;
    {name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"]},&#13;
    {name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90"]},&#13;
    {name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"]},&#13;
    {name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"]},&#13;
    {name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"]},&#13;
    {name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history).md$/i},&#13;
    {name: "Go", mime: "text/x-go", mode: "go", ext: ["go"]},&#13;
    {name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"]},&#13;
    {name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"]},&#13;
    {name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"]},&#13;
    {name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"]},&#13;
    {name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"]},&#13;
    {name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"]},&#13;
    {name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"]},&#13;
    {name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm"], alias: ["xhtml"]},&#13;
    {name: "HTTP", mime: "message/http", mode: "http"},&#13;
    {name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"]},&#13;
    {name: "Jade", mime: "text/x-jade", mode: "jade", ext: ["jade"]},&#13;
    {name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"]},&#13;
    {name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"]},&#13;
    {name: "JavaScript", mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],&#13;
     mode: "javascript", ext: ["js"], alias: ["ecmascript", "js", "node"]},&#13;
    {name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"]},&#13;
    {name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"]},&#13;
    {name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"]},&#13;
    {name: "Jinja2", mime: "null", mode: "jinja2"},&#13;
    {name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"]},&#13;
    {name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"]},&#13;
    {name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"]},&#13;
    {name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"]},&#13;
    {name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"]},&#13;
    {name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"]},&#13;
    {name: "mIRC", mime: "text/mirc", mode: "mirc"},&#13;
    {name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql"},&#13;
    {name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb"]},&#13;
    {name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"]},&#13;
    {name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"]},&#13;
    {name: "MS SQL", mime: "text/x-mssql", mode: "sql"},&#13;
    {name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"]},&#13;
    {name: "MySQL", mime: "text/x-mysql", mode: "sql"},&#13;
    {name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i},&#13;
    {name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"]},&#13;
    {name: "NTriples", mime: "text/n-triples", mode: "ntriples", ext: ["nt"]},&#13;
    {name: "Objective C", mime: "text/x-objectivec", mode: "clike", ext: ["m", "mm"], alias: ["objective-c", "objc"]},&#13;
    {name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"]},&#13;
    {name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"]},&#13;
    {name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"]},&#13;
    {name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"]},&#13;
    {name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"]},&#13;
    {name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"]},&#13;
    {name: "PHP", mime: "application/x-httpd-php", mode: "php", ext: ["php", "php3", "php4", "php5", "phtml"]},&#13;
    {name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"]},&#13;
    {name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"]},&#13;
    {name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"]},&#13;
    {name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"]},&#13;
    {name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"]},&#13;
    {name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"]},&#13;
    {name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/},&#13;
    {name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"]},&#13;
    {name: "Q", mime: "text/x-q", mode: "q", ext: ["q"]},&#13;
    {name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r"], alias: ["rscript"]},&#13;
    {name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"]},&#13;
    {name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm"},&#13;
    {name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"]},&#13;
    {name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"]},&#13;
    {name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"]},&#13;
    {name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"]},&#13;
    {name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"]},&#13;
    {name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"]},&#13;
    {name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"]},&#13;
    {name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"]},&#13;
    {name: "Shell", mime: "text/x-sh", mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/},&#13;
    {name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"]},&#13;
    {name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"]},&#13;
    {name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"]},&#13;
    {name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"]},&#13;
    {name: "Solr", mime: "text/x-solr", mode: "solr"},&#13;
    {name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"]},&#13;
    {name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"]},&#13;
    {name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"]},&#13;
    {name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"]},&#13;
    {name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"]},&#13;
    {name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"]},&#13;
    {name: "sTeX", mime: "text/x-stex", mode: "stex"},&#13;
    {name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx"], alias: ["tex"]},&#13;
    {name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v"]},&#13;
    {name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"]},&#13;
    {name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"]},&#13;
    {name: "TiddlyWiki ", mime: "text/x-tiddlywiki", mode: "tiddlywiki"},&#13;
    {name: "Tiki wiki", mime: "text/tiki", mode: "tiki"},&#13;
    {name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"]},&#13;
    {name: "Tornado", mime: "text/x-tornado", mode: "tornado"},&#13;
    {name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"]},&#13;
    {name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"]},&#13;
    {name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"]},&#13;
    {name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"]},&#13;
    {name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"]},&#13;
    {name: "Twig", mime: "text/x-twig", mode: "twig"},&#13;
    {name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"]},&#13;
    {name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"]},&#13;
    {name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"]},&#13;
    {name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"]},&#13;
    {name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"]},&#13;
    {name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"]},&#13;
    {name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd"], alias: ["rss", "wsdl", "xsd"]},&#13;
    {name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"]},&#13;
    {name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"]},&#13;
    {name: "YAML", mime: "text/x-yaml", mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"]},&#13;
    {name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"]},&#13;
    {name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"]},&#13;
    {name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"]},&#13;
    {name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"]}&#13;
  ];&#13;
  // Ensure all modes have a mime property for backwards compatibility&#13;
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {&#13;
    var info = CodeMirror.modeInfo[i];&#13;
    if (info.mimes) info.mime = info.mimes[0];&#13;
  }&#13;
&#13;
  CodeMirror.findModeByMIME = function(mime) {&#13;
    mime = mime.toLowerCase();&#13;
    for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {&#13;
      var info = CodeMirror.modeInfo[i];&#13;
      if (info.mime == mime) return info;&#13;
      if (info.mimes) for (var j = 0; j &lt; info.mimes.length; j++)&#13;
        if (info.mimes[j] == mime) return info;&#13;
    }&#13;
  };&#13;
&#13;
  CodeMirror.findModeByExtension = function(ext) {&#13;
    for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {&#13;
      var info = CodeMirror.modeInfo[i];&#13;
      if (info.ext) for (var j = 0; j &lt; info.ext.length; j++)&#13;
        if (info.ext[j] == ext) return info;&#13;
    }&#13;
  };&#13;
&#13;
  CodeMirror.findModeByFileName = function(filename) {&#13;
    for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {&#13;
      var info = CodeMirror.modeInfo[i];&#13;
      if (info.file &amp;&amp; info.file.test(filename)) return info;&#13;
    }&#13;
    var dot = filename.lastIndexOf(".");&#13;
    var ext = dot &gt; -1 &amp;&amp; filename.substring(dot + 1, filename.length);&#13;
    if (ext) return CodeMirror.findModeByExtension(ext);&#13;
  };&#13;
&#13;
  CodeMirror.findModeByName = function(name) {&#13;
    name = name.toLowerCase();&#13;
    for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {&#13;
      var info = CodeMirror.modeInfo[i];&#13;
      if (info.name.toLowerCase() == name) return info;&#13;
      if (info.alias) for (var j = 0; j &lt; info.alias.length; j++)&#13;
        if (info.alias[j].toLowerCase() == name) return info;&#13;
    }&#13;
  };&#13;
});&#13;
&#13;
},{"../lib/codemirror":10}],14:[function(require,module,exports){&#13;
// CodeMirror, copyright (c) by Marijn Haverbeke and others&#13;
// Distributed under an MIT license: http://codemirror.net/LICENSE&#13;
&#13;
(function(mod) {&#13;
  if (typeof exports == "object" &amp;&amp; typeof module == "object") // CommonJS&#13;
    mod(require("../../lib/codemirror"));&#13;
  else if (typeof define == "function" &amp;&amp; define.amd) // AMD&#13;
    define(["../../lib/codemirror"], mod);&#13;
  else // Plain browser env&#13;
    mod(CodeMirror);&#13;
})(function(CodeMirror) {&#13;
"use strict";&#13;
&#13;
var htmlConfig = {&#13;
  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,&#13;
                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,&#13;
                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,&#13;
                    'track': true, 'wbr': true, 'menuitem': true},&#13;
  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,&#13;
                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,&#13;
                     'th': true, 'tr': true},&#13;
  contextGrabbers: {&#13;
    'dd': {'dd': true, 'dt': true},&#13;
    'dt': {'dd': true, 'dt': true},&#13;
    'li': {'li': true},&#13;
    'option': {'option': true, 'optgroup': true},&#13;
    'optgroup': {'optgroup': true},&#13;
    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,&#13;
          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,&#13;
          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,&#13;
          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,&#13;
          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},&#13;
    'rp': {'rp': true, 'rt': true},&#13;
    'rt': {'rp': true, 'rt': true},&#13;
    'tbody': {'tbody': true, 'tfoot': true},&#13;
    'td': {'td': true, 'th': true},&#13;
    'tfoot': {'tbody': true},&#13;
    'th': {'td': true, 'th': true},&#13;
    'thead': {'tbody': true, 'tfoot': true},&#13;
    'tr': {'tr': true}&#13;
  },&#13;
  doNotIndent: {"pre": true},&#13;
  allowUnquoted: true,&#13;
  allowMissing: true,&#13;
  caseFold: true&#13;
}&#13;
&#13;
var xmlConfig = {&#13;
  autoSelfClosers: {},&#13;
  implicitlyClosed: {},&#13;
  contextGrabbers: {},&#13;
  doNotIndent: {},&#13;
  allowUnquoted: false,&#13;
  allowMissing: false,&#13;
  caseFold: false&#13;
}&#13;
&#13;
CodeMirror.defineMode("xml", function(editorConf, config_) {&#13;
  var indentUnit = editorConf.indentUnit&#13;
  var config = {}&#13;
  var defaults = config_.htmlMode ? htmlConfig : xmlConfig&#13;
  for (var prop in defaults) config[prop] = defaults[prop]&#13;
  for (var prop in config_) config[prop] = config_[prop]&#13;
&#13;
  // Return variables for tokenizers&#13;
  var type, setStyle;&#13;
&#13;
  function inText(stream, state) {&#13;
    function chain(parser) {&#13;
      state.tokenize = parser;&#13;
      return parser(stream, state);&#13;
    }&#13;
&#13;
    var ch = stream.next();&#13;
    if (ch == "&lt;") {&#13;
      if (stream.eat("!")) {&#13;
        if (stream.eat("[")) {&#13;
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]&gt;"));&#13;
          else return null;&#13;
        } else if (stream.match("--")) {&#13;
          return chain(inBlock("comment", "--&gt;"));&#13;
        } else if (stream.match("DOCTYPE", true, true)) {&#13;
          stream.eatWhile(/[\w\._\-]/);&#13;
          return chain(doctype(1));&#13;
        } else {&#13;
          return null;&#13;
        }&#13;
      } else if (stream.eat("?")) {&#13;
        stream.eatWhile(/[\w\._\-]/);&#13;
        state.tokenize = inBlock("meta", "?&gt;");&#13;
        return "meta";&#13;
      } else {&#13;
        type = stream.eat("/") ? "closeTag" : "openTag";&#13;
        state.tokenize = inTag;&#13;
        return "tag bracket";&#13;
      }&#13;
    } else if (ch == "&amp;") {&#13;
      var ok;&#13;
      if (stream.eat("#")) {&#13;
        if (stream.eat("x")) {&#13;
          ok = stream.eatWhile(/[a-fA-F\d]/) &amp;&amp; stream.eat(";");&#13;
        } else {&#13;
          ok = stream.eatWhile(/[\d]/) &amp;&amp; stream.eat(";");&#13;
        }&#13;
      } else {&#13;
        ok = stream.eatWhile(/[\w\.\-:]/) &amp;&amp; stream.eat(";");&#13;
      }&#13;
      return ok ? "atom" : "error";&#13;
    } else {&#13;
      stream.eatWhile(/[^&amp;&lt;]/);&#13;
      return null;&#13;
    }&#13;
  }&#13;
  inText.isInText = true;&#13;
&#13;
  function inTag(stream, state) {&#13;
    var ch = stream.next();&#13;
    if (ch == "&gt;" || (ch == "/" &amp;&amp; stream.eat("&gt;"))) {&#13;
      state.tokenize = inText;&#13;
      type = ch == "&gt;" ? "endTag" : "selfcloseTag";&#13;
      return "tag bracket";&#13;
    } else if (ch == "=") {&#13;
      type = "equals";&#13;
      return null;&#13;
    } else if (ch == "&lt;") {&#13;
      state.tokenize = inText;&#13;
      state.state = baseState;&#13;
      state.tagName = state.tagStart = null;&#13;
      var next = state.tokenize(stream, state);&#13;
      return next ? next + " tag error" : "tag error";&#13;
    } else if (/[\'\"]/.test(ch)) {&#13;
      state.tokenize = inAttribute(ch);&#13;
      state.stringStartCol = stream.column();&#13;
      return state.tokenize(stream, state);&#13;
    } else {&#13;
      stream.match(/^[^\s\u00a0=&lt;&gt;\"\']*[^\s\u00a0=&lt;&gt;\"\'\/]/);&#13;
      return "word";&#13;
    }&#13;
  }&#13;
&#13;
  function inAttribute(quote) {&#13;
    var closure = function(stream, state) {&#13;
      while (!stream.eol()) {&#13;
        if (stream.next() == quote) {&#13;
          state.tokenize = inTag;&#13;
          break;&#13;
        }&#13;
      }&#13;
      return "string";&#13;
    };&#13;
    closure.isInAttribute = true;&#13;
    return closure;&#13;
  }&#13;
&#13;
  function inBlock(style, terminator) {&#13;
    return function(stream, state) {&#13;
      while (!stream.eol()) {&#13;
        if (stream.match(terminator)) {&#13;
          state.tokenize = inText;&#13;
          break;&#13;
        }&#13;
        stream.next();&#13;
      }&#13;
      return style;&#13;
    };&#13;
  }&#13;
  function doctype(depth) {&#13;
    return function(stream, state) {&#13;
      var ch;&#13;
      while ((ch = stream.next()) != null) {&#13;
        if (ch == "&lt;") {&#13;
          state.tokenize = doctype(depth + 1);&#13;
          return state.tokenize(stream, state);&#13;
        } else if (ch == "&gt;") {&#13;
          if (depth == 1) {&#13;
            state.tokenize = inText;&#13;
            break;&#13;
          } else {&#13;
            state.tokenize = doctype(depth - 1);&#13;
            return state.tokenize(stream, state);&#13;
          }&#13;
        }&#13;
      }&#13;
      return "meta";&#13;
    };&#13;
  }&#13;
&#13;
  function Context(state, tagName, startOfLine) {&#13;
    this.prev = state.context;&#13;
    this.tagName = tagName;&#13;
    this.indent = state.indented;&#13;
    this.startOfLine = startOfLine;&#13;
    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context &amp;&amp; state.context.noIndent))&#13;
      this.noIndent = true;&#13;
  }&#13;
  function popContext(state) {&#13;
    if (state.context) state.context = state.context.prev;&#13;
  }&#13;
  function maybePopContext(state, nextTagName) {&#13;
    var parentTagName;&#13;
    while (true) {&#13;
      if (!state.context) {&#13;
        return;&#13;
      }&#13;
      parentTagName = state.context.tagName;&#13;
      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||&#13;
          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {&#13;
        return;&#13;
      }&#13;
      popContext(state);&#13;
    }&#13;
  }&#13;
&#13;
  function baseState(type, stream, state) {&#13;
    if (type == "openTag") {&#13;
      state.tagStart = stream.column();&#13;
      return tagNameState;&#13;
    } else if (type == "closeTag") {&#13;
      return closeTagNameState;&#13;
    } else {&#13;
      return baseState;&#13;
    }&#13;
  }&#13;
  function tagNameState(type, stream, state) {&#13;
    if (type == "word") {&#13;
      state.tagName = stream.current();&#13;
      setStyle = "tag";&#13;
      return attrState;&#13;
    } else {&#13;
      setStyle = "error";&#13;
      return tagNameState;&#13;
    }&#13;
  }&#13;
  function closeTagNameState(type, stream, state) {&#13;
    if (type == "word") {&#13;
      var tagName = stream.current();&#13;
      if (state.context &amp;&amp; state.context.tagName != tagName &amp;&amp;&#13;
          config.implicitlyClosed.hasOwnProperty(state.context.tagName))&#13;
        popContext(state);&#13;
      if ((state.context &amp;&amp; state.context.tagName == tagName) || config.matchClosing === false) {&#13;
        setStyle = "tag";&#13;
        return closeState;&#13;
      } else {&#13;
        setStyle = "tag error";&#13;
        return closeStateErr;&#13;
      }&#13;
    } else {&#13;
      setStyle = "error";&#13;
      return closeStateErr;&#13;
    }&#13;
  }&#13;
&#13;
  function closeState(type, _stream, state) {&#13;
    if (type != "endTag") {&#13;
      setStyle = "error";&#13;
      return closeState;&#13;
    }&#13;
    popContext(state);&#13;
    return baseState;&#13;
  }&#13;
  function closeStateErr(type, stream, state) {&#13;
    setStyle = "error";&#13;
    return closeState(type, stream, state);&#13;
  }&#13;
&#13;
  function attrState(type, _stream, state) {&#13;
    if (type == "word") {&#13;
      setStyle = "attribute";&#13;
      return attrEqState;&#13;
    } else if (type == "endTag" || type == "selfcloseTag") {&#13;
      var tagName = state.tagName, tagStart = state.tagStart;&#13;
      state.tagName = state.tagStart = null;&#13;
      if (type == "selfcloseTag" ||&#13;
          config.autoSelfClosers.hasOwnProperty(tagName)) {&#13;
        maybePopContext(state, tagName);&#13;
      } else {&#13;
        maybePopContext(state, tagName);&#13;
        state.context = new Context(state, tagName, tagStart == state.indented);&#13;
      }&#13;
      return baseState;&#13;
    }&#13;
    setStyle = "error";&#13;
    return attrState;&#13;
  }&#13;
  function attrEqState(type, stream, state) {&#13;
    if (type == "equals") return attrValueState;&#13;
    if (!config.allowMissing) setStyle = "error";&#13;
    return attrState(type, stream, state);&#13;
  }&#13;
  function attrValueState(type, stream, state) {&#13;
    if (type == "string") return attrContinuedState;&#13;
    if (type == "word" &amp;&amp; config.allowUnquoted) {setStyle = "string"; return attrState;}&#13;
    setStyle = "error";&#13;
    return attrState(type, stream, state);&#13;
  }&#13;
  function attrContinuedState(type, stream, state) {&#13;
    if (type == "string") return attrContinuedState;&#13;
    return attrState(type, stream, state);&#13;
  }&#13;
&#13;
  return {&#13;
    startState: function(baseIndent) {&#13;
      var state = {tokenize: inText,&#13;
                   state: baseState,&#13;
                   indented: baseIndent || 0,&#13;
                   tagName: null, tagStart: null,&#13;
                   context: null}&#13;
      if (baseIndent != null) state.baseIndent = baseIndent&#13;
      return state&#13;
    },&#13;
&#13;
    token: function(stream, state) {&#13;
      if (!state.tagName &amp;&amp; stream.sol())&#13;
        state.indented = stream.indentation();&#13;
&#13;
      if (stream.eatSpace()) return null;&#13;
      type = null;&#13;
      var style = state.tokenize(stream, state);&#13;
      if ((style || type) &amp;&amp; style != "comment") {&#13;
        setStyle = null;&#13;
        state.state = state.state(type || style, stream, state);&#13;
        if (setStyle)&#13;
          style = setStyle == "error" ? style + " error" : setStyle;&#13;
      }&#13;
      return style;&#13;
    },&#13;
&#13;
    indent: function(state, textAfter, fullLine) {&#13;
      var context = state.context;&#13;
      // Indent multi-line strings (e.g. css).&#13;
      if (state.tokenize.isInAttribute) {&#13;
        if (state.tagStart == state.indented)&#13;
          return state.stringStartCol + 1;&#13;
        else&#13;
          return state.indented + indentUnit;&#13;
      }&#13;
      if (context &amp;&amp; context.noIndent) return CodeMirror.Pass;&#13;
      if (state.tokenize != inTag &amp;&amp; state.tokenize != inText)&#13;
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;&#13;
      // Indent the starts of attribute names.&#13;
      if (state.tagName) {&#13;
        if (config.multilineTagIndentPastTag !== false)&#13;
          return state.tagStart + state.tagName.length + 2;&#13;
        else&#13;
          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);&#13;
      }&#13;
      if (config.alignCDATA &amp;&amp; /&lt;!\[CDATA\[/.test(textAfter)) return 0;&#13;
      var tagAfter = textAfter &amp;&amp; /^&lt;(\/)?([\w_:\.-]*)/.exec(textAfter);&#13;
      if (tagAfter &amp;&amp; tagAfter[1]) { // Closing tag spotted&#13;
        while (context) {&#13;
          if (context.tagName == tagAfter[2]) {&#13;
            context = context.prev;&#13;
            break;&#13;
          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {&#13;
            context = context.prev;&#13;
          } else {&#13;
            break;&#13;
          }&#13;
        }&#13;
      } else if (tagAfter) { // Opening tag spotted&#13;
        while (context) {&#13;
          var grabbers = config.contextGrabbers[context.tagName];&#13;
          if (grabbers &amp;&amp; grabbers.hasOwnProperty(tagAfter[2]))&#13;
            context = context.prev;&#13;
          else&#13;
            break;&#13;
        }&#13;
      }&#13;
      while (context &amp;&amp; context.prev &amp;&amp; !context.startOfLine)&#13;
        context = context.prev;&#13;
      if (context) return context.indent + indentUnit;&#13;
      else return state.baseIndent || 0;&#13;
    },&#13;
&#13;
    electricInput: /&lt;\/[\s\w:]+&gt;$/,&#13;
    blockCommentStart: "&lt;!--",&#13;
    blockCommentEnd: "--&gt;",&#13;
&#13;
    configuration: config.htmlMode ? "html" : "xml",&#13;
    helperType: config.htmlMode ? "html" : "xml",&#13;
&#13;
    skipAttribute: function(state) {&#13;
      if (state.state == attrValueState)&#13;
        state.state = attrState&#13;
    }&#13;
  };&#13;
});&#13;
&#13;
CodeMirror.defineMIME("text/xml", "xml");&#13;
CodeMirror.defineMIME("application/xml", "xml");&#13;
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))&#13;
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});&#13;
&#13;
});&#13;
&#13;
},{"../../lib/codemirror":10}],15:[function(require,module,exports){&#13;
exports.read = function (buffer, offset, isLE, mLen, nBytes) {&#13;
  var e, m&#13;
  var eLen = nBytes * 8 - mLen - 1&#13;
  var eMax = (1 &lt;&lt; eLen) - 1&#13;
  var eBias = eMax &gt;&gt; 1&#13;
  var nBits = -7&#13;
  var i = isLE ? (nBytes - 1) : 0&#13;
  var d = isLE ? -1 : 1&#13;
  var s = buffer[offset + i]&#13;
&#13;
  i += d&#13;
&#13;
  e = s &amp; ((1 &lt;&lt; (-nBits)) - 1)&#13;
  s &gt;&gt;= (-nBits)&#13;
  nBits += eLen&#13;
  for (; nBits &gt; 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}&#13;
&#13;
  m = e &amp; ((1 &lt;&lt; (-nBits)) - 1)&#13;
  e &gt;&gt;= (-nBits)&#13;
  nBits += mLen&#13;
  for (; nBits &gt; 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}&#13;
&#13;
  if (e === 0) {&#13;
    e = 1 - eBias&#13;
  } else if (e === eMax) {&#13;
    return m ? NaN : ((s ? -1 : 1) * Infinity)&#13;
  } else {&#13;
    m = m + Math.pow(2, mLen)&#13;
    e = e - eBias&#13;
  }&#13;
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)&#13;
}&#13;
&#13;
exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {&#13;
  var e, m, c&#13;
  var eLen = nBytes * 8 - mLen - 1&#13;
  var eMax = (1 &lt;&lt; eLen) - 1&#13;
  var eBias = eMax &gt;&gt; 1&#13;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)&#13;
  var i = isLE ? 0 : (nBytes - 1)&#13;
  var d = isLE ? 1 : -1&#13;
  var s = value &lt; 0 || (value === 0 &amp;&amp; 1 / value &lt; 0) ? 1 : 0&#13;
&#13;
  value = Math.abs(value)&#13;
&#13;
  if (isNaN(value) || value === Infinity) {&#13;
    m = isNaN(value) ? 1 : 0&#13;
    e = eMax&#13;
  } else {&#13;
    e = Math.floor(Math.log(value) / Math.LN2)&#13;
    if (value * (c = Math.pow(2, -e)) &lt; 1) {&#13;
      e--&#13;
      c *= 2&#13;
    }&#13;
    if (e + eBias &gt;= 1) {&#13;
      value += rt / c&#13;
    } else {&#13;
      value += rt * Math.pow(2, 1 - eBias)&#13;
    }&#13;
    if (value * c &gt;= 2) {&#13;
      e++&#13;
      c /= 2&#13;
    }&#13;
&#13;
    if (e + eBias &gt;= eMax) {&#13;
      m = 0&#13;
      e = eMax&#13;
    } else if (e + eBias &gt;= 1) {&#13;
      m = (value * c - 1) * Math.pow(2, mLen)&#13;
      e = e + eBias&#13;
    } else {&#13;
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)&#13;
      e = 0&#13;
    }&#13;
  }&#13;
&#13;
  for (; mLen &gt;= 8; buffer[offset + i] = m &amp; 0xff, i += d, m /= 256, mLen -= 8) {}&#13;
&#13;
  e = (e &lt;&lt; mLen) | m&#13;
  eLen += mLen&#13;
  for (; eLen &gt; 0; buffer[offset + i] = e &amp; 0xff, i += d, e /= 256, eLen -= 8) {}&#13;
&#13;
  buffer[offset + i - d] |= s * 128&#13;
}&#13;
&#13;
},{}],16:[function(require,module,exports){&#13;
var toString = {}.toString;&#13;
&#13;
module.exports = Array.isArray || function (arr) {&#13;
  return toString.call(arr) == '[object Array]';&#13;
};&#13;
&#13;
},{}],17:[function(require,module,exports){&#13;
(function (global){&#13;
/**&#13;
 * marked - a markdown parser&#13;
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)&#13;
 * https://github.com/chjj/marked&#13;
 */&#13;
&#13;
;(function() {&#13;
&#13;
/**&#13;
 * Block-Level Grammar&#13;
 */&#13;
&#13;
var block = {&#13;
  newline: /^\n+/,&#13;
  code: /^( {4}[^\n]+\n*)+/,&#13;
  fences: noop,&#13;
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,&#13;
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,&#13;
  nptable: noop,&#13;
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,&#13;
  blockquote: /^( *&gt;[^\n]+(\n(?!def)[^\n]+)*\n*)+/,&#13;
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,&#13;
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,&#13;
  def: /^ *\[([^\]]+)\]: *&lt;?([^\s&gt;]+)&gt;?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,&#13;
  table: noop,&#13;
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,&#13;
  text: /^[^\n]+/&#13;
};&#13;
&#13;
block.bullet = /(?:[*+-]|\d+\.)/;&#13;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;&#13;
block.item = replace(block.item, 'gm')&#13;
  (/bull/g, block.bullet)&#13;
  ();&#13;
&#13;
block.list = replace(block.list)&#13;
  (/bull/g, block.bullet)&#13;
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')&#13;
  ('def', '\\n+(?=' + block.def.source + ')')&#13;
  ();&#13;
&#13;
block.blockquote = replace(block.blockquote)&#13;
  ('def', block.def)&#13;
  ();&#13;
&#13;
block._tag = '(?!(?:'&#13;
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'&#13;
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'&#13;
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';&#13;
&#13;
block.html = replace(block.html)&#13;
  ('comment', /&lt;!--[\s\S]*?--&gt;/)&#13;
  ('closed', /&lt;(tag)[\s\S]+?&lt;\/\1&gt;/)&#13;
  ('closing', /&lt;tag(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;/)&#13;
  (/tag/g, block._tag)&#13;
  ();&#13;
&#13;
block.paragraph = replace(block.paragraph)&#13;
  ('hr', block.hr)&#13;
  ('heading', block.heading)&#13;
  ('lheading', block.lheading)&#13;
  ('blockquote', block.blockquote)&#13;
  ('tag', '&lt;' + block._tag)&#13;
  ('def', block.def)&#13;
  ();&#13;
&#13;
/**&#13;
 * Normal Block Grammar&#13;
 */&#13;
&#13;
block.normal = merge({}, block);&#13;
&#13;
/**&#13;
 * GFM Block Grammar&#13;
 */&#13;
&#13;
block.gfm = merge({}, block.normal, {&#13;
  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,&#13;
  paragraph: /^/,&#13;
  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/&#13;
});&#13;
&#13;
block.gfm.paragraph = replace(block.paragraph)&#13;
  ('(?!', '(?!'&#13;
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'&#13;
    + block.list.source.replace('\\1', '\\3') + '|')&#13;
  ();&#13;
&#13;
/**&#13;
 * GFM + Tables Block Grammar&#13;
 */&#13;
&#13;
block.tables = merge({}, block.gfm, {&#13;
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,&#13;
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/&#13;
});&#13;
&#13;
/**&#13;
 * Block Lexer&#13;
 */&#13;
&#13;
function Lexer(options) {&#13;
  this.tokens = [];&#13;
  this.tokens.links = {};&#13;
  this.options = options || marked.defaults;&#13;
  this.rules = block.normal;&#13;
&#13;
  if (this.options.gfm) {&#13;
    if (this.options.tables) {&#13;
      this.rules = block.tables;&#13;
    } else {&#13;
      this.rules = block.gfm;&#13;
    }&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * Expose Block Rules&#13;
 */&#13;
&#13;
Lexer.rules = block;&#13;
&#13;
/**&#13;
 * Static Lex Method&#13;
 */&#13;
&#13;
Lexer.lex = function(src, options) {&#13;
  var lexer = new Lexer(options);&#13;
  return lexer.lex(src);&#13;
};&#13;
&#13;
/**&#13;
 * Preprocessing&#13;
 */&#13;
&#13;
Lexer.prototype.lex = function(src) {&#13;
  src = src&#13;
    .replace(/\r\n|\r/g, '\n')&#13;
    .replace(/\t/g, '    ')&#13;
    .replace(/\u00a0/g, ' ')&#13;
    .replace(/\u2424/g, '\n');&#13;
&#13;
  return this.token(src, true);&#13;
};&#13;
&#13;
/**&#13;
 * Lexing&#13;
 */&#13;
&#13;
Lexer.prototype.token = function(src, top, bq) {&#13;
  var src = src.replace(/^ +$/gm, '')&#13;
    , next&#13;
    , loose&#13;
    , cap&#13;
    , bull&#13;
    , b&#13;
    , item&#13;
    , space&#13;
    , i&#13;
    , l;&#13;
&#13;
  while (src) {&#13;
    // newline&#13;
    if (cap = this.rules.newline.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      if (cap[0].length &gt; 1) {&#13;
        this.tokens.push({&#13;
          type: 'space'&#13;
        });&#13;
      }&#13;
    }&#13;
&#13;
    // code&#13;
    if (cap = this.rules.code.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      cap = cap[0].replace(/^ {4}/gm, '');&#13;
      this.tokens.push({&#13;
        type: 'code',&#13;
        text: !this.options.pedantic&#13;
          ? cap.replace(/\n+$/, '')&#13;
          : cap&#13;
      });&#13;
      continue;&#13;
    }&#13;
&#13;
    // fences (gfm)&#13;
    if (cap = this.rules.fences.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      this.tokens.push({&#13;
        type: 'code',&#13;
        lang: cap[2],&#13;
        text: cap[3] || ''&#13;
      });&#13;
      continue;&#13;
    }&#13;
&#13;
    // heading&#13;
    if (cap = this.rules.heading.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      this.tokens.push({&#13;
        type: 'heading',&#13;
        depth: cap[1].length,&#13;
        text: cap[2]&#13;
      });&#13;
      continue;&#13;
    }&#13;
&#13;
    // table no leading pipe (gfm)&#13;
    if (top &amp;&amp; (cap = this.rules.nptable.exec(src))) {&#13;
      src = src.substring(cap[0].length);&#13;
&#13;
      item = {&#13;
        type: 'table',&#13;
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),&#13;
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),&#13;
        cells: cap[3].replace(/\n$/, '').split('\n')&#13;
      };&#13;
&#13;
      for (i = 0; i &lt; item.align.length; i++) {&#13;
        if (/^ *-+: *$/.test(item.align[i])) {&#13;
          item.align[i] = 'right';&#13;
        } else if (/^ *:-+: *$/.test(item.align[i])) {&#13;
          item.align[i] = 'center';&#13;
        } else if (/^ *:-+ *$/.test(item.align[i])) {&#13;
          item.align[i] = 'left';&#13;
        } else {&#13;
          item.align[i] = null;&#13;
        }&#13;
      }&#13;
&#13;
      for (i = 0; i &lt; item.cells.length; i++) {&#13;
        item.cells[i] = item.cells[i].split(/ *\| */);&#13;
      }&#13;
&#13;
      this.tokens.push(item);&#13;
&#13;
      continue;&#13;
    }&#13;
&#13;
    // lheading&#13;
    if (cap = this.rules.lheading.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      this.tokens.push({&#13;
        type: 'heading',&#13;
        depth: cap[2] === '=' ? 1 : 2,&#13;
        text: cap[1]&#13;
      });&#13;
      continue;&#13;
    }&#13;
&#13;
    // hr&#13;
    if (cap = this.rules.hr.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      this.tokens.push({&#13;
        type: 'hr'&#13;
      });&#13;
      continue;&#13;
    }&#13;
&#13;
    // blockquote&#13;
    if (cap = this.rules.blockquote.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
&#13;
      this.tokens.push({&#13;
        type: 'blockquote_start'&#13;
      });&#13;
&#13;
      cap = cap[0].replace(/^ *&gt; ?/gm, '');&#13;
&#13;
      // Pass `top` to keep the current&#13;
      // "toplevel" state. This is exactly&#13;
      // how markdown.pl works.&#13;
      this.token(cap, top, true);&#13;
&#13;
      this.tokens.push({&#13;
        type: 'blockquote_end'&#13;
      });&#13;
&#13;
      continue;&#13;
    }&#13;
&#13;
    // list&#13;
    if (cap = this.rules.list.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      bull = cap[2];&#13;
&#13;
      this.tokens.push({&#13;
        type: 'list_start',&#13;
        ordered: bull.length &gt; 1&#13;
      });&#13;
&#13;
      // Get each top-level item.&#13;
      cap = cap[0].match(this.rules.item);&#13;
&#13;
      next = false;&#13;
      l = cap.length;&#13;
      i = 0;&#13;
&#13;
      for (; i &lt; l; i++) {&#13;
        item = cap[i];&#13;
&#13;
        // Remove the list item's bullet&#13;
        // so it is seen as the next token.&#13;
        space = item.length;&#13;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');&#13;
&#13;
        // Outdent whatever the&#13;
        // list item contains. Hacky.&#13;
        if (~item.indexOf('\n ')) {&#13;
          space -= item.length;&#13;
          item = !this.options.pedantic&#13;
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')&#13;
            : item.replace(/^ {1,4}/gm, '');&#13;
        }&#13;
&#13;
        // Determine whether the next list item belongs here.&#13;
        // Backpedal if it does not belong in this list.&#13;
        if (this.options.smartLists &amp;&amp; i !== l - 1) {&#13;
          b = block.bullet.exec(cap[i + 1])[0];&#13;
          if (bull !== b &amp;&amp; !(bull.length &gt; 1 &amp;&amp; b.length &gt; 1)) {&#13;
            src = cap.slice(i + 1).join('\n') + src;&#13;
            i = l - 1;&#13;
          }&#13;
        }&#13;
&#13;
        // Determine whether item is loose or not.&#13;
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/&#13;
        // for discount behavior.&#13;
        loose = next || /\n\n(?!\s*$)/.test(item);&#13;
        if (i !== l - 1) {&#13;
          next = item.charAt(item.length - 1) === '\n';&#13;
          if (!loose) loose = next;&#13;
        }&#13;
&#13;
        this.tokens.push({&#13;
          type: loose&#13;
            ? 'loose_item_start'&#13;
            : 'list_item_start'&#13;
        });&#13;
&#13;
        // Recurse.&#13;
        this.token(item, false, bq);&#13;
&#13;
        this.tokens.push({&#13;
          type: 'list_item_end'&#13;
        });&#13;
      }&#13;
&#13;
      this.tokens.push({&#13;
        type: 'list_end'&#13;
      });&#13;
&#13;
      continue;&#13;
    }&#13;
&#13;
    // html&#13;
    if (cap = this.rules.html.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      this.tokens.push({&#13;
        type: this.options.sanitize&#13;
          ? 'paragraph'&#13;
          : 'html',&#13;
        pre: !this.options.sanitizer&#13;
          &amp;&amp; (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),&#13;
        text: cap[0]&#13;
      });&#13;
      continue;&#13;
    }&#13;
&#13;
    // def&#13;
    if ((!bq &amp;&amp; top) &amp;&amp; (cap = this.rules.def.exec(src))) {&#13;
      src = src.substring(cap[0].length);&#13;
      this.tokens.links[cap[1].toLowerCase()] = {&#13;
        href: cap[2],&#13;
        title: cap[3]&#13;
      };&#13;
      continue;&#13;
    }&#13;
&#13;
    // table (gfm)&#13;
    if (top &amp;&amp; (cap = this.rules.table.exec(src))) {&#13;
      src = src.substring(cap[0].length);&#13;
&#13;
      item = {&#13;
        type: 'table',&#13;
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),&#13;
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),&#13;
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')&#13;
      };&#13;
&#13;
      for (i = 0; i &lt; item.align.length; i++) {&#13;
        if (/^ *-+: *$/.test(item.align[i])) {&#13;
          item.align[i] = 'right';&#13;
        } else if (/^ *:-+: *$/.test(item.align[i])) {&#13;
          item.align[i] = 'center';&#13;
        } else if (/^ *:-+ *$/.test(item.align[i])) {&#13;
          item.align[i] = 'left';&#13;
        } else {&#13;
          item.align[i] = null;&#13;
        }&#13;
      }&#13;
&#13;
      for (i = 0; i &lt; item.cells.length; i++) {&#13;
        item.cells[i] = item.cells[i]&#13;
          .replace(/^ *\| *| *\| *$/g, '')&#13;
          .split(/ *\| */);&#13;
      }&#13;
&#13;
      this.tokens.push(item);&#13;
&#13;
      continue;&#13;
    }&#13;
&#13;
    // top-level paragraph&#13;
    if (top &amp;&amp; (cap = this.rules.paragraph.exec(src))) {&#13;
      src = src.substring(cap[0].length);&#13;
      this.tokens.push({&#13;
        type: 'paragraph',&#13;
        text: cap[1].charAt(cap[1].length - 1) === '\n'&#13;
          ? cap[1].slice(0, -1)&#13;
          : cap[1]&#13;
      });&#13;
      continue;&#13;
    }&#13;
&#13;
    // text&#13;
    if (cap = this.rules.text.exec(src)) {&#13;
      // Top-level should never reach here.&#13;
      src = src.substring(cap[0].length);&#13;
      this.tokens.push({&#13;
        type: 'text',&#13;
        text: cap[0]&#13;
      });&#13;
      continue;&#13;
    }&#13;
&#13;
    if (src) {&#13;
      throw new&#13;
        Error('Infinite loop on byte: ' + src.charCodeAt(0));&#13;
    }&#13;
  }&#13;
&#13;
  return this.tokens;&#13;
};&#13;
&#13;
/**&#13;
 * Inline-Level Grammar&#13;
 */&#13;
&#13;
var inline = {&#13;
  escape: /^\\([\\`*{}\[\]()#+\-.!_&gt;])/,&#13;
  autolink: /^&lt;([^ &gt;]+(@|:\/)[^ &gt;]+)&gt;/,&#13;
  url: noop,&#13;
  tag: /^&lt;!--[\s\S]*?--&gt;|^&lt;\/?\w+(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;/,&#13;
  link: /^!?\[(inside)\]\(href\)/,&#13;
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,&#13;
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,&#13;
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,&#13;
  em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,&#13;
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,&#13;
  br: /^ {2,}\n(?!\s*$)/,&#13;
  del: noop,&#13;
  text: /^[\s\S]+?(?=[\\&lt;!\[_*`]| {2,}\n|$)/&#13;
};&#13;
&#13;
inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;&#13;
inline._href = /\s*&lt;?([\s\S]*?)&gt;?(?:\s+['"]([\s\S]*?)['"])?\s*/;&#13;
&#13;
inline.link = replace(inline.link)&#13;
  ('inside', inline._inside)&#13;
  ('href', inline._href)&#13;
  ();&#13;
&#13;
inline.reflink = replace(inline.reflink)&#13;
  ('inside', inline._inside)&#13;
  ();&#13;
&#13;
/**&#13;
 * Normal Inline Grammar&#13;
 */&#13;
&#13;
inline.normal = merge({}, inline);&#13;
&#13;
/**&#13;
 * Pedantic Inline Grammar&#13;
 */&#13;
&#13;
inline.pedantic = merge({}, inline.normal, {&#13;
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,&#13;
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/&#13;
});&#13;
&#13;
/**&#13;
 * GFM Inline Grammar&#13;
 */&#13;
&#13;
inline.gfm = merge({}, inline.normal, {&#13;
  escape: replace(inline.escape)('])', '~|])')(),&#13;
  url: /^(https?:\/\/[^\s&lt;]+[^&lt;.,:;"')\]\s])/,&#13;
  del: /^~~(?=\S)([\s\S]*?\S)~~/,&#13;
  text: replace(inline.text)&#13;
    (']|', '~]|')&#13;
    ('|', '|https?://|')&#13;
    ()&#13;
});&#13;
&#13;
/**&#13;
 * GFM + Line Breaks Inline Grammar&#13;
 */&#13;
&#13;
inline.breaks = merge({}, inline.gfm, {&#13;
  br: replace(inline.br)('{2,}', '*')(),&#13;
  text: replace(inline.gfm.text)('{2,}', '*')()&#13;
});&#13;
&#13;
/**&#13;
 * Inline Lexer &amp; Compiler&#13;
 */&#13;
&#13;
function InlineLexer(links, options) {&#13;
  this.options = options || marked.defaults;&#13;
  this.links = links;&#13;
  this.rules = inline.normal;&#13;
  this.renderer = this.options.renderer || new Renderer;&#13;
  this.renderer.options = this.options;&#13;
&#13;
  if (!this.links) {&#13;
    throw new&#13;
      Error('Tokens array requires a `links` property.');&#13;
  }&#13;
&#13;
  if (this.options.gfm) {&#13;
    if (this.options.breaks) {&#13;
      this.rules = inline.breaks;&#13;
    } else {&#13;
      this.rules = inline.gfm;&#13;
    }&#13;
  } else if (this.options.pedantic) {&#13;
    this.rules = inline.pedantic;&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * Expose Inline Rules&#13;
 */&#13;
&#13;
InlineLexer.rules = inline;&#13;
&#13;
/**&#13;
 * Static Lexing/Compiling Method&#13;
 */&#13;
&#13;
InlineLexer.output = function(src, links, options) {&#13;
  var inline = new InlineLexer(links, options);&#13;
  return inline.output(src);&#13;
};&#13;
&#13;
/**&#13;
 * Lexing/Compiling&#13;
 */&#13;
&#13;
InlineLexer.prototype.output = function(src) {&#13;
  var out = ''&#13;
    , link&#13;
    , text&#13;
    , href&#13;
    , cap;&#13;
&#13;
  while (src) {&#13;
    // escape&#13;
    if (cap = this.rules.escape.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      out += cap[1];&#13;
      continue;&#13;
    }&#13;
&#13;
    // autolink&#13;
    if (cap = this.rules.autolink.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      if (cap[2] === '@') {&#13;
        text = cap[1].charAt(6) === ':'&#13;
          ? this.mangle(cap[1].substring(7))&#13;
          : this.mangle(cap[1]);&#13;
        href = this.mangle('mailto:') + text;&#13;
      } else {&#13;
        text = escape(cap[1]);&#13;
        href = text;&#13;
      }&#13;
      out += this.renderer.link(href, null, text);&#13;
      continue;&#13;
    }&#13;
&#13;
    // url (gfm)&#13;
    if (!this.inLink &amp;&amp; (cap = this.rules.url.exec(src))) {&#13;
      src = src.substring(cap[0].length);&#13;
      text = escape(cap[1]);&#13;
      href = text;&#13;
      out += this.renderer.link(href, null, text);&#13;
      continue;&#13;
    }&#13;
&#13;
    // tag&#13;
    if (cap = this.rules.tag.exec(src)) {&#13;
      if (!this.inLink &amp;&amp; /^&lt;a /i.test(cap[0])) {&#13;
        this.inLink = true;&#13;
      } else if (this.inLink &amp;&amp; /^&lt;\/a&gt;/i.test(cap[0])) {&#13;
        this.inLink = false;&#13;
      }&#13;
      src = src.substring(cap[0].length);&#13;
      out += this.options.sanitize&#13;
        ? this.options.sanitizer&#13;
          ? this.options.sanitizer(cap[0])&#13;
          : escape(cap[0])&#13;
        : cap[0]&#13;
      continue;&#13;
    }&#13;
&#13;
    // link&#13;
    if (cap = this.rules.link.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      this.inLink = true;&#13;
      out += this.outputLink(cap, {&#13;
        href: cap[2],&#13;
        title: cap[3]&#13;
      });&#13;
      this.inLink = false;&#13;
      continue;&#13;
    }&#13;
&#13;
    // reflink, nolink&#13;
    if ((cap = this.rules.reflink.exec(src))&#13;
        || (cap = this.rules.nolink.exec(src))) {&#13;
      src = src.substring(cap[0].length);&#13;
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');&#13;
      link = this.links[link.toLowerCase()];&#13;
      if (!link || !link.href) {&#13;
        out += cap[0].charAt(0);&#13;
        src = cap[0].substring(1) + src;&#13;
        continue;&#13;
      }&#13;
      this.inLink = true;&#13;
      out += this.outputLink(cap, link);&#13;
      this.inLink = false;&#13;
      continue;&#13;
    }&#13;
&#13;
    // strong&#13;
    if (cap = this.rules.strong.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      out += this.renderer.strong(this.output(cap[2] || cap[1]));&#13;
      continue;&#13;
    }&#13;
&#13;
    // em&#13;
    if (cap = this.rules.em.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      out += this.renderer.em(this.output(cap[2] || cap[1]));&#13;
      continue;&#13;
    }&#13;
&#13;
    // code&#13;
    if (cap = this.rules.code.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      out += this.renderer.codespan(escape(cap[2], true));&#13;
      continue;&#13;
    }&#13;
&#13;
    // br&#13;
    if (cap = this.rules.br.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      out += this.renderer.br();&#13;
      continue;&#13;
    }&#13;
&#13;
    // del (gfm)&#13;
    if (cap = this.rules.del.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      out += this.renderer.del(this.output(cap[1]));&#13;
      continue;&#13;
    }&#13;
&#13;
    // text&#13;
    if (cap = this.rules.text.exec(src)) {&#13;
      src = src.substring(cap[0].length);&#13;
      out += this.renderer.text(escape(this.smartypants(cap[0])));&#13;
      continue;&#13;
    }&#13;
&#13;
    if (src) {&#13;
      throw new&#13;
        Error('Infinite loop on byte: ' + src.charCodeAt(0));&#13;
    }&#13;
  }&#13;
&#13;
  return out;&#13;
};&#13;
&#13;
/**&#13;
 * Compile Link&#13;
 */&#13;
&#13;
InlineLexer.prototype.outputLink = function(cap, link) {&#13;
  var href = escape(link.href)&#13;
    , title = link.title ? escape(link.title) : null;&#13;
&#13;
  return cap[0].charAt(0) !== '!'&#13;
    ? this.renderer.link(href, title, this.output(cap[1]))&#13;
    : this.renderer.image(href, title, escape(cap[1]));&#13;
};&#13;
&#13;
/**&#13;
 * Smartypants Transformations&#13;
 */&#13;
&#13;
InlineLexer.prototype.smartypants = function(text) {&#13;
  if (!this.options.smartypants) return text;&#13;
  return text&#13;
    // em-dashes&#13;
    .replace(/---/g, '\u2014')&#13;
    // en-dashes&#13;
    .replace(/--/g, '\u2013')&#13;
    // opening singles&#13;
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')&#13;
    // closing singles &amp; apostrophes&#13;
    .replace(/'/g, '\u2019')&#13;
    // opening doubles&#13;
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')&#13;
    // closing doubles&#13;
    .replace(/"/g, '\u201d')&#13;
    // ellipses&#13;
    .replace(/\.{3}/g, '\u2026');&#13;
};&#13;
&#13;
/**&#13;
 * Mangle Links&#13;
 */&#13;
&#13;
InlineLexer.prototype.mangle = function(text) {&#13;
  if (!this.options.mangle) return text;&#13;
  var out = ''&#13;
    , l = text.length&#13;
    , i = 0&#13;
    , ch;&#13;
&#13;
  for (; i &lt; l; i++) {&#13;
    ch = text.charCodeAt(i);&#13;
    if (Math.random() &gt; 0.5) {&#13;
      ch = 'x' + ch.toString(16);&#13;
    }&#13;
    out += '&amp;#' + ch + ';';&#13;
  }&#13;
&#13;
  return out;&#13;
};&#13;
&#13;
/**&#13;
 * Renderer&#13;
 */&#13;
&#13;
function Renderer(options) {&#13;
  this.options = options || {};&#13;
}&#13;
&#13;
Renderer.prototype.code = function(code, lang, escaped) {&#13;
  if (this.options.highlight) {&#13;
    var out = this.options.highlight(code, lang);&#13;
    if (out != null &amp;&amp; out !== code) {&#13;
      escaped = true;&#13;
      code = out;&#13;
    }&#13;
  }&#13;
&#13;
  if (!lang) {&#13;
    return '&lt;pre&gt;&lt;code&gt;'&#13;
      + (escaped ? code : escape(code, true))&#13;
      + '\n&lt;/code&gt;&lt;/pre&gt;';&#13;
  }&#13;
&#13;
  return '&lt;pre&gt;&lt;code class="'&#13;
    + this.options.langPrefix&#13;
    + escape(lang, true)&#13;
    + '"&gt;'&#13;
    + (escaped ? code : escape(code, true))&#13;
    + '\n&lt;/code&gt;&lt;/pre&gt;\n';&#13;
};&#13;
&#13;
Renderer.prototype.blockquote = function(quote) {&#13;
  return '&lt;blockquote&gt;\n' + quote + '&lt;/blockquote&gt;\n';&#13;
};&#13;
&#13;
Renderer.prototype.html = function(html) {&#13;
  return html;&#13;
};&#13;
&#13;
Renderer.prototype.heading = function(text, level, raw) {&#13;
  return '&lt;h'&#13;
    + level&#13;
    + ' id="'&#13;
    + this.options.headerPrefix&#13;
    + raw.toLowerCase().replace(/[^\w]+/g, '-')&#13;
    + '"&gt;'&#13;
    + text&#13;
    + '&lt;/h'&#13;
    + level&#13;
    + '&gt;\n';&#13;
};&#13;
&#13;
Renderer.prototype.hr = function() {&#13;
  return this.options.xhtml ? '&lt;hr/&gt;\n' : '&lt;hr&gt;\n';&#13;
};&#13;
&#13;
Renderer.prototype.list = function(body, ordered) {&#13;
  var type = ordered ? 'ol' : 'ul';&#13;
  return '&lt;' + type + '&gt;\n' + body + '&lt;/' + type + '&gt;\n';&#13;
};&#13;
&#13;
Renderer.prototype.listitem = function(text) {&#13;
  return '&lt;li&gt;' + text + '&lt;/li&gt;\n';&#13;
};&#13;
&#13;
Renderer.prototype.paragraph = function(text) {&#13;
  return '&lt;p&gt;' + text + '&lt;/p&gt;\n';&#13;
};&#13;
&#13;
Renderer.prototype.table = function(header, body) {&#13;
  return '&lt;table class="table_class"&gt;\n'&#13;
    + '&lt;thead&gt;\n'&#13;
    + header&#13;
    + '&lt;/thead&gt;\n'&#13;
    + '&lt;tbody&gt;\n'&#13;
    + body&#13;
    + '&lt;/tbody&gt;\n'&#13;
    + '&lt;/table&gt;\n';&#13;
};&#13;
&#13;
Renderer.prototype.tablerow = function(content) {&#13;
  return '&lt;tr&gt;\n' + content + '&lt;/tr&gt;\n';&#13;
};&#13;
&#13;
Renderer.prototype.tablecell = function(content, flags) {&#13;
  var type = flags.header ? 'th' : 'td';&#13;
  var tag = flags.align&#13;
    ? '&lt;' + type + ' style="text-align:' + flags.align + '"&gt;'&#13;
    : '&lt;' + type + '&gt;';&#13;
  return tag + content + '&lt;/' + type + '&gt;\n';&#13;
};&#13;
&#13;
// span level renderer&#13;
Renderer.prototype.strong = function(text) {&#13;
  return '&lt;strong&gt;' + text + '&lt;/strong&gt;';&#13;
};&#13;
&#13;
Renderer.prototype.em = function(text) {&#13;
  return '&lt;em&gt;' + text + '&lt;/em&gt;';&#13;
};&#13;
&#13;
Renderer.prototype.codespan = function(text) {&#13;
  return '&lt;code&gt;' + text + '&lt;/code&gt;';&#13;
};&#13;
&#13;
Renderer.prototype.br = function() {&#13;
  return this.options.xhtml ? '&lt;br/&gt;' : '&lt;br&gt;';&#13;
};&#13;
&#13;
Renderer.prototype.del = function(text) {&#13;
  return '&lt;del&gt;' + text + '&lt;/del&gt;';&#13;
};&#13;
&#13;
Renderer.prototype.link = function(href, title, text) {&#13;
  if (this.options.sanitize) {&#13;
    try {&#13;
      var prot = decodeURIComponent(unescape(href))&#13;
        .replace(/[^\w:]/g, '')&#13;
        .toLowerCase();&#13;
    } catch (e) {&#13;
      return '';&#13;
    }&#13;
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {&#13;
      return '';&#13;
    }&#13;
  }&#13;
  var out = '&lt;a href="' + href + '"';&#13;
  if (title) {&#13;
    out += ' title="' + title + '"';&#13;
  }&#13;
  out += '&gt;' + text + '&lt;/a&gt;';&#13;
  return out;&#13;
};&#13;
&#13;
Renderer.prototype.image = function(href, title, text) {&#13;
  var out = '&lt;img src="' + href + '" alt="' + text + '"';&#13;
  if (title) {&#13;
    out += ' title="' + title + '"';&#13;
  }&#13;
  out += this.options.xhtml ? '/&gt;' : '&gt;';&#13;
  return out;&#13;
};&#13;
&#13;
Renderer.prototype.text = function(text) {&#13;
  return text;&#13;
};&#13;
&#13;
/**&#13;
 * Parsing &amp; Compiling&#13;
 */&#13;
&#13;
function Parser(options) {&#13;
  this.tokens = [];&#13;
  this.token = null;&#13;
  this.options = options || marked.defaults;&#13;
  this.options.renderer = this.options.renderer || new Renderer;&#13;
  this.renderer = this.options.renderer;&#13;
  this.renderer.options = this.options;&#13;
}&#13;
&#13;
/**&#13;
 * Static Parse Method&#13;
 */&#13;
&#13;
Parser.parse = function(src, options, renderer) {&#13;
  var parser = new Parser(options, renderer);&#13;
  return parser.parse(src);&#13;
};&#13;
&#13;
/**&#13;
 * Parse Loop&#13;
 */&#13;
&#13;
Parser.prototype.parse = function(src) {&#13;
  this.inline = new InlineLexer(src.links, this.options, this.renderer);&#13;
  this.tokens = src.reverse();&#13;
&#13;
  var out = '';&#13;
  while (this.next()) {&#13;
    out += this.tok();&#13;
  }&#13;
&#13;
  return out;&#13;
};&#13;
&#13;
/**&#13;
 * Next Token&#13;
 */&#13;
&#13;
Parser.prototype.next = function() {&#13;
  return this.token = this.tokens.pop();&#13;
};&#13;
&#13;
/**&#13;
 * Preview Next Token&#13;
 */&#13;
&#13;
Parser.prototype.peek = function() {&#13;
  return this.tokens[this.tokens.length - 1] || 0;&#13;
};&#13;
&#13;
/**&#13;
 * Parse Text Tokens&#13;
 */&#13;
&#13;
Parser.prototype.parseText = function() {&#13;
  var body = this.token.text;&#13;
&#13;
  while (this.peek().type === 'text') {&#13;
    body += '\n' + this.next().text;&#13;
  }&#13;
&#13;
  return this.inline.output(body);&#13;
};&#13;
&#13;
/**&#13;
 * Parse Current Token&#13;
 */&#13;
&#13;
Parser.prototype.tok = function() {&#13;
  switch (this.token.type) {&#13;
    case 'space': {&#13;
      return '';&#13;
    }&#13;
    case 'hr': {&#13;
      return this.renderer.hr();&#13;
    }&#13;
    case 'heading': {&#13;
      return this.renderer.heading(&#13;
        this.inline.output(this.token.text),&#13;
        this.token.depth,&#13;
        this.token.text);&#13;
    }&#13;
    case 'code': {&#13;
      return this.renderer.code(this.token.text,&#13;
        this.token.lang,&#13;
        this.token.escaped);&#13;
    }&#13;
    case 'table': {&#13;
      var header = ''&#13;
        , body = ''&#13;
        , i&#13;
        , row&#13;
        , cell&#13;
        , flags&#13;
        , j;&#13;
&#13;
      // header&#13;
      cell = '';&#13;
      for (i = 0; i &lt; this.token.header.length; i++) {&#13;
        flags = { header: true, align: this.token.align[i] };&#13;
        cell += this.renderer.tablecell(&#13;
          this.inline.output(this.token.header[i]),&#13;
          { header: true, align: this.token.align[i] }&#13;
        );&#13;
      }&#13;
      header += this.renderer.tablerow(cell);&#13;
&#13;
      for (i = 0; i &lt; this.token.cells.length; i++) {&#13;
        row = this.token.cells[i];&#13;
&#13;
        cell = '';&#13;
        for (j = 0; j &lt; row.length; j++) {&#13;
          cell += this.renderer.tablecell(&#13;
            this.inline.output(row[j]),&#13;
            { header: false, align: this.token.align[j] }&#13;
          );&#13;
        }&#13;
&#13;
        body += this.renderer.tablerow(cell);&#13;
      }&#13;
      return this.renderer.table(header, body);&#13;
    }&#13;
    case 'blockquote_start': {&#13;
      var body = '';&#13;
&#13;
      while (this.next().type !== 'blockquote_end') {&#13;
        body += this.tok();&#13;
      }&#13;
&#13;
      return this.renderer.blockquote(body);&#13;
    }&#13;
    case 'list_start': {&#13;
      var body = ''&#13;
        , ordered = this.token.ordered;&#13;
&#13;
      while (this.next().type !== 'list_end') {&#13;
        body += this.tok();&#13;
      }&#13;
&#13;
      return this.renderer.list(body, ordered);&#13;
    }&#13;
    case 'list_item_start': {&#13;
      var body = '';&#13;
&#13;
      while (this.next().type !== 'list_item_end') {&#13;
        body += this.token.type === 'text'&#13;
          ? this.parseText()&#13;
          : this.tok();&#13;
      }&#13;
&#13;
      return this.renderer.listitem(body);&#13;
    }&#13;
    case 'loose_item_start': {&#13;
      var body = '';&#13;
&#13;
      while (this.next().type !== 'list_item_end') {&#13;
        body += this.tok();&#13;
      }&#13;
&#13;
      return this.renderer.listitem(body);&#13;
    }&#13;
    case 'html': {&#13;
      var html = !this.token.pre &amp;&amp; !this.options.pedantic&#13;
        ? this.inline.output(this.token.text)&#13;
        : this.token.text;&#13;
      return this.renderer.html(html);&#13;
    }&#13;
    case 'paragraph': {&#13;
      return this.renderer.paragraph(this.inline.output(this.token.text));&#13;
    }&#13;
    case 'text': {&#13;
      return this.renderer.paragraph(this.parseText());&#13;
    }&#13;
  }&#13;
};&#13;
&#13;
/**&#13;
 * Helpers&#13;
 */&#13;
&#13;
function escape(html, encode) {&#13;
  return html&#13;
    .replace(!encode ? /&amp;(?!#?\w+;)/g : /&amp;/g, '&amp;amp;')&#13;
    .replace(/&lt;/g, '&amp;lt;')&#13;
    .replace(/&gt;/g, '&amp;gt;')&#13;
    .replace(/"/g, '&amp;quot;')&#13;
    .replace(/'/g, '&amp;#39;');&#13;
}&#13;
&#13;
function unescape(html) {&#13;
  return html.replace(/&amp;([#\w]+);/g, function(_, n) {&#13;
    n = n.toLowerCase();&#13;
    if (n === 'colon') return ':';&#13;
    if (n.charAt(0) === '#') {&#13;
      return n.charAt(1) === 'x'&#13;
        ? String.fromCharCode(parseInt(n.substring(2), 16))&#13;
        : String.fromCharCode(+n.substring(1));&#13;
    }&#13;
    return '';&#13;
  });&#13;
}&#13;
&#13;
function replace(regex, opt) {&#13;
  regex = regex.source;&#13;
  opt = opt || '';&#13;
  return function self(name, val) {&#13;
    if (!name) return new RegExp(regex, opt);&#13;
    val = val.source || val;&#13;
    val = val.replace(/(^|[^\[])\^/g, '$1');&#13;
    regex = regex.replace(name, val);&#13;
    return self;&#13;
  };&#13;
}&#13;
&#13;
function noop() {}&#13;
noop.exec = noop;&#13;
&#13;
function merge(obj) {&#13;
  var i = 1&#13;
    , target&#13;
    , key;&#13;
&#13;
  for (; i &lt; arguments.length; i++) {&#13;
    target = arguments[i];&#13;
    for (key in target) {&#13;
      if (Object.prototype.hasOwnProperty.call(target, key)) {&#13;
        obj[key] = target[key];&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  return obj;&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Marked&#13;
 */&#13;
&#13;
function marked(src, opt, callback) {&#13;
  if (callback || typeof opt === 'function') {&#13;
    if (!callback) {&#13;
      callback = opt;&#13;
      opt = null;&#13;
    }&#13;
&#13;
    opt = merge({}, marked.defaults, opt || {});&#13;
&#13;
    var highlight = opt.highlight&#13;
      , tokens&#13;
      , pending&#13;
      , i = 0;&#13;
&#13;
    try {&#13;
      tokens = Lexer.lex(src, opt)&#13;
    } catch (e) {&#13;
      return callback(e);&#13;
    }&#13;
&#13;
    pending = tokens.length;&#13;
&#13;
    var done = function(err) {&#13;
      if (err) {&#13;
        opt.highlight = highlight;&#13;
        return callback(err);&#13;
      }&#13;
&#13;
      var out;&#13;
&#13;
      try {&#13;
        out = Parser.parse(tokens, opt);&#13;
      } catch (e) {&#13;
        err = e;&#13;
      }&#13;
&#13;
      opt.highlight = highlight;&#13;
&#13;
      return err&#13;
        ? callback(err)&#13;
        : callback(null, out);&#13;
    };&#13;
&#13;
    if (!highlight || highlight.length &lt; 3) {&#13;
      return done();&#13;
    }&#13;
&#13;
    delete opt.highlight;&#13;
&#13;
    if (!pending) return done();&#13;
&#13;
    for (; i &lt; tokens.length; i++) {&#13;
      (function(token) {&#13;
        if (token.type !== 'code') {&#13;
          return --pending || done();&#13;
        }&#13;
        return highlight(token.text, token.lang, function(err, code) {&#13;
          if (err) return done(err);&#13;
          if (code == null || code === token.text) {&#13;
            return --pending || done();&#13;
          }&#13;
          token.text = code;&#13;
          token.escaped = true;&#13;
          --pending || done();&#13;
        });&#13;
      })(tokens[i]);&#13;
    }&#13;
&#13;
    return;&#13;
  }&#13;
  try {&#13;
    if (opt) opt = merge({}, marked.defaults, opt);&#13;
    return Parser.parse(Lexer.lex(src, opt), opt);&#13;
  } catch (e) {&#13;
    e.message += '\nPlease report this to https://github.com/chjj/marked.';&#13;
    if ((opt || marked.defaults).silent) {&#13;
      return '&lt;p&gt;An error occured:&lt;/p&gt;&lt;pre&gt;'&#13;
        + escape(e.message + '', true)&#13;
        + '&lt;/pre&gt;';&#13;
    }&#13;
    throw e;&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * Options&#13;
 */&#13;
&#13;
marked.options =&#13;
marked.setOptions = function(opt) {&#13;
  merge(marked.defaults, opt);&#13;
  return marked;&#13;
};&#13;
&#13;
marked.defaults = {&#13;
  gfm: true,&#13;
  tables: true,&#13;
  breaks: false,&#13;
  pedantic: false,&#13;
  sanitize: false,&#13;
  sanitizer: null,&#13;
  mangle: true,&#13;
  smartLists: false,&#13;
  silent: false,&#13;
  highlight: null,&#13;
  langPrefix: 'lang-',&#13;
  smartypants: false,&#13;
  headerPrefix: '',&#13;
  renderer: new Renderer,&#13;
  xhtml: false&#13;
};&#13;
&#13;
/**&#13;
 * Expose&#13;
 */&#13;
&#13;
marked.Parser = Parser;&#13;
marked.parser = Parser.parse;&#13;
&#13;
marked.Renderer = Renderer;&#13;
&#13;
marked.Lexer = Lexer;&#13;
marked.lexer = Lexer.lex;&#13;
&#13;
marked.InlineLexer = InlineLexer;&#13;
marked.inlineLexer = InlineLexer.output;&#13;
&#13;
marked.parse = marked;&#13;
&#13;
if (typeof module !== 'undefined' &amp;&amp; typeof exports === 'object') {&#13;
  module.exports = marked;&#13;
} else if (typeof define === 'function' &amp;&amp; define.amd) {&#13;
  define(function() { return marked; });&#13;
} else {&#13;
  this.marked = marked;&#13;
}&#13;
&#13;
}).call(function() {&#13;
  return this || (typeof window !== 'undefined' ? window : global);&#13;
}());&#13;
&#13;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})&#13;
},{}],18:[function(require,module,exports){&#13;
(function (Buffer,__dirname){&#13;
'use strict';&#13;
&#13;
/**&#13;
 * Typo is a JavaScript implementation of a spellchecker using hunspell-style &#13;
 * dictionaries.&#13;
 */&#13;
&#13;
/**&#13;
 * Typo constructor.&#13;
 *&#13;
 * @param {String} [dictionary] The locale code of the dictionary being used. e.g.,&#13;
 *                              "en_US". This is only used to auto-load dictionaries.&#13;
 * @param {String} [affData]    The data from the dictionary's .aff file. If omitted&#13;
 *                              and Typo.js is being used in a Chrome extension, the .aff&#13;
 *                              file will be loaded automatically from&#13;
 *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff&#13;
 *                              In other environments, it will be loaded from&#13;
 *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff&#13;
 * @param {String} [wordsData]  The data from the dictionary's .dic file. If omitted&#13;
 *                              and Typo.js is being used in a Chrome extension, the .dic&#13;
 *                              file will be loaded automatically from&#13;
 *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic&#13;
 *                              In other environments, it will be loaded from&#13;
 *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic&#13;
 * @param {Object} [settings]   Constructor settings. Available properties are:&#13;
 *                              {String} [dictionaryPath]: path to load dictionary from in non-chrome&#13;
 *                              environment.&#13;
 *                              {Object} [flags]: flag information.&#13;
 *&#13;
 *&#13;
 * @returns {Typo} A Typo object.&#13;
 */&#13;
&#13;
var Typo = function (dictionary, affData, wordsData, settings) {&#13;
	settings = settings || {};&#13;
	&#13;
	this.dictionary = null;&#13;
	&#13;
	this.rules = {};&#13;
	this.dictionaryTable = {};&#13;
	&#13;
	this.compoundRules = [];&#13;
	this.compoundRuleCodes = {};&#13;
	&#13;
	this.replacementTable = [];&#13;
	&#13;
	this.flags = settings.flags || {}; &#13;
	&#13;
	if (dictionary) {&#13;
		this.dictionary = dictionary;&#13;
		&#13;
		if (typeof window !== 'undefined' &amp;&amp; 'chrome' in window &amp;&amp; 'extension' in window.chrome &amp;&amp; 'getURL' in window.chrome.extension) {&#13;
			if (!affData) affData = this._readFile(chrome.extension.getURL("lib/typo/dictionaries/" + dictionary + "/" + dictionary + ".aff"));&#13;
			if (!wordsData) wordsData = this._readFile(chrome.extension.getURL("lib/typo/dictionaries/" + dictionary + "/" + dictionary + ".dic"));&#13;
		} else {&#13;
			if (settings.dictionaryPath) {&#13;
				var path = settings.dictionaryPath;&#13;
			}&#13;
			else if (typeof __dirname !== 'undefined') {&#13;
				var path = __dirname + '/dictionaries';&#13;
			}&#13;
			else {&#13;
				var path = './dictionaries';&#13;
			}&#13;
			&#13;
			if (!affData) affData = this._readFile(path + "/" + dictionary + "/" + dictionary + ".aff");&#13;
			if (!wordsData) wordsData = this._readFile(path + "/" + dictionary + "/" + dictionary + ".dic");&#13;
		}&#13;
		&#13;
		this.rules = this._parseAFF(affData);&#13;
		&#13;
		// Save the rule codes that are used in compound rules.&#13;
		this.compoundRuleCodes = {};&#13;
		&#13;
		for (var i = 0, _len = this.compoundRules.length; i &lt; _len; i++) {&#13;
			var rule = this.compoundRules[i];&#13;
			&#13;
			for (var j = 0, _jlen = rule.length; j &lt; _jlen; j++) {&#13;
				this.compoundRuleCodes[rule[j]] = [];&#13;
			}&#13;
		}&#13;
		&#13;
		// If we add this ONLYINCOMPOUND flag to this.compoundRuleCodes, then _parseDIC&#13;
		// will do the work of saving the list of words that are compound-only.&#13;
		if ("ONLYINCOMPOUND" in this.flags) {&#13;
			this.compoundRuleCodes[this.flags.ONLYINCOMPOUND] = [];&#13;
		}&#13;
		&#13;
		this.dictionaryTable = this._parseDIC(wordsData);&#13;
		&#13;
		// Get rid of any codes from the compound rule codes that are never used &#13;
		// (or that were special regex characters).  Not especially necessary... &#13;
		for (var i in this.compoundRuleCodes) {&#13;
			if (this.compoundRuleCodes[i].length == 0) {&#13;
				delete this.compoundRuleCodes[i];&#13;
			}&#13;
		}&#13;
		&#13;
		// Build the full regular expressions for each compound rule.&#13;
		// I have a feeling (but no confirmation yet) that this method of &#13;
		// testing for compound words is probably slow.&#13;
		for (var i = 0, _len = this.compoundRules.length; i &lt; _len; i++) {&#13;
			var ruleText = this.compoundRules[i];&#13;
			&#13;
			var expressionText = "";&#13;
			&#13;
			for (var j = 0, _jlen = ruleText.length; j &lt; _jlen; j++) {&#13;
				var character = ruleText[j];&#13;
				&#13;
				if (character in this.compoundRuleCodes) {&#13;
					expressionText += "(" + this.compoundRuleCodes[character].join("|") + ")";&#13;
				}&#13;
				else {&#13;
					expressionText += character;&#13;
				}&#13;
			}&#13;
			&#13;
			this.compoundRules[i] = new RegExp(expressionText, "i");&#13;
		}&#13;
	}&#13;
	&#13;
	return this;&#13;
};&#13;
&#13;
Typo.prototype = {&#13;
	/**&#13;
	 * Loads a Typo instance from a hash of all of the Typo properties.&#13;
	 *&#13;
	 * @param object obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).&#13;
	 */&#13;
	&#13;
	load : function (obj) {&#13;
		for (var i in obj) {&#13;
			this[i] = obj[i];&#13;
		}&#13;
		&#13;
		return this;&#13;
	},&#13;
	&#13;
	/**&#13;
	 * Read the contents of a file.&#13;
	 * &#13;
	 * @param {String} path The path (relative) to the file.&#13;
	 * @param {String} [charset="ISO8859-1"] The expected charset of the file&#13;
	 * @returns string The file data.&#13;
	 */&#13;
	&#13;
	_readFile : function (path, charset) {&#13;
		if (!charset) charset = "utf8";&#13;
		&#13;
		if (typeof XMLHttpRequest !== 'undefined') {&#13;
			var req = new XMLHttpRequest();&#13;
			req.open("GET", path, false);&#13;
		&#13;
			if (req.overrideMimeType)&#13;
				req.overrideMimeType("text/plain; charset=" + charset);&#13;
		&#13;
			req.send(null);&#13;
			&#13;
			return req.responseText;&#13;
		}&#13;
		else if (typeof require !== 'undefined') {&#13;
			// Node.js&#13;
			var fs = require("fs");&#13;
			&#13;
			try {&#13;
				if (fs.existsSync(path)) {&#13;
					var stats = fs.statSync(path);&#13;
					&#13;
					var fileDescriptor = fs.openSync(path, 'r');&#13;
					&#13;
					var buffer = new Buffer(stats.size);&#13;
					&#13;
					fs.readSync(fileDescriptor, buffer, 0, buffer.length, null);&#13;
					&#13;
					return buffer.toString(charset, 0, buffer.length);&#13;
				}&#13;
				else {&#13;
					console.log("Path " + path + " does not exist.");&#13;
				}&#13;
			} catch (e) {&#13;
				console.log(e);&#13;
				return '';&#13;
			}&#13;
		}&#13;
	},&#13;
	&#13;
	/**&#13;
	 * Parse the rules out from a .aff file.&#13;
	 *&#13;
	 * @param {String} data The contents of the affix file.&#13;
	 * @returns object The rules from the file.&#13;
	 */&#13;
	&#13;
	_parseAFF : function (data) {&#13;
		var rules = {};&#13;
		&#13;
		// Remove comment lines&#13;
		data = this._removeAffixComments(data);&#13;
		&#13;
		var lines = data.split("\n");&#13;
		&#13;
		for (var i = 0, _len = lines.length; i &lt; _len; i++) {&#13;
			var line = lines[i];&#13;
			&#13;
			var definitionParts = line.split(/\s+/);&#13;
			&#13;
			var ruleType = definitionParts[0];&#13;
			&#13;
			if (ruleType == "PFX" || ruleType == "SFX") {&#13;
				var ruleCode = definitionParts[1];&#13;
				var combineable = definitionParts[2];&#13;
				var numEntries = parseInt(definitionParts[3], 10);&#13;
				&#13;
				var entries = [];&#13;
				&#13;
				for (var j = i + 1, _jlen = i + 1 + numEntries; j &lt; _jlen; j++) {&#13;
					var line = lines[j];&#13;
					&#13;
					var lineParts = line.split(/\s+/);&#13;
					var charactersToRemove = lineParts[2];&#13;
					&#13;
					var additionParts = lineParts[3].split("/");&#13;
					&#13;
					var charactersToAdd = additionParts[0];&#13;
					if (charactersToAdd === "0") charactersToAdd = "";&#13;
					&#13;
					var continuationClasses = this.parseRuleCodes(additionParts[1]);&#13;
					&#13;
					var regexToMatch = lineParts[4];&#13;
					&#13;
					var entry = {};&#13;
					entry.add = charactersToAdd;&#13;
					&#13;
					if (continuationClasses.length &gt; 0) entry.continuationClasses = continuationClasses;&#13;
					&#13;
					if (regexToMatch !== ".") {&#13;
						if (ruleType === "SFX") {&#13;
							entry.match = new RegExp(regexToMatch + "$");&#13;
						}&#13;
						else {&#13;
							entry.match = new RegExp("^" + regexToMatch);&#13;
						}&#13;
					}&#13;
					&#13;
					if (charactersToRemove != "0") {&#13;
						if (ruleType === "SFX") {&#13;
							entry.remove = new RegExp(charactersToRemove  + "$");&#13;
						}&#13;
						else {&#13;
							entry.remove = charactersToRemove;&#13;
						}&#13;
					}&#13;
					&#13;
					entries.push(entry);&#13;
				}&#13;
				&#13;
				rules[ruleCode] = { "type" : ruleType, "combineable" : (combineable == "Y"), "entries" : entries };&#13;
				&#13;
				i += numEntries;&#13;
			}&#13;
			else if (ruleType === "COMPOUNDRULE") {&#13;
				var numEntries = parseInt(definitionParts[1], 10);&#13;
				&#13;
				for (var j = i + 1, _jlen = i + 1 + numEntries; j &lt; _jlen; j++) {&#13;
					var line = lines[j];&#13;
					&#13;
					var lineParts = line.split(/\s+/);&#13;
					this.compoundRules.push(lineParts[1]);&#13;
				}&#13;
				&#13;
				i += numEntries;&#13;
			}&#13;
			else if (ruleType === "REP") {&#13;
				var lineParts = line.split(/\s+/);&#13;
				&#13;
				if (lineParts.length === 3) {&#13;
					this.replacementTable.push([ lineParts[1], lineParts[2] ]);&#13;
				}&#13;
			}&#13;
			else {&#13;
				// ONLYINCOMPOUND&#13;
				// COMPOUNDMIN&#13;
				// FLAG&#13;
				// KEEPCASE&#13;
				// NEEDAFFIX&#13;
				&#13;
				this.flags[ruleType] = definitionParts[1];&#13;
			}&#13;
		}&#13;
		&#13;
		return rules;&#13;
	},&#13;
	&#13;
	/**&#13;
	 * Removes comment lines and then cleans up blank lines and trailing whitespace.&#13;
	 *&#13;
	 * @param {String} data The data from an affix file.&#13;
	 * @return {String} The cleaned-up data.&#13;
	 */&#13;
	&#13;
	_removeAffixComments : function (data) {&#13;
		// Remove comments&#13;
		data = data.replace(/#.*$/mg, "");&#13;
		&#13;
		// Trim each line&#13;
		data = data.replace(/^\s\s*/m, '').replace(/\s\s*$/m, '');&#13;
		&#13;
		// Remove blank lines.&#13;
		data = data.replace(/\n{2,}/g, "\n");&#13;
		&#13;
		// Trim the entire string&#13;
		data = data.replace(/^\s\s*/, '').replace(/\s\s*$/, '');&#13;
		&#13;
		return data;&#13;
	},&#13;
	&#13;
	/**&#13;
	 * Parses the words out from the .dic file.&#13;
	 *&#13;
	 * @param {String} data The data from the dictionary file.&#13;
	 * @returns object The lookup table containing all of the words and&#13;
	 *                 word forms from the dictionary.&#13;
	 */&#13;
	&#13;
	_parseDIC : function (data) {&#13;
		data = this._removeDicComments(data);&#13;
		&#13;
		var lines = data.split("\n");&#13;
		var dictionaryTable = {};&#13;
		&#13;
		function addWord(word, rules) {&#13;
			// Some dictionaries will list the same word multiple times with different rule sets.&#13;
			if (!(word in dictionaryTable) || typeof dictionaryTable[word] != 'object') {&#13;
				dictionaryTable[word] = [];&#13;
			}&#13;
			&#13;
			dictionaryTable[word].push(rules);&#13;
		}&#13;
		&#13;
		// The first line is the number of words in the dictionary.&#13;
		for (var i = 1, _len = lines.length; i &lt; _len; i++) {&#13;
			var line = lines[i];&#13;
			&#13;
			var parts = line.split("/", 2);&#13;
			&#13;
			var word = parts[0];&#13;
&#13;
			// Now for each affix rule, generate that form of the word.&#13;
			if (parts.length &gt; 1) {&#13;
				var ruleCodesArray = this.parseRuleCodes(parts[1]);&#13;
				&#13;
				// Save the ruleCodes for compound word situations.&#13;
				if (!("NEEDAFFIX" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {&#13;
					addWord(word, ruleCodesArray);&#13;
				}&#13;
				&#13;
				for (var j = 0, _jlen = ruleCodesArray.length; j &lt; _jlen; j++) {&#13;
					var code = ruleCodesArray[j];&#13;
					&#13;
					var rule = this.rules[code];&#13;
					&#13;
					if (rule) {&#13;
						var newWords = this._applyRule(word, rule);&#13;
						&#13;
						for (var ii = 0, _iilen = newWords.length; ii &lt; _iilen; ii++) {&#13;
							var newWord = newWords[ii];&#13;
							&#13;
							addWord(newWord, []);&#13;
							&#13;
							if (rule.combineable) {&#13;
								for (var k = j + 1; k &lt; _jlen; k++) {&#13;
									var combineCode = ruleCodesArray[k];&#13;
									&#13;
									var combineRule = this.rules[combineCode];&#13;
									&#13;
									if (combineRule) {&#13;
										if (combineRule.combineable &amp;&amp; (rule.type != combineRule.type)) {&#13;
											var otherNewWords = this._applyRule(newWord, combineRule);&#13;
											&#13;
											for (var iii = 0, _iiilen = otherNewWords.length; iii &lt; _iiilen; iii++) {&#13;
												var otherNewWord = otherNewWords[iii];&#13;
												addWord(otherNewWord, []);&#13;
											}&#13;
										}&#13;
									}&#13;
								}&#13;
							}&#13;
						}&#13;
					}&#13;
					&#13;
					if (code in this.compoundRuleCodes) {&#13;
						this.compoundRuleCodes[code].push(word);&#13;
					}&#13;
				}&#13;
			}&#13;
			else {&#13;
				addWord(word.trim(), []);&#13;
			}&#13;
		}&#13;
		&#13;
		return dictionaryTable;&#13;
	},&#13;
	&#13;
	&#13;
	/**&#13;
	 * Removes comment lines and then cleans up blank lines and trailing whitespace.&#13;
	 *&#13;
	 * @param {String} data The data from a .dic file.&#13;
	 * @return {String} The cleaned-up data.&#13;
	 */&#13;
	&#13;
	_removeDicComments : function (data) {&#13;
		// I can't find any official documentation on it, but at least the de_DE&#13;
		// dictionary uses tab-indented lines as comments.&#13;
		&#13;
		// Remove comments&#13;
		data = data.replace(/^\t.*$/mg, "");&#13;
		&#13;
		return data;&#13;
	},&#13;
	&#13;
	parseRuleCodes : function (textCodes) {&#13;
		if (!textCodes) {&#13;
			return [];&#13;
		}&#13;
		else if (!("FLAG" in this.flags)) {&#13;
			return textCodes.split("");&#13;
		}&#13;
		else if (this.flags.FLAG === "long") {&#13;
			var flags = [];&#13;
			&#13;
			for (var i = 0, _len = textCodes.length; i &lt; _len; i += 2) {&#13;
				flags.push(textCodes.substr(i, 2));&#13;
			}&#13;
			&#13;
			return flags;&#13;
		}&#13;
		else if (this.flags.FLAG === "num") {&#13;
			return textCode.split(",");&#13;
		}&#13;
	},&#13;
	&#13;
	/**&#13;
	 * Applies an affix rule to a word.&#13;
	 *&#13;
	 * @param {String} word The base word.&#13;
	 * @param {Object} rule The affix rule.&#13;
	 * @returns {String[]} The new words generated by the rule.&#13;
	 */&#13;
	&#13;
	_applyRule : function (word, rule) {&#13;
		var entries = rule.entries;&#13;
		var newWords = [];&#13;
		&#13;
		for (var i = 0, _len = entries.length; i &lt; _len; i++) {&#13;
			var entry = entries[i];&#13;
			&#13;
			if (!entry.match || word.match(entry.match)) {&#13;
				var newWord = word;&#13;
				&#13;
				if (entry.remove) {&#13;
					newWord = newWord.replace(entry.remove, "");&#13;
				}&#13;
				&#13;
				if (rule.type === "SFX") {&#13;
					newWord = newWord + entry.add;&#13;
				}&#13;
				else {&#13;
					newWord = entry.add + newWord;&#13;
				}&#13;
				&#13;
				newWords.push(newWord);&#13;
				&#13;
				if ("continuationClasses" in entry) {&#13;
					for (var j = 0, _jlen = entry.continuationClasses.length; j &lt; _jlen; j++) {&#13;
						var continuationRule = this.rules[entry.continuationClasses[j]];&#13;
						&#13;
						if (continuationRule) {&#13;
							newWords = newWords.concat(this._applyRule(newWord, continuationRule));&#13;
						}&#13;
						/*&#13;
						else {&#13;
							// This shouldn't happen, but it does, at least in the de_DE dictionary.&#13;
							// I think the author mistakenly supplied lower-case rule codes instead &#13;
							// of upper-case.&#13;
						}&#13;
						*/&#13;
					}&#13;
				}&#13;
			}&#13;
		}&#13;
		&#13;
		return newWords;&#13;
	},&#13;
	&#13;
	/**&#13;
	 * Checks whether a word or a capitalization variant exists in the current dictionary.&#13;
	 * The word is trimmed and several variations of capitalizations are checked.&#13;
	 * If you want to check a word without any changes made to it, call checkExact()&#13;
	 *&#13;
	 * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function&#13;
	 *&#13;
	 * @param {String} aWord The word to check.&#13;
	 * @returns {Boolean}&#13;
	 */&#13;
	&#13;
	check : function (aWord) {&#13;
		// Remove leading and trailing whitespace&#13;
		var trimmedWord = aWord.replace(/^\s\s*/, '').replace(/\s\s*$/, '');&#13;
		&#13;
		if (this.checkExact(trimmedWord)) {&#13;
			return true;&#13;
		}&#13;
		&#13;
		// The exact word is not in the dictionary.&#13;
		if (trimmedWord.toUpperCase() === trimmedWord) {&#13;
			// The word was supplied in all uppercase.&#13;
			// Check for a capitalized form of the word.&#13;
			var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();&#13;
			&#13;
			if (this.hasFlag(capitalizedWord, "KEEPCASE")) {&#13;
				// Capitalization variants are not allowed for this word.&#13;
				return false;&#13;
			}&#13;
			&#13;
			if (this.checkExact(capitalizedWord)) {&#13;
				return true;&#13;
			}&#13;
		}&#13;
		&#13;
		var lowercaseWord = trimmedWord.toLowerCase();&#13;
		&#13;
		if (lowercaseWord !== trimmedWord) {&#13;
			if (this.hasFlag(lowercaseWord, "KEEPCASE")) {&#13;
				// Capitalization variants are not allowed for this word.&#13;
				return false;&#13;
			}&#13;
			&#13;
			// Check for a lowercase form&#13;
			if (this.checkExact(lowercaseWord)) {&#13;
				return true;&#13;
			}&#13;
		}&#13;
		&#13;
		return false;&#13;
	},&#13;
	&#13;
	/**&#13;
	 * Checks whether a word exists in the current dictionary.&#13;
	 *&#13;
	 * @param {String} word The word to check.&#13;
	 * @returns {Boolean}&#13;
	 */&#13;
	&#13;
	checkExact : function (word) {&#13;
		var ruleCodes = this.dictionaryTable[word];&#13;
		&#13;
		if (typeof ruleCodes === 'undefined') {&#13;
			// Check if this might be a compound word.&#13;
			if ("COMPOUNDMIN" in this.flags &amp;&amp; word.length &gt;= this.flags.COMPOUNDMIN) {&#13;
				for (var i = 0, _len = this.compoundRules.length; i &lt; _len; i++) {&#13;
					if (word.match(this.compoundRules[i])) {&#13;
						return true;&#13;
					}&#13;
				}&#13;
			}&#13;
			&#13;
			return false;&#13;
		}&#13;
		else if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.&#13;
			for (var i = 0, _len = ruleCodes.length; i &lt; _len; i++) {&#13;
				if (!this.hasFlag(word, "ONLYINCOMPOUND", ruleCodes[i])) {&#13;
					return true;&#13;
				}&#13;
			}&#13;
			&#13;
			return false;&#13;
		}&#13;
	},&#13;
	&#13;
	/**&#13;
	 * Looks up whether a given word is flagged with a given flag.&#13;
	 *&#13;
	 * @param {String} word The word in question.&#13;
	 * @param {String} flag The flag in question.&#13;
	 * @return {Boolean}&#13;
	 */&#13;
	 &#13;
	hasFlag : function (word, flag, wordFlags) {&#13;
		if (flag in this.flags) {&#13;
			if (typeof wordFlags === 'undefined') {&#13;
				var wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);&#13;
			}&#13;
			&#13;
			if (wordFlags &amp;&amp; wordFlags.indexOf(this.flags[flag]) !== -1) {&#13;
				return true;&#13;
			}&#13;
		}&#13;
		&#13;
		return false;&#13;
	},&#13;
	&#13;
	/**&#13;
	 * Returns a list of suggestions for a misspelled word.&#13;
	 *&#13;
	 * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.&#13;
	 * This suggestor is primitive, but it works.&#13;
	 *&#13;
	 * @param {String} word The misspelling.&#13;
	 * @param {Number} [limit=5] The maximum number of suggestions to return.&#13;
	 * @returns {String[]} The array of suggestions.&#13;
	 */&#13;
	&#13;
	alphabet : "",&#13;
	&#13;
	suggest : function (word, limit) {&#13;
		if (!limit) limit = 5;&#13;
		&#13;
		if (this.check(word)) return [];&#13;
		&#13;
		// Check the replacement table.&#13;
		for (var i = 0, _len = this.replacementTable.length; i &lt; _len; i++) {&#13;
			var replacementEntry = this.replacementTable[i];&#13;
			&#13;
			if (word.indexOf(replacementEntry[0]) !== -1) {&#13;
				var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);&#13;
				&#13;
				if (this.check(correctedWord)) {&#13;
					return [ correctedWord ];&#13;
				}&#13;
			}&#13;
		}&#13;
		&#13;
		var self = this;&#13;
		self.alphabet = "abcdefghijklmnopqrstuvwxyz";&#13;
		&#13;
		/*&#13;
		if (!self.alphabet) {&#13;
			// Use the alphabet as implicitly defined by the words in the dictionary.&#13;
			var alphaHash = {};&#13;
			&#13;
			for (var i in self.dictionaryTable) {&#13;
				for (var j = 0, _len = i.length; j &lt; _len; j++) {&#13;
					alphaHash[i[j]] = true;&#13;
				}&#13;
			}&#13;
			&#13;
			for (var i in alphaHash) {&#13;
				self.alphabet += i;&#13;
			}&#13;
			&#13;
			var alphaArray = self.alphabet.split("");&#13;
			alphaArray.sort();&#13;
			self.alphabet = alphaArray.join("");&#13;
		}&#13;
		*/&#13;
		&#13;
		function edits1(words) {&#13;
			var rv = [];&#13;
			&#13;
			for (var ii = 0, _iilen = words.length; ii &lt; _iilen; ii++) {&#13;
				var word = words[ii];&#13;
				&#13;
				var splits = [];&#13;
			&#13;
				for (var i = 0, _len = word.length + 1; i &lt; _len; i++) {&#13;
					splits.push([ word.substring(0, i), word.substring(i, word.length) ]);&#13;
				}&#13;
			&#13;
				var deletes = [];&#13;
			&#13;
				for (var i = 0, _len = splits.length; i &lt; _len; i++) {&#13;
					var s = splits[i];&#13;
				&#13;
					if (s[1]) {&#13;
						deletes.push(s[0] + s[1].substring(1));&#13;
					}&#13;
				}&#13;
			&#13;
				var transposes = [];&#13;
			&#13;
				for (var i = 0, _len = splits.length; i &lt; _len; i++) {&#13;
					var s = splits[i];&#13;
				&#13;
					if (s[1].length &gt; 1) {&#13;
						transposes.push(s[0] + s[1][1] + s[1][0] + s[1].substring(2));&#13;
					}&#13;
				}&#13;
			&#13;
				var replaces = [];&#13;
			&#13;
				for (var i = 0, _len = splits.length; i &lt; _len; i++) {&#13;
					var s = splits[i];&#13;
				&#13;
					if (s[1]) {&#13;
						for (var j = 0, _jlen = self.alphabet.length; j &lt; _jlen; j++) {&#13;
							replaces.push(s[0] + self.alphabet[j] + s[1].substring(1));&#13;
						}&#13;
					}&#13;
				}&#13;
			&#13;
				var inserts = [];&#13;
			&#13;
				for (var i = 0, _len = splits.length; i &lt; _len; i++) {&#13;
					var s = splits[i];&#13;
				&#13;
					if (s[1]) {&#13;
						for (var j = 0, _jlen = self.alphabet.length; j &lt; _jlen; j++) {&#13;
							replaces.push(s[0] + self.alphabet[j] + s[1]);&#13;
						}&#13;
					}&#13;
				}&#13;
			&#13;
				rv = rv.concat(deletes);&#13;
				rv = rv.concat(transposes);&#13;
				rv = rv.concat(replaces);&#13;
				rv = rv.concat(inserts);&#13;
			}&#13;
			&#13;
			return rv;&#13;
		}&#13;
		&#13;
		function known(words) {&#13;
			var rv = [];&#13;
			&#13;
			for (var i = 0; i &lt; words.length; i++) {&#13;
				if (self.check(words[i])) {&#13;
					rv.push(words[i]);&#13;
				}&#13;
			}&#13;
			&#13;
			return rv;&#13;
		}&#13;
		&#13;
		function correct(word) {&#13;
			// Get the edit-distance-1 and edit-distance-2 forms of this word.&#13;
			var ed1 = edits1([word]);&#13;
			var ed2 = edits1(ed1);&#13;
			&#13;
			var corrections = known(ed1).concat(known(ed2));&#13;
			&#13;
			// Sort the edits based on how many different ways they were created.&#13;
			var weighted_corrections = {};&#13;
			&#13;
			for (var i = 0, _len = corrections.length; i &lt; _len; i++) {&#13;
				if (!(corrections[i] in weighted_corrections)) {&#13;
					weighted_corrections[corrections[i]] = 1;&#13;
				}&#13;
				else {&#13;
					weighted_corrections[corrections[i]] += 1;&#13;
				}&#13;
			}&#13;
			&#13;
			var sorted_corrections = [];&#13;
			&#13;
			for (var i in weighted_corrections) {&#13;
				sorted_corrections.push([ i, weighted_corrections[i] ]);&#13;
			}&#13;
			&#13;
			function sorter(a, b) {&#13;
				if (a[1] &lt; b[1]) {&#13;
					return -1;&#13;
				}&#13;
				&#13;
				return 1;&#13;
			}&#13;
			&#13;
			sorted_corrections.sort(sorter).reverse();&#13;
			&#13;
			var rv = [];&#13;
			&#13;
			for (var i = 0, _len = Math.min(limit, sorted_corrections.length); i &lt; _len; i++) {&#13;
				if (!self.hasFlag(sorted_corrections[i][0], "NOSUGGEST")) {&#13;
					rv.push(sorted_corrections[i][0]);&#13;
				}&#13;
			}&#13;
			&#13;
			return rv;&#13;
		}&#13;
		&#13;
		return correct(word);&#13;
	}&#13;
};&#13;
&#13;
// Support for use as a node.js module.&#13;
if (typeof module !== 'undefined') {&#13;
	module.exports = Typo;&#13;
}&#13;
}).call(this,require("buffer").Buffer,"/node_modules/typo-js")&#13;
},{"buffer":3,"fs":2}],19:[function(require,module,exports){&#13;
// CodeMirror, copyright (c) by Marijn Haverbeke and others&#13;
// Distributed under an MIT license: http://codemirror.net/LICENSE&#13;
&#13;
var CodeMirror = require("codemirror");&#13;
&#13;
CodeMirror.commands.tabAndIndentMarkdownList = function (cm) {&#13;
	var ranges = cm.listSelections();&#13;
	var pos = ranges[0].head;&#13;
	var eolState = cm.getStateAfter(pos.line);&#13;
	var inList = eolState.list !== false;&#13;
&#13;
	if (inList) {&#13;
		cm.execCommand("indentMore");&#13;
		return;&#13;
	}&#13;
&#13;
	if (cm.options.indentWithTabs) {&#13;
		cm.execCommand("insertTab");&#13;
	}&#13;
	else {&#13;
		var spaces = Array(cm.options.tabSize + 1).join(" ");&#13;
		cm.replaceSelection(spaces);&#13;
	}&#13;
};&#13;
&#13;
CodeMirror.commands.shiftTabAndUnindentMarkdownList = function (cm) {&#13;
	var ranges = cm.listSelections();&#13;
	var pos = ranges[0].head;&#13;
	var eolState = cm.getStateAfter(pos.line);&#13;
	var inList = eolState.list !== false;&#13;
&#13;
	if (inList) {&#13;
		cm.execCommand("indentLess");&#13;
		return;&#13;
	}&#13;
&#13;
	if (cm.options.indentWithTabs) {&#13;
		cm.execCommand("insertTab");&#13;
	}&#13;
	else {&#13;
		var spaces = Array(cm.options.tabSize + 1).join(" ");&#13;
		cm.replaceSelection(spaces);&#13;
	}&#13;
};&#13;
&#13;
},{"codemirror":10}],20:[function(require,module,exports){&#13;
/*global require,module*/&#13;
"use strict";&#13;
var CodeMirror = require("codemirror");&#13;
require("codemirror/addon/edit/continuelist.js");&#13;
require("./codemirror/tablist");&#13;
require("codemirror/addon/display/fullscreen.js");&#13;
require("codemirror/mode/markdown/markdown.js");&#13;
require("codemirror/addon/mode/overlay.js");&#13;
require("codemirror/addon/display/placeholder.js");&#13;
require("codemirror/addon/selection/mark-selection.js");&#13;
require("codemirror/mode/gfm/gfm.js");&#13;
require("codemirror/mode/xml/xml.js");&#13;
var CodeMirrorSpellChecker = require("codemirror-spell-checker");&#13;
var marked = require("marked");&#13;
&#13;
&#13;
// Some variables&#13;
var isMac = /Mac/.test(navigator.platform);&#13;
&#13;
// Mapping of actions that can be bound to keyboard shortcuts or toolbar buttons&#13;
var bindings = {&#13;
	"toggleBold": toggleBold,&#13;
	"toggleItalic": toggleItalic,&#13;
	"drawLink": drawLink,&#13;
	"toggleHeadingSmaller": toggleHeadingSmaller,&#13;
	"toggleHeadingBigger": toggleHeadingBigger,&#13;
	"drawImage": drawImage,&#13;
	"toggleBlockquote": toggleBlockquote,&#13;
	"toggleOrderedList": toggleOrderedList,&#13;
	"toggleUnorderedList": toggleUnorderedList,&#13;
	"toggleCodeBlock": toggleCodeBlock,&#13;
	"togglePreview": togglePreview,&#13;
	"toggleStrikethrough": toggleStrikethrough,&#13;
	"toggleHeading1": toggleHeading1,&#13;
	"toggleHeading2": toggleHeading2,&#13;
	"toggleHeading3": toggleHeading3,&#13;
	"cleanBlock": cleanBlock,&#13;
	"drawTable": drawTable,&#13;
	"drawHorizontalRule": drawHorizontalRule,&#13;
	"undo": undo,&#13;
	"redo": redo,&#13;
	"toggleSideBySide": toggleSideBySide,&#13;
	"toggleFullScreen": toggleFullScreen&#13;
};&#13;
&#13;
var shortcuts = {&#13;
	"toggleBold": "Cmd-B",&#13;
	"toggleItalic": "Cmd-I",&#13;
	"drawLink": "Cmd-K",&#13;
	"toggleHeadingSmaller": "Cmd-H",&#13;
	"toggleHeadingBigger": "Shift-Cmd-H",&#13;
	"cleanBlock": "Cmd-E",&#13;
	"drawImage": "Cmd-Alt-I",&#13;
	"toggleBlockquote": "Cmd-'",&#13;
	"toggleOrderedList": "Cmd-Alt-L",&#13;
	"toggleUnorderedList": "Cmd-L",&#13;
	"toggleCodeBlock": "Cmd-Alt-C",&#13;
	"togglePreview": "Cmd-P",&#13;
	"toggleSideBySide": "F9",&#13;
	"toggleFullScreen": "F11"&#13;
};&#13;
&#13;
var getBindingName = function(f) {&#13;
	for(var key in bindings) {&#13;
		if(bindings[key] === f) {&#13;
			return key;&#13;
		}&#13;
	}&#13;
	return null;&#13;
};&#13;
&#13;
var isMobile = function() {&#13;
	var check = false;&#13;
	(function(a) {&#13;
		if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;&#13;
	})(navigator.userAgent || navigator.vendor || window.opera);&#13;
	return check;&#13;
};&#13;
&#13;
&#13;
/**&#13;
 * Fix shortcut. Mac use Command, others use Ctrl.&#13;
 */&#13;
function fixShortcut(name) {&#13;
	if(isMac) {&#13;
		name = name.replace("Ctrl", "Cmd");&#13;
	} else {&#13;
		name = name.replace("Cmd", "Ctrl");&#13;
	}&#13;
	return name;&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Create icon element for toolbar.&#13;
 */&#13;
function createIcon(options, enableTooltips, shortcuts) {&#13;
	options = options || {};&#13;
	var el = document.createElement("a");&#13;
	enableTooltips = (enableTooltips == undefined) ? true : enableTooltips;&#13;
&#13;
	if(options.title &amp;&amp; enableTooltips) {&#13;
		el.title = createTootlip(options.title, options.action, shortcuts);&#13;
&#13;
		if(isMac) {&#13;
			el.title = el.title.replace("Ctrl", "");&#13;
			el.title = el.title.replace("Alt", "");&#13;
		}&#13;
	}&#13;
&#13;
	el.tabIndex = -1;&#13;
	el.className = options.className;&#13;
	return el;&#13;
}&#13;
&#13;
function createSep() {&#13;
	var el = document.createElement("i");&#13;
	el.className = "separator";&#13;
	el.innerHTML = "|";&#13;
	return el;&#13;
}&#13;
&#13;
function createTootlip(title, action, shortcuts) {&#13;
	var actionName;&#13;
	var tooltip = title;&#13;
&#13;
	if(action) {&#13;
		actionName = getBindingName(action);&#13;
		if(shortcuts[actionName]) {&#13;
			tooltip += " (" + fixShortcut(shortcuts[actionName]) + ")";&#13;
		}&#13;
	}&#13;
&#13;
	return tooltip;&#13;
}&#13;
&#13;
/**&#13;
 * The state of CodeMirror at the given position.&#13;
 */&#13;
function getState(cm, pos) {&#13;
	pos = pos || cm.getCursor("start");&#13;
	var stat = cm.getTokenAt(pos);&#13;
	if(!stat.type) return {};&#13;
&#13;
	var types = stat.type.split(" ");&#13;
&#13;
	var ret = {},&#13;
		data, text;&#13;
	for(var i = 0; i &lt; types.length; i++) {&#13;
		data = types[i];&#13;
		if(data === "strong") {&#13;
			ret.bold = true;&#13;
		} else if(data === "variable-2") {&#13;
			text = cm.getLine(pos.line);&#13;
			if(/^\s*\d+\.\s/.test(text)) {&#13;
				ret["ordered-list"] = true;&#13;
			} else {&#13;
				ret["unordered-list"] = true;&#13;
			}&#13;
		} else if(data === "atom") {&#13;
			ret.quote = true;&#13;
		} else if(data === "em") {&#13;
			ret.italic = true;&#13;
		} else if(data === "quote") {&#13;
			ret.quote = true;&#13;
		} else if(data === "strikethrough") {&#13;
			ret.strikethrough = true;&#13;
		} else if(data === "comment") {&#13;
			ret.code = true;&#13;
		} else if(data === "link") {&#13;
			ret.link = true;&#13;
		} else if(data === "tag") {&#13;
			ret.image = true;&#13;
		} else if(data.match(/^header(\-[1-6])?$/)) {&#13;
			ret[data.replace("header", "heading")] = true;&#13;
		}&#13;
	}&#13;
	return ret;&#13;
}&#13;
&#13;
&#13;
// Saved overflow setting&#13;
var saved_overflow = "";&#13;
&#13;
/**&#13;
 * Toggle full screen of the editor.&#13;
 */&#13;
function toggleFullScreen(editor) {&#13;
	// Set fullscreen&#13;
	var cm = editor.codemirror;&#13;
	cm.setOption("fullScreen", !cm.getOption("fullScreen"));&#13;
&#13;
&#13;
	// Prevent scrolling on body during fullscreen active&#13;
	if(cm.getOption("fullScreen")) {&#13;
		saved_overflow = document.body.style.overflow;&#13;
		document.body.style.overflow = "hidden";&#13;
	} else {&#13;
		document.body.style.overflow = saved_overflow;&#13;
	}&#13;
&#13;
&#13;
	// Update toolbar class&#13;
	var wrap = cm.getWrapperElement();&#13;
&#13;
	if(!/fullscreen/.test(wrap.previousSibling.className)) {&#13;
		wrap.previousSibling.className += " fullscreen";&#13;
	} else {&#13;
		wrap.previousSibling.className = wrap.previousSibling.className.replace(/\s*fullscreen\b/, "");&#13;
	}&#13;
&#13;
&#13;
	// Update toolbar button&#13;
	var toolbarButton = editor.toolbarElements.fullscreen;&#13;
&#13;
	if(!/active/.test(toolbarButton.className)) {&#13;
		toolbarButton.className += " active";&#13;
	} else {&#13;
		toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");&#13;
	}&#13;
&#13;
&#13;
	// Hide side by side if needed&#13;
	var sidebyside = cm.getWrapperElement().nextSibling;&#13;
	if(/editor-preview-active-side/.test(sidebyside.className))&#13;
		toggleSideBySide(editor);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Action for toggling bold.&#13;
 */&#13;
function toggleBold(editor) {&#13;
	_toggleBlock(editor, "bold", editor.options.blockStyles.bold);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Action for toggling italic.&#13;
 */&#13;
function toggleItalic(editor) {&#13;
	_toggleBlock(editor, "italic", editor.options.blockStyles.italic);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Action for toggling strikethrough.&#13;
 */&#13;
function toggleStrikethrough(editor) {&#13;
	_toggleBlock(editor, "strikethrough", "~~");&#13;
}&#13;
&#13;
/**&#13;
 * Action for toggling code block.&#13;
 */&#13;
function toggleCodeBlock(editor) {&#13;
	var fenceCharsToInsert = editor.options.blockStyles.code;&#13;
&#13;
	function fencing_line(line) {&#13;
		/* return true, if this is a ``` or ~~~ line */&#13;
		if(typeof line !== "object") {&#13;
			throw "fencing_line() takes a 'line' object (not a line number, or line text).  Got: " + typeof line + ": " + line;&#13;
		}&#13;
		return line.styles &amp;&amp; line.styles[2] &amp;&amp; line.styles[2].indexOf("formatting-code-block") !== -1;&#13;
	}&#13;
&#13;
	function token_state(token) {&#13;
		// base goes an extra level deep when mode backdrops are used, e.g. spellchecker on&#13;
		return token.state.base.base || token.state.base;&#13;
	}&#13;
&#13;
	function code_type(cm, line_num, line, firstTok, lastTok) {&#13;
		/*&#13;
		 * Return "single", "indented", "fenced" or false&#13;
		 *&#13;
		 * cm and line_num are required.  Others are optional for efficiency&#13;
		 *   To check in the middle of a line, pass in firstTok yourself.&#13;
		 */&#13;
		line = line || cm.getLineHandle(line_num);&#13;
		firstTok = firstTok || cm.getTokenAt({&#13;
			line: line_num,&#13;
			ch: 1&#13;
		});&#13;
		lastTok = lastTok || (!!line.text &amp;&amp; cm.getTokenAt({&#13;
			line: line_num,&#13;
			ch: line.text.length - 1&#13;
		}));&#13;
		var types = firstTok.type ? firstTok.type.split(" ") : [];&#13;
		if(lastTok &amp;&amp; token_state(lastTok).indentedCode) {&#13;
			// have to check last char, since first chars of first line aren"t marked as indented&#13;
			return "indented";&#13;
		} else if(types.indexOf("comment") === -1) {&#13;
			// has to be after "indented" check, since first chars of first indented line aren"t marked as such&#13;
			return false;&#13;
		} else if(token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line)) {&#13;
			return "fenced";&#13;
		} else {&#13;
			return "single";&#13;
		}&#13;
	}&#13;
&#13;
	function insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert) {&#13;
		var start_line_sel = cur_start.line + 1,&#13;
			end_line_sel = cur_end.line + 1,&#13;
			sel_multi = cur_start.line !== cur_end.line,&#13;
			repl_start = fenceCharsToInsert + "\n",&#13;
			repl_end = "\n" + fenceCharsToInsert;&#13;
		if(sel_multi) {&#13;
			end_line_sel++;&#13;
		}&#13;
		// handle last char including \n or not&#13;
		if(sel_multi &amp;&amp; cur_end.ch === 0) {&#13;
			repl_end = fenceCharsToInsert + "\n";&#13;
			end_line_sel--;&#13;
		}&#13;
		_replaceSelection(cm, false, [repl_start, repl_end]);&#13;
		cm.setSelection({&#13;
			line: start_line_sel,&#13;
			ch: 0&#13;
		}, {&#13;
			line: end_line_sel,&#13;
			ch: 0&#13;
		});&#13;
	}&#13;
&#13;
	var cm = editor.codemirror,&#13;
		cur_start = cm.getCursor("start"),&#13;
		cur_end = cm.getCursor("end"),&#13;
		tok = cm.getTokenAt({&#13;
			line: cur_start.line,&#13;
			ch: cur_start.ch || 1&#13;
		}), // avoid ch 0 which is a cursor pos but not token&#13;
		line = cm.getLineHandle(cur_start.line),&#13;
		is_code = code_type(cm, cur_start.line, line, tok);&#13;
	var block_start, block_end, lineCount;&#13;
&#13;
	if(is_code === "single") {&#13;
		// similar to some SimpleMDE _toggleBlock logic&#13;
		var start = line.text.slice(0, cur_start.ch).replace("`", ""),&#13;
			end = line.text.slice(cur_start.ch).replace("`", "");&#13;
		cm.replaceRange(start + end, {&#13;
			line: cur_start.line,&#13;
			ch: 0&#13;
		}, {&#13;
			line: cur_start.line,&#13;
			ch: 99999999999999&#13;
		});&#13;
		cur_start.ch--;&#13;
		if(cur_start !== cur_end) {&#13;
			cur_end.ch--;&#13;
		}&#13;
		cm.setSelection(cur_start, cur_end);&#13;
		cm.focus();&#13;
	} else if(is_code === "fenced") {&#13;
		if(cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {&#13;
			// use selection&#13;
&#13;
			// find the fenced line so we know what type it is (tilde, backticks, number of them)&#13;
			for(block_start = cur_start.line; block_start &gt;= 0; block_start--) {&#13;
				line = cm.getLineHandle(block_start);&#13;
				if(fencing_line(line)) {&#13;
					break;&#13;
				}&#13;
			}&#13;
			var fencedTok = cm.getTokenAt({&#13;
				line: block_start,&#13;
				ch: 1&#13;
			});&#13;
			var fence_chars = token_state(fencedTok).fencedChars;&#13;
			var start_text, start_line;&#13;
			var end_text, end_line;&#13;
			// check for selection going up against fenced lines, in which case we don't want to add more fencing&#13;
			if(fencing_line(cm.getLineHandle(cur_start.line))) {&#13;
				start_text = "";&#13;
				start_line = cur_start.line;&#13;
			} else if(fencing_line(cm.getLineHandle(cur_start.line - 1))) {&#13;
				start_text = "";&#13;
				start_line = cur_start.line - 1;&#13;
			} else {&#13;
				start_text = fence_chars + "\n";&#13;
				start_line = cur_start.line;&#13;
			}&#13;
			if(fencing_line(cm.getLineHandle(cur_end.line))) {&#13;
				end_text = "";&#13;
				end_line = cur_end.line;&#13;
				if(cur_end.ch === 0) {&#13;
					end_line += 1;&#13;
				}&#13;
			} else if(cur_end.ch !== 0 &amp;&amp; fencing_line(cm.getLineHandle(cur_end.line + 1))) {&#13;
				end_text = "";&#13;
				end_line = cur_end.line + 1;&#13;
			} else {&#13;
				end_text = fence_chars + "\n";&#13;
				end_line = cur_end.line + 1;&#13;
			}&#13;
			if(cur_end.ch === 0) {&#13;
				// full last line selected, putting cursor at beginning of next&#13;
				end_line -= 1;&#13;
			}&#13;
			cm.operation(function() {&#13;
				// end line first, so that line numbers don't change&#13;
				cm.replaceRange(end_text, {&#13;
					line: end_line,&#13;
					ch: 0&#13;
				}, {&#13;
					line: end_line + (end_text ? 0 : 1),&#13;
					ch: 0&#13;
				});&#13;
				cm.replaceRange(start_text, {&#13;
					line: start_line,&#13;
					ch: 0&#13;
				}, {&#13;
					line: start_line + (start_text ? 0 : 1),&#13;
					ch: 0&#13;
				});&#13;
			});&#13;
			cm.setSelection({&#13;
				line: start_line + (start_text ? 1 : 0),&#13;
				ch: 0&#13;
			}, {&#13;
				line: end_line + (start_text ? 1 : -1),&#13;
				ch: 0&#13;
			});&#13;
			cm.focus();&#13;
		} else {&#13;
			// no selection, search for ends of this fenced block&#13;
			var search_from = cur_start.line;&#13;
			if(fencing_line(cm.getLineHandle(cur_start.line))) { // gets a little tricky if cursor is right on a fenced line&#13;
				if(code_type(cm, cur_start.line + 1) === "fenced") {&#13;
					block_start = cur_start.line;&#13;
					search_from = cur_start.line + 1; // for searching for "end"&#13;
				} else {&#13;
					block_end = cur_start.line;&#13;
					search_from = cur_start.line - 1; // for searching for "start"&#13;
				}&#13;
			}&#13;
			if(block_start === undefined) {&#13;
				for(block_start = search_from; block_start &gt;= 0; block_start--) {&#13;
					line = cm.getLineHandle(block_start);&#13;
					if(fencing_line(line)) {&#13;
						break;&#13;
					}&#13;
				}&#13;
			}&#13;
			if(block_end === undefined) {&#13;
				lineCount = cm.lineCount();&#13;
				for(block_end = search_from; block_end &lt; lineCount; block_end++) {&#13;
					line = cm.getLineHandle(block_end);&#13;
					if(fencing_line(line)) {&#13;
						break;&#13;
					}&#13;
				}&#13;
			}&#13;
			cm.operation(function() {&#13;
				cm.replaceRange("", {&#13;
					line: block_start,&#13;
					ch: 0&#13;
				}, {&#13;
					line: block_start + 1,&#13;
					ch: 0&#13;
				});&#13;
				cm.replaceRange("", {&#13;
					line: block_end - 1,&#13;
					ch: 0&#13;
				}, {&#13;
					line: block_end,&#13;
					ch: 0&#13;
				});&#13;
			});&#13;
			cm.focus();&#13;
		}&#13;
	} else if(is_code === "indented") {&#13;
		if(cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {&#13;
			// use selection&#13;
			block_start = cur_start.line;&#13;
			block_end = cur_end.line;&#13;
			if(cur_end.ch === 0) {&#13;
				block_end--;&#13;
			}&#13;
		} else {&#13;
			// no selection, search for ends of this indented block&#13;
			for(block_start = cur_start.line; block_start &gt;= 0; block_start--) {&#13;
				line = cm.getLineHandle(block_start);&#13;
				if(line.text.match(/^\s*$/)) {&#13;
					// empty or all whitespace - keep going&#13;
					continue;&#13;
				} else {&#13;
					if(code_type(cm, block_start, line) !== "indented") {&#13;
						block_start += 1;&#13;
						break;&#13;
					}&#13;
				}&#13;
			}&#13;
			lineCount = cm.lineCount();&#13;
			for(block_end = cur_start.line; block_end &lt; lineCount; block_end++) {&#13;
				line = cm.getLineHandle(block_end);&#13;
				if(line.text.match(/^\s*$/)) {&#13;
					// empty or all whitespace - keep going&#13;
					continue;&#13;
				} else {&#13;
					if(code_type(cm, block_end, line) !== "indented") {&#13;
						block_end -= 1;&#13;
						break;&#13;
					}&#13;
				}&#13;
			}&#13;
		}&#13;
		// if we are going to un-indent based on a selected set of lines, and the next line is indented too, we need to&#13;
		// insert a blank line so that the next line(s) continue to be indented code&#13;
		var next_line = cm.getLineHandle(block_end + 1),&#13;
			next_line_last_tok = next_line &amp;&amp; cm.getTokenAt({&#13;
				line: block_end + 1,&#13;
				ch: next_line.text.length - 1&#13;
			}),&#13;
			next_line_indented = next_line_last_tok &amp;&amp; token_state(next_line_last_tok).indentedCode;&#13;
		if(next_line_indented) {&#13;
			cm.replaceRange("\n", {&#13;
				line: block_end + 1,&#13;
				ch: 0&#13;
			});&#13;
		}&#13;
&#13;
		for(var i = block_start; i &lt;= block_end; i++) {&#13;
			cm.indentLine(i, "subtract"); // TODO: this doesn't get tracked in the history, so can't be undone :(&#13;
		}&#13;
		cm.focus();&#13;
	} else {&#13;
		// insert code formatting&#13;
		var no_sel_and_starting_of_line = (cur_start.line === cur_end.line &amp;&amp; cur_start.ch === cur_end.ch &amp;&amp; cur_start.ch === 0);&#13;
		var sel_multi = cur_start.line !== cur_end.line;&#13;
		if(no_sel_and_starting_of_line || sel_multi) {&#13;
			insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);&#13;
		} else {&#13;
			_replaceSelection(cm, false, ["`", "`"]);&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
/**&#13;
 * Action for toggling blockquote.&#13;
 */&#13;
function toggleBlockquote(editor) {&#13;
	var cm = editor.codemirror;&#13;
	_toggleLine(cm, "quote");&#13;
}&#13;
&#13;
/**&#13;
 * Action for toggling heading size: normal -&gt; h1 -&gt; h2 -&gt; h3 -&gt; h4 -&gt; h5 -&gt; h6 -&gt; normal&#13;
 */&#13;
function toggleHeadingSmaller(editor) {&#13;
	var cm = editor.codemirror;&#13;
	_toggleHeading(cm, "smaller");&#13;
}&#13;
&#13;
/**&#13;
 * Action for toggling heading size: normal -&gt; h6 -&gt; h5 -&gt; h4 -&gt; h3 -&gt; h2 -&gt; h1 -&gt; normal&#13;
 */&#13;
function toggleHeadingBigger(editor) {&#13;
	var cm = editor.codemirror;&#13;
	_toggleHeading(cm, "bigger");&#13;
}&#13;
&#13;
/**&#13;
 * Action for toggling heading size 1&#13;
 */&#13;
function toggleHeading1(editor) {&#13;
	var cm = editor.codemirror;&#13;
	_toggleHeading(cm, undefined, 1);&#13;
}&#13;
&#13;
/**&#13;
 * Action for toggling heading size 2&#13;
 */&#13;
function toggleHeading2(editor) {&#13;
	var cm = editor.codemirror;&#13;
	_toggleHeading(cm, undefined, 2);&#13;
}&#13;
&#13;
/**&#13;
 * Action for toggling heading size 3&#13;
 */&#13;
function toggleHeading3(editor) {&#13;
	var cm = editor.codemirror;&#13;
	_toggleHeading(cm, undefined, 3);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Action for toggling ul.&#13;
 */&#13;
function toggleUnorderedList(editor) {&#13;
	var cm = editor.codemirror;&#13;
	_toggleLine(cm, "unordered-list");&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Action for toggling ol.&#13;
 */&#13;
function toggleOrderedList(editor) {&#13;
	var cm = editor.codemirror;&#13;
	_toggleLine(cm, "ordered-list");&#13;
}&#13;
&#13;
/**&#13;
 * Action for clean block (remove headline, list, blockquote code, markers)&#13;
 */&#13;
function cleanBlock(editor) {&#13;
	var cm = editor.codemirror;&#13;
	_cleanBlock(cm);&#13;
}&#13;
&#13;
/**&#13;
 * Action for drawing a link.&#13;
 */&#13;
function drawLink(editor) {&#13;
	var cm = editor.codemirror;&#13;
	var stat = getState(cm);&#13;
	var options = editor.options;&#13;
	var url = "http://";&#13;
	if(options.promptURLs) {&#13;
		url = prompt(options.promptTexts.link);&#13;
		if(!url) {&#13;
			return false;&#13;
		}&#13;
	}&#13;
	_replaceSelection(cm, stat.link, options.insertTexts.link, url);&#13;
}&#13;
&#13;
/**&#13;
 * Action for drawing an img.&#13;
 */&#13;
function drawImage(editor) {&#13;
	var cm = editor.codemirror;&#13;
	var stat = getState(cm);&#13;
	var options = editor.options;&#13;
	var url = "http://";&#13;
	if(options.promptURLs) {&#13;
		url = prompt(options.promptTexts.image);&#13;
		if(!url) {&#13;
			return false;&#13;
		}&#13;
	}&#13;
	_replaceSelection(cm, stat.image, options.insertTexts.image, url);&#13;
}&#13;
&#13;
/**&#13;
 * Action for drawing a table.&#13;
 */&#13;
function drawTable(editor) {&#13;
	var cm = editor.codemirror;&#13;
	var stat = getState(cm);&#13;
	var options = editor.options;&#13;
	_replaceSelection(cm, stat.table, options.insertTexts.table);&#13;
}&#13;
&#13;
/**&#13;
 * Action for drawing a horizontal rule.&#13;
 */&#13;
function drawHorizontalRule(editor) {&#13;
	var cm = editor.codemirror;&#13;
	var stat = getState(cm);&#13;
	var options = editor.options;&#13;
	_replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Undo action.&#13;
 */&#13;
function undo(editor) {&#13;
	var cm = editor.codemirror;&#13;
	cm.undo();&#13;
	cm.focus();&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Redo action.&#13;
 */&#13;
function redo(editor) {&#13;
	var cm = editor.codemirror;&#13;
	cm.redo();&#13;
	cm.focus();&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Toggle side by side preview&#13;
 */&#13;
function toggleSideBySide(editor) {&#13;
	var cm = editor.codemirror;&#13;
	var wrapper = cm.getWrapperElement();&#13;
	var preview = wrapper.nextSibling;&#13;
	var toolbarButton = editor.toolbarElements["side-by-side"];&#13;
	var useSideBySideListener = false;&#13;
	if(/editor-preview-active-side/.test(preview.className)) {&#13;
		preview.className = preview.className.replace(&#13;
			/\s*editor-preview-active-side\s*/g, ""&#13;
		);&#13;
		toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");&#13;
		wrapper.className = wrapper.className.replace(/\s*CodeMirror-sided\s*/g, " ");&#13;
	} else {&#13;
		// When the preview button is clicked for the first time,&#13;
		// give some time for the transition from editor.css to fire and the view to slide from right to left,&#13;
		// instead of just appearing.&#13;
		setTimeout(function() {&#13;
			if(!cm.getOption("fullScreen"))&#13;
				toggleFullScreen(editor);&#13;
			preview.className += " editor-preview-active-side";&#13;
		}, 1);&#13;
		toolbarButton.className += " active";&#13;
		wrapper.className += " CodeMirror-sided";&#13;
		useSideBySideListener = true;&#13;
	}&#13;
&#13;
	// Hide normal preview if active&#13;
	var previewNormal = wrapper.lastChild;&#13;
	if(/editor-preview-active/.test(previewNormal.className)) {&#13;
		previewNormal.className = previewNormal.className.replace(&#13;
			/\s*editor-preview-active\s*/g, ""&#13;
		);&#13;
		var toolbar = editor.toolbarElements.preview;&#13;
		var toolbar_div = wrapper.previousSibling;&#13;
		toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");&#13;
		toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");&#13;
	}&#13;
&#13;
	var sideBySideRenderingFunction = function() {&#13;
		preview.innerHTML = editor.options.previewRender(editor.value(), preview);&#13;
	};&#13;
&#13;
	if(!cm.sideBySideRenderingFunction) {&#13;
		cm.sideBySideRenderingFunction = sideBySideRenderingFunction;&#13;
	}&#13;
&#13;
	if(useSideBySideListener) {&#13;
		preview.innerHTML = editor.options.previewRender(editor.value(), preview);&#13;
		cm.on("update", cm.sideBySideRenderingFunction);&#13;
	} else {&#13;
		cm.off("update", cm.sideBySideRenderingFunction);&#13;
	}&#13;
&#13;
	// Refresh to fix selection being off (#309)&#13;
	cm.refresh();&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Preview action.&#13;
 */&#13;
function togglePreview(editor) {&#13;
	var cm = editor.codemirror;&#13;
	var wrapper = cm.getWrapperElement();&#13;
	var toolbar_div = wrapper.previousSibling;&#13;
	var toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;&#13;
	var preview = wrapper.lastChild;&#13;
	if(!preview || !/editor-preview/.test(preview.className)) {&#13;
		preview = document.createElement("div");&#13;
		preview.className = "editor-preview";&#13;
		wrapper.appendChild(preview);&#13;
	}&#13;
	if(/editor-preview-active/.test(preview.className)) {&#13;
		preview.className = preview.className.replace(&#13;
			/\s*editor-preview-active\s*/g, ""&#13;
		);&#13;
		if(toolbar) {&#13;
			toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");&#13;
			toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");&#13;
		}&#13;
	} else {&#13;
		// When the preview button is clicked for the first time,&#13;
		// give some time for the transition from editor.css to fire and the view to slide from right to left,&#13;
		// instead of just appearing.&#13;
		setTimeout(function() {&#13;
			preview.className += " editor-preview-active";&#13;
		}, 1);&#13;
		if(toolbar) {&#13;
			toolbar.className += " active";&#13;
			toolbar_div.className += " disabled-for-preview";&#13;
		}&#13;
	}&#13;
	preview.innerHTML = editor.options.previewRender(editor.value(), preview);&#13;
&#13;
	// Turn off side by side if needed&#13;
	var sidebyside = cm.getWrapperElement().nextSibling;&#13;
	if(/editor-preview-active-side/.test(sidebyside.className))&#13;
		toggleSideBySide(editor);&#13;
}&#13;
&#13;
function _replaceSelection(cm, active, startEnd, url) {&#13;
	if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))&#13;
		return;&#13;
&#13;
	var text;&#13;
	var start = startEnd[0];&#13;
	var end = startEnd[1];&#13;
	var startPoint = cm.getCursor("start");&#13;
	var endPoint = cm.getCursor("end");&#13;
	if(url) {&#13;
		end = end.replace("#url#", url);&#13;
	}&#13;
	if(active) {&#13;
		text = cm.getLine(startPoint.line);&#13;
		start = text.slice(0, startPoint.ch);&#13;
		end = text.slice(startPoint.ch);&#13;
		cm.replaceRange(start + end, {&#13;
			line: startPoint.line,&#13;
			ch: 0&#13;
		});&#13;
	} else {&#13;
		text = cm.getSelection();&#13;
		cm.replaceSelection(start + text + end);&#13;
&#13;
		startPoint.ch += start.length;&#13;
		if(startPoint !== endPoint) {&#13;
			endPoint.ch += start.length;&#13;
		}&#13;
	}&#13;
	cm.setSelection(startPoint, endPoint);&#13;
	cm.focus();&#13;
}&#13;
&#13;
&#13;
function _toggleHeading(cm, direction, size) {&#13;
	if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))&#13;
		return;&#13;
&#13;
	var startPoint = cm.getCursor("start");&#13;
	var endPoint = cm.getCursor("end");&#13;
	for(var i = startPoint.line; i &lt;= endPoint.line; i++) {&#13;
		(function(i) {&#13;
			var text = cm.getLine(i);&#13;
			var currHeadingLevel = text.search(/[^#]/);&#13;
&#13;
			if(direction !== undefined) {&#13;
				if(currHeadingLevel &lt;= 0) {&#13;
					if(direction == "bigger") {&#13;
						text = "###### " + text;&#13;
					} else {&#13;
						text = "# " + text;&#13;
					}&#13;
				} else if(currHeadingLevel == 6 &amp;&amp; direction == "smaller") {&#13;
					text = text.substr(7);&#13;
				} else if(currHeadingLevel == 1 &amp;&amp; direction == "bigger") {&#13;
					text = text.substr(2);&#13;
				} else {&#13;
					if(direction == "bigger") {&#13;
						text = text.substr(1);&#13;
					} else {&#13;
						text = "#" + text;&#13;
					}&#13;
				}&#13;
			} else {&#13;
				if(size == 1) {&#13;
					if(currHeadingLevel &lt;= 0) {&#13;
						text = "# " + text;&#13;
					} else if(currHeadingLevel == size) {&#13;
						text = text.substr(currHeadingLevel + 1);&#13;
					} else {&#13;
						text = "# " + text.substr(currHeadingLevel + 1);&#13;
					}&#13;
				} else if(size == 2) {&#13;
					if(currHeadingLevel &lt;= 0) {&#13;
						text = "## " + text;&#13;
					} else if(currHeadingLevel == size) {&#13;
						text = text.substr(currHeadingLevel + 1);&#13;
					} else {&#13;
						text = "## " + text.substr(currHeadingLevel + 1);&#13;
					}&#13;
				} else {&#13;
					if(currHeadingLevel &lt;= 0) {&#13;
						text = "### " + text;&#13;
					} else if(currHeadingLevel == size) {&#13;
						text = text.substr(currHeadingLevel + 1);&#13;
					} else {&#13;
						text = "### " + text.substr(currHeadingLevel + 1);&#13;
					}&#13;
				}&#13;
			}&#13;
&#13;
			cm.replaceRange(text, {&#13;
				line: i,&#13;
				ch: 0&#13;
			}, {&#13;
				line: i,&#13;
				ch: 99999999999999&#13;
			});&#13;
		})(i);&#13;
	}&#13;
	cm.focus();&#13;
}&#13;
&#13;
&#13;
function _toggleLine(cm, name) {&#13;
	if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))&#13;
		return;&#13;
&#13;
	var stat = getState(cm);&#13;
	var startPoint = cm.getCursor("start");&#13;
	var endPoint = cm.getCursor("end");&#13;
	var repl = {&#13;
		"quote": /^(\s*)\&gt;\s+/,&#13;
		"unordered-list": /^(\s*)(\*|\-|\+)\s+/,&#13;
		"ordered-list": /^(\s*)\d+\.\s+/&#13;
	};&#13;
	var map = {&#13;
		"quote": "&gt; ",&#13;
		"unordered-list": "* ",&#13;
		"ordered-list": "1. "&#13;
	};&#13;
	for(var i = startPoint.line; i &lt;= endPoint.line; i++) {&#13;
		(function(i) {&#13;
			var text = cm.getLine(i);&#13;
			if(stat[name]) {&#13;
				text = text.replace(repl[name], "$1");&#13;
			} else {&#13;
				text = map[name] + text;&#13;
			}&#13;
			cm.replaceRange(text, {&#13;
				line: i,&#13;
				ch: 0&#13;
			}, {&#13;
				line: i,&#13;
				ch: 99999999999999&#13;
			});&#13;
		})(i);&#13;
	}&#13;
	cm.focus();&#13;
}&#13;
&#13;
function _toggleBlock(editor, type, start_chars, end_chars) {&#13;
	if(/editor-preview-active/.test(editor.codemirror.getWrapperElement().lastChild.className))&#13;
		return;&#13;
&#13;
	end_chars = (typeof end_chars === "undefined") ? start_chars : end_chars;&#13;
	var cm = editor.codemirror;&#13;
	var stat = getState(cm);&#13;
&#13;
	var text;&#13;
	var start = start_chars;&#13;
	var end = end_chars;&#13;
&#13;
	var startPoint = cm.getCursor("start");&#13;
	var endPoint = cm.getCursor("end");&#13;
&#13;
	if(stat[type]) {&#13;
		text = cm.getLine(startPoint.line);&#13;
		start = text.slice(0, startPoint.ch);&#13;
		end = text.slice(startPoint.ch);&#13;
		if(type == "bold") {&#13;
			start = start.replace(/(\*\*|__)(?![\s\S]*(\*\*|__))/, "");&#13;
			end = end.replace(/(\*\*|__)/, "");&#13;
		} else if(type == "italic") {&#13;
			start = start.replace(/(\*|_)(?![\s\S]*(\*|_))/, "");&#13;
			end = end.replace(/(\*|_)/, "");&#13;
		} else if(type == "strikethrough") {&#13;
			start = start.replace(/(\*\*|~~)(?![\s\S]*(\*\*|~~))/, "");&#13;
			end = end.replace(/(\*\*|~~)/, "");&#13;
		}&#13;
		cm.replaceRange(start + end, {&#13;
			line: startPoint.line,&#13;
			ch: 0&#13;
		}, {&#13;
			line: startPoint.line,&#13;
			ch: 99999999999999&#13;
		});&#13;
&#13;
		if(type == "bold" || type == "strikethrough") {&#13;
			startPoint.ch -= 2;&#13;
			if(startPoint !== endPoint) {&#13;
				endPoint.ch -= 2;&#13;
			}&#13;
		} else if(type == "italic") {&#13;
			startPoint.ch -= 1;&#13;
			if(startPoint !== endPoint) {&#13;
				endPoint.ch -= 1;&#13;
			}&#13;
		}&#13;
	} else {&#13;
		text = cm.getSelection();&#13;
		if(type == "bold") {&#13;
			text = text.split("**").join("");&#13;
			text = text.split("__").join("");&#13;
		} else if(type == "italic") {&#13;
			text = text.split("*").join("");&#13;
			text = text.split("_").join("");&#13;
		} else if(type == "strikethrough") {&#13;
			text = text.split("~~").join("");&#13;
		}&#13;
		cm.replaceSelection(start + text + end);&#13;
&#13;
		startPoint.ch += start_chars.length;&#13;
		endPoint.ch = startPoint.ch + text.length;&#13;
	}&#13;
&#13;
	cm.setSelection(startPoint, endPoint);&#13;
	cm.focus();&#13;
}&#13;
&#13;
function _cleanBlock(cm) {&#13;
	if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))&#13;
		return;&#13;
&#13;
	var startPoint = cm.getCursor("start");&#13;
	var endPoint = cm.getCursor("end");&#13;
	var text;&#13;
&#13;
	for(var line = startPoint.line; line &lt;= endPoint.line; line++) {&#13;
		text = cm.getLine(line);&#13;
		text = text.replace(/^[ ]*([# ]+|\*|\-|[&gt; ]+|[0-9]+(.|\)))[ ]*/, "");&#13;
&#13;
		cm.replaceRange(text, {&#13;
			line: line,&#13;
			ch: 0&#13;
		}, {&#13;
			line: line,&#13;
			ch: 99999999999999&#13;
		});&#13;
	}&#13;
}&#13;
&#13;
// Merge the properties of one object into another.&#13;
function _mergeProperties(target, source) {&#13;
	for(var property in source) {&#13;
		if(source.hasOwnProperty(property)) {&#13;
			if(source[property] instanceof Array) {&#13;
				target[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);&#13;
			} else if(&#13;
				source[property] !== null &amp;&amp;&#13;
				typeof source[property] === "object" &amp;&amp;&#13;
				source[property].constructor === Object&#13;
			) {&#13;
				target[property] = _mergeProperties(target[property] || {}, source[property]);&#13;
			} else {&#13;
				target[property] = source[property];&#13;
			}&#13;
		}&#13;
	}&#13;
&#13;
	return target;&#13;
}&#13;
&#13;
// Merge an arbitrary number of objects into one.&#13;
function extend(target) {&#13;
	for(var i = 1; i &lt; arguments.length; i++) {&#13;
		target = _mergeProperties(target, arguments[i]);&#13;
	}&#13;
&#13;
	return target;&#13;
}&#13;
&#13;
/* The right word count in respect for CJK. */&#13;
function wordCount(data) {&#13;
	var pattern = /[a-zA-Z0-9_\u0392-\u03c9\u0410-\u04F9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g;&#13;
	var m = data.match(pattern);&#13;
	var count = 0;&#13;
	if(m === null) return count;&#13;
	for(var i = 0; i &lt; m.length; i++) {&#13;
		if(m[i].charCodeAt(0) &gt;= 0x4E00) {&#13;
			count += m[i].length;&#13;
		} else {&#13;
			count += 1;&#13;
		}&#13;
	}&#13;
	return count;&#13;
}&#13;
&#13;
var toolbarBuiltInButtons = {&#13;
	"bold": {&#13;
		name: "bold",&#13;
		action: toggleBold,&#13;
		className: "fa fa-bold",&#13;
		title: "Bold",&#13;
		default: true&#13;
	},&#13;
	"italic": {&#13;
		name: "italic",&#13;
		action: toggleItalic,&#13;
		className: "fa fa-italic",&#13;
		title: "Italic",&#13;
		default: true&#13;
	},&#13;
	"strikethrough": {&#13;
		name: "strikethrough",&#13;
		action: toggleStrikethrough,&#13;
		className: "fa fa-strikethrough",&#13;
		title: "Strikethrough"&#13;
	},&#13;
	"heading": {&#13;
		name: "heading",&#13;
		action: toggleHeadingSmaller,&#13;
		className: "fa fa-header",&#13;
		title: "Heading",&#13;
		default: true&#13;
	},&#13;
	"heading-smaller": {&#13;
		name: "heading-smaller",&#13;
		action: toggleHeadingSmaller,&#13;
		className: "fa fa-header fa-header-x fa-header-smaller",&#13;
		title: "Smaller Heading"&#13;
	},&#13;
	"heading-bigger": {&#13;
		name: "heading-bigger",&#13;
		action: toggleHeadingBigger,&#13;
		className: "fa fa-header fa-header-x fa-header-bigger",&#13;
		title: "Bigger Heading"&#13;
	},&#13;
	"heading-1": {&#13;
		name: "heading-1",&#13;
		action: toggleHeading1,&#13;
		className: "fa fa-header fa-header-x fa-header-1",&#13;
		title: "Big Heading"&#13;
	},&#13;
	"heading-2": {&#13;
		name: "heading-2",&#13;
		action: toggleHeading2,&#13;
		className: "fa fa-header fa-header-x fa-header-2",&#13;
		title: "Medium Heading"&#13;
	},&#13;
	"heading-3": {&#13;
		name: "heading-3",&#13;
		action: toggleHeading3,&#13;
		className: "fa fa-header fa-header-x fa-header-3",&#13;
		title: "Small Heading"&#13;
	},&#13;
	"separator-1": {&#13;
		name: "separator-1"&#13;
	},&#13;
	"code": {&#13;
		name: "code",&#13;
		action: toggleCodeBlock,&#13;
		className: "fa fa-code",&#13;
		title: "Code"&#13;
	},&#13;
	"quote": {&#13;
		name: "quote",&#13;
		action: toggleBlockquote,&#13;
		className: "fa fa-quote-left",&#13;
		title: "Quote",&#13;
		default: true&#13;
	},&#13;
	"unordered-list": {&#13;
		name: "unordered-list",&#13;
		action: toggleUnorderedList,&#13;
		className: "fa fa-list-ul",&#13;
		title: "Generic List",&#13;
		default: true&#13;
	},&#13;
	"ordered-list": {&#13;
		name: "ordered-list",&#13;
		action: toggleOrderedList,&#13;
		className: "fa fa-list-ol",&#13;
		title: "Numbered List",&#13;
		default: true&#13;
	},&#13;
	"clean-block": {&#13;
		name: "clean-block",&#13;
		action: cleanBlock,&#13;
		className: "fa fa-eraser fa-clean-block",&#13;
		title: "Clean block"&#13;
	},&#13;
	"separator-2": {&#13;
		name: "separator-2"&#13;
	},&#13;
	"link": {&#13;
		name: "link",&#13;
		action: drawLink,&#13;
		className: "fa fa-link",&#13;
		title: "Create Link",&#13;
		default: true&#13;
	},&#13;
	"image": {&#13;
		name: "image",&#13;
		action: drawImage,&#13;
		className: "fa fa-picture-o",&#13;
		title: "Insert Image",&#13;
		default: true&#13;
	},&#13;
	"table": {&#13;
		name: "table",&#13;
		action: drawTable,&#13;
		className: "fa fa-table",&#13;
		title: "Insert Table"&#13;
	},&#13;
	"horizontal-rule": {&#13;
		name: "horizontal-rule",&#13;
		action: drawHorizontalRule,&#13;
		className: "fa fa-minus",&#13;
		title: "Insert Horizontal Line"&#13;
	},&#13;
	"separator-3": {&#13;
		name: "separator-3"&#13;
	},&#13;
	"preview": {&#13;
		name: "preview",&#13;
		action: togglePreview,&#13;
		className: "fa fa-eye no-disable",&#13;
		title: "Toggle Preview",&#13;
		default: true&#13;
	},&#13;
	"side-by-side": {&#13;
		name: "side-by-side",&#13;
		action: toggleSideBySide,&#13;
		className: "fa fa-columns no-disable no-mobile",&#13;
		title: "Toggle Side by Side",&#13;
		default: true&#13;
	},&#13;
	"fullscreen": {&#13;
		name: "fullscreen",&#13;
		action: toggleFullScreen,&#13;
		className: "fa fa-arrows-alt no-disable no-mobile",&#13;
		title: "Toggle Fullscreen",&#13;
		default: true&#13;
	},&#13;
	"separator-4": {&#13;
		name: "separator-4"&#13;
	},&#13;
	"guide": {&#13;
		name: "guide",&#13;
		action: "https://simplemde.com/markdown-guide",&#13;
		className: "fa fa-question-circle",&#13;
		title: "Markdown Guide",&#13;
		default: true&#13;
	},&#13;
	"separator-5": {&#13;
		name: "separator-5"&#13;
	},&#13;
	"undo": {&#13;
		name: "undo",&#13;
		action: undo,&#13;
		className: "fa fa-undo no-disable",&#13;
		title: "Undo"&#13;
	},&#13;
	"redo": {&#13;
		name: "redo",&#13;
		action: redo,&#13;
		className: "fa fa-repeat no-disable",&#13;
		title: "Redo"&#13;
	}&#13;
};&#13;
&#13;
var insertTexts = {&#13;
	link: ["[", "](#url#)"],&#13;
	image: ["![](", "#url#)"],&#13;
	table: ["", "\n\n| Column 1 | Column 2 | Column 3 |\n| -------- | -------- | -------- |\n| Text     | Text     | Text     |\n\n"],&#13;
	horizontalRule: ["", "\n\n-----\n\n"]&#13;
};&#13;
&#13;
var promptTexts = {&#13;
	link: "URL for the link:",&#13;
	image: "URL of the image:"&#13;
};&#13;
&#13;
var blockStyles = {&#13;
	"bold": "**",&#13;
	"code": "```",&#13;
	"italic": "*"&#13;
};&#13;
&#13;
/**&#13;
 * Interface of SimpleMDE.&#13;
 */&#13;
function SimpleMDE(options) {&#13;
	// Handle options parameter&#13;
	options = options || {};&#13;
&#13;
&#13;
	// Used later to refer to it"s parent&#13;
	options.parent = this;&#13;
&#13;
&#13;
	// Check if Font Awesome needs to be auto downloaded&#13;
	var autoDownloadFA = true;&#13;
&#13;
	if(options.autoDownloadFontAwesome === false) {&#13;
		autoDownloadFA = false;&#13;
	}&#13;
&#13;
	if(options.autoDownloadFontAwesome !== true) {&#13;
		var styleSheets = document.styleSheets;&#13;
		for(var i = 0; i &lt; styleSheets.length; i++) {&#13;
			if(!styleSheets[i].href)&#13;
				continue;&#13;
&#13;
			if(styleSheets[i].href.indexOf("//maxcdn.bootstrapcdn.com/font-awesome/") &gt; -1) {&#13;
				autoDownloadFA = false;&#13;
			}&#13;
		}&#13;
	}&#13;
&#13;
	if(autoDownloadFA) {&#13;
		var link = document.createElement("link");&#13;
		link.rel = "stylesheet";&#13;
		link.href = "https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css";&#13;
		document.getElementsByTagName("head")[0].appendChild(link);&#13;
	}&#13;
&#13;
&#13;
	// Find the textarea to use&#13;
	if(options.element) {&#13;
		this.element = options.element;&#13;
	} else if(options.element === null) {&#13;
		// This means that the element option was specified, but no element was found&#13;
		console.log("SimpleMDE: Error. No element was found.");&#13;
		return;&#13;
	}&#13;
&#13;
&#13;
	// Handle toolbar&#13;
	if(options.toolbar === undefined) {&#13;
		// Initialize&#13;
		options.toolbar = [];&#13;
&#13;
&#13;
		// Loop over the built in buttons, to get the preferred order&#13;
		for(var key in toolbarBuiltInButtons) {&#13;
			if(toolbarBuiltInButtons.hasOwnProperty(key)) {&#13;
				if(key.indexOf("separator-") != -1) {&#13;
					options.toolbar.push("|");&#13;
				}&#13;
&#13;
				if(toolbarBuiltInButtons[key].default === true || (options.showIcons &amp;&amp; options.showIcons.constructor === Array &amp;&amp; options.showIcons.indexOf(key) != -1)) {&#13;
					options.toolbar.push(key);&#13;
				}&#13;
			}&#13;
		}&#13;
	}&#13;
&#13;
&#13;
	// Handle status bar&#13;
	if(!options.hasOwnProperty("status")) {&#13;
		options.status = ["autosave", "lines", "words", "cursor"];&#13;
	}&#13;
&#13;
&#13;
	// Add default preview rendering function&#13;
	if(!options.previewRender) {&#13;
		options.previewRender = function(plainText) {&#13;
			// Note: "this" refers to the options object&#13;
			return this.parent.markdown(plainText);&#13;
		};&#13;
	}&#13;
&#13;
&#13;
	// Set default options for parsing config&#13;
	options.parsingConfig = extend({&#13;
		highlightFormatting: true // needed for toggleCodeBlock to detect types of code&#13;
	}, options.parsingConfig || {});&#13;
&#13;
&#13;
	// Merging the insertTexts, with the given options&#13;
	options.insertTexts = extend({}, insertTexts, options.insertTexts || {});&#13;
&#13;
&#13;
	// Merging the promptTexts, with the given options&#13;
	options.promptTexts = promptTexts;&#13;
&#13;
&#13;
	// Merging the blockStyles, with the given options&#13;
	options.blockStyles = extend({}, blockStyles, options.blockStyles || {});&#13;
&#13;
&#13;
	// Merging the shortcuts, with the given options&#13;
	options.shortcuts = extend({}, shortcuts, options.shortcuts || {});&#13;
&#13;
&#13;
	// Change unique_id to uniqueId for backwards compatibility&#13;
	if(options.autosave != undefined &amp;&amp; options.autosave.unique_id != undefined &amp;&amp; options.autosave.unique_id != "")&#13;
		options.autosave.uniqueId = options.autosave.unique_id;&#13;
&#13;
&#13;
	// Update this options&#13;
	this.options = options;&#13;
&#13;
&#13;
	// Auto render&#13;
	this.render();&#13;
&#13;
&#13;
	// The codemirror component is only available after rendering&#13;
	// so, the setter for the initialValue can only run after&#13;
	// the element has been rendered&#13;
	if(options.initialValue &amp;&amp; (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {&#13;
		this.value(options.initialValue);&#13;
	}&#13;
}&#13;
&#13;
/**&#13;
 * Default markdown render.&#13;
 */&#13;
SimpleMDE.prototype.markdown = function(text) {&#13;
	if(marked) {&#13;
		// Initialize&#13;
		var markedOptions = {};&#13;
&#13;
&#13;
		// Update options&#13;
		if(this.options &amp;&amp; this.options.renderingConfig &amp;&amp; this.options.renderingConfig.singleLineBreaks === false) {&#13;
			markedOptions.breaks = false;&#13;
		} else {&#13;
			markedOptions.breaks = true;&#13;
		}&#13;
&#13;
		if(this.options &amp;&amp; this.options.renderingConfig &amp;&amp; this.options.renderingConfig.codeSyntaxHighlighting === true &amp;&amp; window.hljs) {&#13;
			markedOptions.highlight = function(code) {&#13;
				return window.hljs.highlightAuto(code).value;&#13;
			};&#13;
		}&#13;
&#13;
&#13;
		// Set options&#13;
		marked.setOptions(markedOptions);&#13;
&#13;
&#13;
		// Return&#13;
		return marked(text);&#13;
	}&#13;
};&#13;
&#13;
/**&#13;
 * Render editor to the given element.&#13;
 */&#13;
SimpleMDE.prototype.render = function(el) {&#13;
	if(!el) {&#13;
		el = this.element || document.getElementsByTagName("textarea")[0];&#13;
	}&#13;
&#13;
	if(this._rendered &amp;&amp; this._rendered === el) {&#13;
		// Already rendered.&#13;
		return;&#13;
	}&#13;
&#13;
	this.element = el;&#13;
	var options = this.options;&#13;
&#13;
	var self = this;&#13;
	var keyMaps = {};&#13;
&#13;
	for(var key in options.shortcuts) {&#13;
		// null stands for "do not bind this command"&#13;
		if(options.shortcuts[key] !== null &amp;&amp; bindings[key] !== null) {&#13;
			(function(key) {&#13;
				keyMaps[fixShortcut(options.shortcuts[key])] = function() {&#13;
					bindings[key](self);&#13;
				};&#13;
			})(key);&#13;
		}&#13;
	}&#13;
&#13;
	keyMaps["Enter"] = "newlineAndIndentContinueMarkdownList";&#13;
	keyMaps["Tab"] = "tabAndIndentMarkdownList";&#13;
	keyMaps["Shift-Tab"] = "shiftTabAndUnindentMarkdownList";&#13;
	keyMaps["Esc"] = function(cm) {&#13;
		if(cm.getOption("fullScreen")) toggleFullScreen(self);&#13;
	};&#13;
&#13;
	document.addEventListener("keydown", function(e) {&#13;
		e = e || window.event;&#13;
&#13;
		if(e.keyCode == 27) {&#13;
			if(self.codemirror.getOption("fullScreen")) toggleFullScreen(self);&#13;
		}&#13;
	}, false);&#13;
&#13;
	var mode, backdrop;&#13;
	if(options.spellChecker !== false) {&#13;
		mode = "spell-checker";&#13;
		backdrop = options.parsingConfig;&#13;
		backdrop.name = "gfm";&#13;
		backdrop.gitHubSpice = false;&#13;
&#13;
		CodeMirrorSpellChecker({&#13;
			codeMirrorInstance: CodeMirror&#13;
		});&#13;
	} else {&#13;
		mode = options.parsingConfig;&#13;
		mode.name = "gfm";&#13;
		mode.gitHubSpice = false;&#13;
	}&#13;
&#13;
	this.codemirror = CodeMirror.fromTextArea(el, {&#13;
		mode: mode,&#13;
		backdrop: backdrop,&#13;
		theme: "paper",&#13;
		tabSize: (options.tabSize != undefined) ? options.tabSize : 2,&#13;
		indentUnit: (options.tabSize != undefined) ? options.tabSize : 2,&#13;
		indentWithTabs: (options.indentWithTabs === false) ? false : true,&#13;
		lineNumbers: false,&#13;
		autofocus: (options.autofocus === true) ? true : false,&#13;
		extraKeys: keyMaps,&#13;
		lineWrapping: (options.lineWrapping === false) ? false : true,&#13;
		allowDropFileTypes: ["text/plain"],&#13;
		placeholder: options.placeholder || el.getAttribute("placeholder") || "",&#13;
		styleSelectedText: (options.styleSelectedText != undefined) ? options.styleSelectedText : true&#13;
	});&#13;
&#13;
	if(options.forceSync === true) {&#13;
		var cm = this.codemirror;&#13;
		cm.on("change", function() {&#13;
			cm.save();&#13;
		});&#13;
	}&#13;
&#13;
	this.gui = {};&#13;
&#13;
	if(options.toolbar !== false) {&#13;
		this.gui.toolbar = this.createToolbar();&#13;
	}&#13;
	if(options.status !== false) {&#13;
		this.gui.statusbar = this.createStatusbar();&#13;
	}&#13;
	if(options.autosave != undefined &amp;&amp; options.autosave.enabled === true) {&#13;
		this.autosave();&#13;
	}&#13;
&#13;
	this.gui.sideBySide = this.createSideBySide();&#13;
&#13;
	this._rendered = this.element;&#13;
&#13;
&#13;
	// Fixes CodeMirror bug (#344)&#13;
	var temp_cm = this.codemirror;&#13;
	setTimeout(function() {&#13;
		temp_cm.refresh();&#13;
	}.bind(temp_cm), 0);&#13;
};&#13;
&#13;
// Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem throw QuotaExceededError. We're going to detect this and set a variable accordingly.&#13;
function isLocalStorageAvailable() {&#13;
	if(typeof localStorage === "object") {&#13;
		try {&#13;
			localStorage.setItem("smde_localStorage", 1);&#13;
			localStorage.removeItem("smde_localStorage");&#13;
		} catch(e) {&#13;
			return false;&#13;
		}&#13;
	} else {&#13;
		return false;&#13;
	}&#13;
&#13;
	return true;&#13;
}&#13;
&#13;
SimpleMDE.prototype.autosave = function() {&#13;
	if(isLocalStorageAvailable()) {&#13;
		var simplemde = this;&#13;
&#13;
		if(this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == "") {&#13;
			console.log("SimpleMDE: You must set a uniqueId to use the autosave feature");&#13;
			return;&#13;
		}&#13;
&#13;
		if(simplemde.element.form != null &amp;&amp; simplemde.element.form != undefined) {&#13;
			simplemde.element.form.addEventListener("submit", function() {&#13;
				localStorage.removeItem("smde_" + simplemde.options.autosave.uniqueId);&#13;
			});&#13;
		}&#13;
&#13;
		if(this.options.autosave.loaded !== true) {&#13;
			if(typeof localStorage.getItem("smde_" + this.options.autosave.uniqueId) == "string" &amp;&amp; localStorage.getItem("smde_" + this.options.autosave.uniqueId) != "") {&#13;
				this.codemirror.setValue(localStorage.getItem("smde_" + this.options.autosave.uniqueId));&#13;
				this.options.autosave.foundSavedValue = true;&#13;
			}&#13;
&#13;
			this.options.autosave.loaded = true;&#13;
		}&#13;
&#13;
		localStorage.setItem("smde_" + this.options.autosave.uniqueId, simplemde.value());&#13;
&#13;
		var el = document.getElementById("autosaved");&#13;
		if(el != null &amp;&amp; el != undefined &amp;&amp; el != "") {&#13;
			var d = new Date();&#13;
			var hh = d.getHours();&#13;
			var m = d.getMinutes();&#13;
			var dd = "am";&#13;
			var h = hh;&#13;
			if(h &gt;= 12) {&#13;
				h = hh - 12;&#13;
				dd = "pm";&#13;
			}&#13;
			if(h == 0) {&#13;
				h = 12;&#13;
			}&#13;
			m = m &lt; 10 ? "0" + m : m;&#13;
&#13;
			el.innerHTML = "Autosaved: " + h + ":" + m + " " + dd;&#13;
		}&#13;
&#13;
		this.autosaveTimeoutId = setTimeout(function() {&#13;
			simplemde.autosave();&#13;
		}, this.options.autosave.delay || 10000);&#13;
	} else {&#13;
		console.log("SimpleMDE: localStorage not available, cannot autosave");&#13;
	}&#13;
};&#13;
&#13;
SimpleMDE.prototype.clearAutosavedValue = function() {&#13;
	if(isLocalStorageAvailable()) {&#13;
		if(this.options.autosave == undefined || this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == "") {&#13;
			console.log("SimpleMDE: You must set a uniqueId to clear the autosave value");&#13;
			return;&#13;
		}&#13;
&#13;
		localStorage.removeItem("smde_" + this.options.autosave.uniqueId);&#13;
	} else {&#13;
		console.log("SimpleMDE: localStorage not available, cannot autosave");&#13;
	}&#13;
};&#13;
&#13;
SimpleMDE.prototype.createSideBySide = function() {&#13;
	var cm = this.codemirror;&#13;
	var wrapper = cm.getWrapperElement();&#13;
	var preview = wrapper.nextSibling;&#13;
&#13;
	if(!preview || !/editor-preview-side/.test(preview.className)) {&#13;
		preview = document.createElement("div");&#13;
		preview.className = "editor-preview-side";&#13;
		wrapper.parentNode.insertBefore(preview, wrapper.nextSibling);&#13;
	}&#13;
&#13;
	// Syncs scroll  editor -&gt; preview&#13;
	var cScroll = false;&#13;
	var pScroll = false;&#13;
	cm.on("scroll", function(v) {&#13;
		if(cScroll) {&#13;
			cScroll = false;&#13;
			return;&#13;
		}&#13;
		pScroll = true;&#13;
		var height = v.getScrollInfo().height - v.getScrollInfo().clientHeight;&#13;
		var ratio = parseFloat(v.getScrollInfo().top) / height;&#13;
		var move = (preview.scrollHeight - preview.clientHeight) * ratio;&#13;
		preview.scrollTop = move;&#13;
	});&#13;
&#13;
	// Syncs scroll  preview -&gt; editor&#13;
	preview.onscroll = function() {&#13;
		if(pScroll) {&#13;
			pScroll = false;&#13;
			return;&#13;
		}&#13;
		cScroll = true;&#13;
		var height = preview.scrollHeight - preview.clientHeight;&#13;
		var ratio = parseFloat(preview.scrollTop) / height;&#13;
		var move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;&#13;
		cm.scrollTo(0, move);&#13;
	};&#13;
	return preview;&#13;
};&#13;
&#13;
SimpleMDE.prototype.createToolbar = function(items) {&#13;
	items = items || this.options.toolbar;&#13;
&#13;
	if(!items || items.length === 0) {&#13;
		return;&#13;
	}&#13;
	var i;&#13;
	for(i = 0; i &lt; items.length; i++) {&#13;
		if(toolbarBuiltInButtons[items[i]] != undefined) {&#13;
			items[i] = toolbarBuiltInButtons[items[i]];&#13;
		}&#13;
	}&#13;
&#13;
	var bar = document.createElement("div");&#13;
	bar.className = "editor-toolbar";&#13;
&#13;
	var self = this;&#13;
&#13;
	var toolbarData = {};&#13;
	self.toolbar = items;&#13;
&#13;
	for(i = 0; i &lt; items.length; i++) {&#13;
		if(items[i].name == "guide" &amp;&amp; self.options.toolbarGuideIcon === false)&#13;
			continue;&#13;
&#13;
		if(self.options.hideIcons &amp;&amp; self.options.hideIcons.indexOf(items[i].name) != -1)&#13;
			continue;&#13;
&#13;
		// Fullscreen does not work well on mobile devices (even tablets)&#13;
		// In the future, hopefully this can be resolved&#13;
		if((items[i].name == "fullscreen" || items[i].name == "side-by-side") &amp;&amp; isMobile())&#13;
			continue;&#13;
&#13;
&#13;
		// Don't include trailing separators&#13;
		if(items[i] === "|") {&#13;
			var nonSeparatorIconsFollow = false;&#13;
&#13;
			for(var x = (i + 1); x &lt; items.length; x++) {&#13;
				if(items[x] !== "|" &amp;&amp; (!self.options.hideIcons || self.options.hideIcons.indexOf(items[x].name) == -1)) {&#13;
					nonSeparatorIconsFollow = true;&#13;
				}&#13;
			}&#13;
&#13;
			if(!nonSeparatorIconsFollow)&#13;
				continue;&#13;
		}&#13;
&#13;
&#13;
		// Create the icon and append to the toolbar&#13;
		(function(item) {&#13;
			var el;&#13;
			if(item === "|") {&#13;
				el = createSep();&#13;
			} else {&#13;
				el = createIcon(item, self.options.toolbarTips, self.options.shortcuts);&#13;
			}&#13;
&#13;
			// bind events, special for info&#13;
			if(item.action) {&#13;
				if(typeof item.action === "function") {&#13;
					el.onclick = function(e) {&#13;
						e.preventDefault();&#13;
						item.action(self);&#13;
					};&#13;
				} else if(typeof item.action === "string") {&#13;
					el.href = item.action;&#13;
					el.target = "_blank";&#13;
				}&#13;
			}&#13;
&#13;
			toolbarData[item.name || item] = el;&#13;
			bar.appendChild(el);&#13;
		})(items[i]);&#13;
	}&#13;
&#13;
	self.toolbarElements = toolbarData;&#13;
&#13;
	var cm = this.codemirror;&#13;
	cm.on("cursorActivity", function() {&#13;
		var stat = getState(cm);&#13;
&#13;
		for(var key in toolbarData) {&#13;
			(function(key) {&#13;
				var el = toolbarData[key];&#13;
				if(stat[key]) {&#13;
					el.className += " active";&#13;
				} else if(key != "fullscreen" &amp;&amp; key != "side-by-side") {&#13;
					el.className = el.className.replace(/\s*active\s*/g, "");&#13;
				}&#13;
			})(key);&#13;
		}&#13;
	});&#13;
&#13;
	var cmWrapper = cm.getWrapperElement();&#13;
	cmWrapper.parentNode.insertBefore(bar, cmWrapper);&#13;
	return bar;&#13;
};&#13;
&#13;
SimpleMDE.prototype.createStatusbar = function(status) {&#13;
	// Initialize&#13;
	status = status || this.options.status;&#13;
	var options = this.options;&#13;
	var cm = this.codemirror;&#13;
&#13;
&#13;
	// Make sure the status variable is valid&#13;
	if(!status || status.length === 0)&#13;
		return;&#13;
&#13;
&#13;
	// Set up the built-in items&#13;
	var items = [];&#13;
	var i, onUpdate, defaultValue;&#13;
&#13;
	for(i = 0; i &lt; status.length; i++) {&#13;
		// Reset some values&#13;
		onUpdate = undefined;&#13;
		defaultValue = undefined;&#13;
&#13;
&#13;
		// Handle if custom or not&#13;
		if(typeof status[i] === "object") {&#13;
			items.push({&#13;
				className: status[i].className,&#13;
				defaultValue: status[i].defaultValue,&#13;
				onUpdate: status[i].onUpdate&#13;
			});&#13;
		} else {&#13;
			var name = status[i];&#13;
&#13;
			if(name === "words") {&#13;
				defaultValue = function(el) {&#13;
					el.innerHTML = wordCount(cm.getValue());&#13;
				};&#13;
				onUpdate = function(el) {&#13;
					el.innerHTML = wordCount(cm.getValue());&#13;
				};&#13;
			} else if(name === "lines") {&#13;
				defaultValue = function(el) {&#13;
					el.innerHTML = cm.lineCount();&#13;
				};&#13;
				onUpdate = function(el) {&#13;
					el.innerHTML = cm.lineCount();&#13;
				};&#13;
			} else if(name === "cursor") {&#13;
				defaultValue = function(el) {&#13;
					el.innerHTML = "0:0";&#13;
				};&#13;
				onUpdate = function(el) {&#13;
					var pos = cm.getCursor();&#13;
					el.innerHTML = pos.line + ":" + pos.ch;&#13;
				};&#13;
			} else if(name === "autosave") {&#13;
				defaultValue = function(el) {&#13;
					if(options.autosave != undefined &amp;&amp; options.autosave.enabled === true) {&#13;
						el.setAttribute("id", "autosaved");&#13;
					}&#13;
				};&#13;
			}&#13;
&#13;
			items.push({&#13;
				className: name,&#13;
				defaultValue: defaultValue,&#13;
				onUpdate: onUpdate&#13;
			});&#13;
		}&#13;
	}&#13;
&#13;
&#13;
	// Create element for the status bar&#13;
	var bar = document.createElement("div");&#13;
	bar.className = "editor-statusbar";&#13;
&#13;
&#13;
	// Create a new span for each item&#13;
	for(i = 0; i &lt; items.length; i++) {&#13;
		// Store in temporary variable&#13;
		var item = items[i];&#13;
&#13;
&#13;
		// Create span element&#13;
		var el = document.createElement("span");&#13;
		el.className = item.className;&#13;
&#13;
&#13;
		// Ensure the defaultValue is a function&#13;
		if(typeof item.defaultValue === "function") {&#13;
			item.defaultValue(el);&#13;
		}&#13;
&#13;
&#13;
		// Ensure the onUpdate is a function&#13;
		if(typeof item.onUpdate === "function") {&#13;
			// Create a closure around the span of the current action, then execute the onUpdate handler&#13;
			this.codemirror.on("update", (function(el, item) {&#13;
				return function() {&#13;
					item.onUpdate(el);&#13;
				};&#13;
			}(el, item)));&#13;
		}&#13;
&#13;
&#13;
		// Append the item to the status bar&#13;
		bar.appendChild(el);&#13;
	}&#13;
&#13;
&#13;
	// Insert the status bar into the DOM&#13;
	var cmWrapper = this.codemirror.getWrapperElement();&#13;
	cmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);&#13;
	return bar;&#13;
};&#13;
&#13;
/**&#13;
 * Get or set the text content.&#13;
 */&#13;
SimpleMDE.prototype.value = function(val) {&#13;
	if(val === undefined) {&#13;
		return this.codemirror.getValue();&#13;
	} else {&#13;
		this.codemirror.getDoc().setValue(val);&#13;
		return this;&#13;
	}&#13;
};&#13;
&#13;
&#13;
/**&#13;
 * Bind static methods for exports.&#13;
 */&#13;
SimpleMDE.toggleBold = toggleBold;&#13;
SimpleMDE.toggleItalic = toggleItalic;&#13;
SimpleMDE.toggleStrikethrough = toggleStrikethrough;&#13;
SimpleMDE.toggleBlockquote = toggleBlockquote;&#13;
SimpleMDE.toggleHeadingSmaller = toggleHeadingSmaller;&#13;
SimpleMDE.toggleHeadingBigger = toggleHeadingBigger;&#13;
SimpleMDE.toggleHeading1 = toggleHeading1;&#13;
SimpleMDE.toggleHeading2 = toggleHeading2;&#13;
SimpleMDE.toggleHeading3 = toggleHeading3;&#13;
SimpleMDE.toggleCodeBlock = toggleCodeBlock;&#13;
SimpleMDE.toggleUnorderedList = toggleUnorderedList;&#13;
SimpleMDE.toggleOrderedList = toggleOrderedList;&#13;
SimpleMDE.cleanBlock = cleanBlock;&#13;
SimpleMDE.drawLink = drawLink;&#13;
SimpleMDE.drawImage = drawImage;&#13;
SimpleMDE.drawTable = drawTable;&#13;
SimpleMDE.drawHorizontalRule = drawHorizontalRule;&#13;
SimpleMDE.undo = undo;&#13;
SimpleMDE.redo = redo;&#13;
SimpleMDE.togglePreview = togglePreview;&#13;
SimpleMDE.toggleSideBySide = toggleSideBySide;&#13;
SimpleMDE.toggleFullScreen = toggleFullScreen;&#13;
&#13;
/**&#13;
 * Bind instance methods for exports.&#13;
 */&#13;
SimpleMDE.prototype.toggleBold = function() {&#13;
	toggleBold(this);&#13;
};&#13;
SimpleMDE.prototype.toggleItalic = function() {&#13;
	toggleItalic(this);&#13;
};&#13;
SimpleMDE.prototype.toggleStrikethrough = function() {&#13;
	toggleStrikethrough(this);&#13;
};&#13;
SimpleMDE.prototype.toggleBlockquote = function() {&#13;
	toggleBlockquote(this);&#13;
};&#13;
SimpleMDE.prototype.toggleHeadingSmaller = function() {&#13;
	toggleHeadingSmaller(this);&#13;
};&#13;
SimpleMDE.prototype.toggleHeadingBigger = function() {&#13;
	toggleHeadingBigger(this);&#13;
};&#13;
SimpleMDE.prototype.toggleHeading1 = function() {&#13;
	toggleHeading1(this);&#13;
};&#13;
SimpleMDE.prototype.toggleHeading2 = function() {&#13;
	toggleHeading2(this);&#13;
};&#13;
SimpleMDE.prototype.toggleHeading3 = function() {&#13;
	toggleHeading3(this);&#13;
};&#13;
SimpleMDE.prototype.toggleCodeBlock = function() {&#13;
	toggleCodeBlock(this);&#13;
};&#13;
SimpleMDE.prototype.toggleUnorderedList = function() {&#13;
	toggleUnorderedList(this);&#13;
};&#13;
SimpleMDE.prototype.toggleOrderedList = function() {&#13;
	toggleOrderedList(this);&#13;
};&#13;
SimpleMDE.prototype.cleanBlock = function() {&#13;
	cleanBlock(this);&#13;
};&#13;
SimpleMDE.prototype.drawLink = function() {&#13;
	drawLink(this);&#13;
};&#13;
SimpleMDE.prototype.drawImage = function() {&#13;
	drawImage(this);&#13;
};&#13;
SimpleMDE.prototype.drawTable = function() {&#13;
	drawTable(this);&#13;
};&#13;
SimpleMDE.prototype.drawHorizontalRule = function() {&#13;
	drawHorizontalRule(this);&#13;
};&#13;
SimpleMDE.prototype.undo = function() {&#13;
	undo(this);&#13;
};&#13;
SimpleMDE.prototype.redo = function() {&#13;
	redo(this);&#13;
};&#13;
SimpleMDE.prototype.togglePreview = function() {&#13;
	togglePreview(this);&#13;
};&#13;
SimpleMDE.prototype.toggleSideBySide = function() {&#13;
	toggleSideBySide(this);&#13;
};&#13;
SimpleMDE.prototype.toggleFullScreen = function() {&#13;
	toggleFullScreen(this);&#13;
};&#13;
&#13;
SimpleMDE.prototype.isPreviewActive = function() {&#13;
	var cm = this.codemirror;&#13;
	var wrapper = cm.getWrapperElement();&#13;
	var preview = wrapper.lastChild;&#13;
&#13;
	return /editor-preview-active/.test(preview.className);&#13;
};&#13;
&#13;
SimpleMDE.prototype.isSideBySideActive = function() {&#13;
	var cm = this.codemirror;&#13;
	var wrapper = cm.getWrapperElement();&#13;
	var preview = wrapper.nextSibling;&#13;
&#13;
	return /editor-preview-active-side/.test(preview.className);&#13;
};&#13;
&#13;
SimpleMDE.prototype.isFullscreenActive = function() {&#13;
	var cm = this.codemirror;&#13;
&#13;
	return cm.getOption("fullScreen");&#13;
};&#13;
&#13;
SimpleMDE.prototype.getState = function() {&#13;
	var cm = this.codemirror;&#13;
&#13;
	return getState(cm);&#13;
};&#13;
&#13;
SimpleMDE.prototype.toTextArea = function() {&#13;
	var cm = this.codemirror;&#13;
	var wrapper = cm.getWrapperElement();&#13;
&#13;
	if(wrapper.parentNode) {&#13;
		if(this.gui.toolbar) {&#13;
			wrapper.parentNode.removeChild(this.gui.toolbar);&#13;
		}&#13;
		if(this.gui.statusbar) {&#13;
			wrapper.parentNode.removeChild(this.gui.statusbar);&#13;
		}&#13;
		if(this.gui.sideBySide) {&#13;
			wrapper.parentNode.removeChild(this.gui.sideBySide);&#13;
		}&#13;
	}&#13;
&#13;
	cm.toTextArea();&#13;
&#13;
	if(this.autosaveTimeoutId) {&#13;
		clearTimeout(this.autosaveTimeoutId);&#13;
		this.autosaveTimeoutId = undefined;&#13;
		this.clearAutosavedValue();&#13;
	}&#13;
};&#13;
&#13;
module.exports = SimpleMDE;&#13;
},{"./codemirror/tablist":19,"codemirror":10,"codemirror-spell-checker":4,"codemirror/addon/display/fullscreen.js":5,"codemirror/addon/display/placeholder.js":6,"codemirror/addon/edit/continuelist.js":7,"codemirror/addon/mode/overlay.js":8,"codemirror/addon/selection/mark-selection.js":9,"codemirror/mode/gfm/gfm.js":11,"codemirror/mode/markdown/markdown.js":12,"codemirror/mode/xml/xml.js":14,"marked":17}]},{},[20])(20)&#13;
});</script>
        <script_name>simplemde_min</script_name>
        <sys_class_name>sys_ui_script</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2018-11-07 00:11:56</sys_created_on>
        <sys_id>d4a82cfe4fed2300ecf18c318110c7dd</sys_id>
        <sys_mod_count>8</sys_mod_count>
        <sys_name>x_58056_md_docs.simplemde_min</sys_name>
        <sys_package display_value="Markdown Documents" source="x_58056_md_docs">7ac0b5344f212300ecf18c318110c745</sys_package>
        <sys_policy/>
        <sys_scope display_value="Markdown Documents">7ac0b5344f212300ecf18c318110c745</sys_scope>
        <sys_update_name>sys_ui_script_d4a82cfe4fed2300ecf18c318110c7dd</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2019-05-16 00:20:24</sys_updated_on>
        <ui_type>0</ui_type>
        <use_scoped_format>false</use_scoped_format>
    </sys_ui_script>
</record_update>
