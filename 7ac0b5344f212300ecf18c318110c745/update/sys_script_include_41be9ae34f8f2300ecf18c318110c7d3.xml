<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_58056_md_docs.SourceDocumenter</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>SourceDocumenter</name>
        <script><![CDATA[/*
var gr = new GlideRecord('x_58056_md_docs_markdown_document');
if (gr.get("d0df1e1a4f612300ecf18c318110c73f")) {
  new SourceDocumenter().getSourceMarkdown(gr);
}
*/

var SourceDocumenter = Class.create();

SourceDocumenter.DEBUG = true;

SourceDocumenter.prototype = {
    initialize: function() {
        this.classRegex = /Class./;
        this.functionRegex = / function */;
        this.prototypeRegex = /.prototype/;
        this.returnRegex = /return/;
        this.scriptIncludeRegex = /.*Class..*|.* function *\(.*|.*.prototype.*|.*return.*/gm;
        this.markdown = [];
        this.nodes = [];
        this.typeKeys = {
            AssignmentExpression: ["left", "right"],
            AssignmentPattern: ["left", "right"],
            ArrayExpression: ["elements"],
            ArrayPattern: ["elements"],
            ArrowFunctionExpression: ["params", "body"],
            AwaitExpression: ["argument"], // CAUTION: It's deferred to ES7.
            BlockStatement: ["body"],
            BinaryExpression: ["left", "right"],
            BreakStatement: ["label"],
            CallExpression: ["callee", "arguments"],
            CatchClause: ["param", "body"],
            ClassBody: ["body"],
            ClassDeclaration: ["id", "superClass", "body"],
            ClassExpression: ["id", "superClass", "body"],
            ComprehensionBlock: ["left", "right"], // CAUTION: It's deferred to ES7.
            ComprehensionExpression: ["blocks", "filter", "body"], // CAUTION: It's deferred to ES7.
            ConditionalExpression: ["test", "consequent", "alternate"],
            ContinueStatement: ["label"],
            DebuggerStatement: [],
            DirectiveStatement: [],
            DoWhileStatement: ["body", "test"],
            EmptyStatement: [],
            ExportAllDeclaration: ["source"],
            ExportDefaultDeclaration: ["declaration"],
            ExportNamedDeclaration: ["declaration", "specifiers", "source"],
            ExportSpecifier: ["exported", "local"],
            ExpressionStatement: ["expression"],
            ForStatement: ["init", "test", "update", "body"],
            ForInStatement: ["left", "right", "body"],
            ForOfStatement: ["left", "right", "body"],
            FunctionDeclaration: ["id", "params", "body"],
            FunctionExpression: ["id", "params", "body"],
            GeneratorExpression: ["blocks", "filter", "body"], // CAUTION: It's deferred to ES7.
            Identifier: [],
            IfStatement: ["test", "consequent", "alternate"],
            ImportDeclaration: ["specifiers", "source"],
            ImportDefaultSpecifier: ["local"],
            ImportNamespaceSpecifier: ["local"],
            ImportSpecifier: ["imported", "local"],
            Literal: [],
            LabeledStatement: ["label", "body"],
            LogicalExpression: ["left", "right"],
            MemberExpression: ["object", "property"],
            MetaProperty: ["meta", "property"],
            MethodDefinition: ["key", "value"],
            ModuleSpecifier: [],
            NewExpression: ["callee", "arguments"],
            ObjectExpression: ["properties"],
            ObjectPattern: ["properties"],
            Program: ["body"],
            Property: ["key", "value"],
            RestElement: ["argument"],
            ReturnStatement: ["argument"],
            SequenceExpression: ["expressions"],
            SpreadElement: ["argument"],
            Super: [],
            SwitchStatement: ["discriminant", "cases"],
            SwitchCase: ["test", "consequent"],
            TaggedTemplateExpression: ["tag", "quasi"],
            TemplateElement: [],
            TemplateLiteral: ["quasis", "expressions"],
            ThisExpression: [],
            ThrowStatement: ["argument"],
            TryStatement: ["block", "handler", "finalizer"],
            UnaryExpression: ["argument"],
            UpdateExpression: ["argument"],
            VariableDeclaration: ["declarations"],
            VariableDeclarator: ["id", "init"],
            WhileStatement: ["test", "body"],
            WithStatement: ["object", "body"],
            YieldExpression: ["argument"]
        };
    },

    getSourceMarkdown: function(docGR) {
        var sourceAST = this.getSourceAST(docGR.getUniqueValue());
        this.markdown.push("# " + docGR.short_description);
        this.markdown.push(" ");
        sourceAST.forEach(this.convertASTToMarkdown, this);
        this._logDebug(this.markdown);
    },

    convertASTToMarkdown: function(doc) {
        this.markdown.push("## " + doc.label + ": " + doc.name);
        this.markdown.push(" ");
        if (!gs.nil(doc.description.trim())) {
            this.markdown.push(doc.description.trim());
        }
        var AST = JSON.parse(doc.AST);
        if (AST.type in this.typeKeys) {
            for (var i = 0; i < this.typeKeys[AST.type].length; i++) {
                var typeKey = this.typeKeys[AST.type];
                this._traverseNode(AST[typeKey]);
            }
        } else {
            this._logError("Unknown type found in AST for " + doc.label + " " + doc.name);
        }
    },

    _traverseNode: function(obj) {
        var nodeArray = this._makeArray(obj);
        if (Array.isArray(obj)) {
            nodeArray = obj;
        } else {
            nodeArray.push(obj);
        }
        for (var i = 0; i < nodeArray.length; i++) {
            this._handleNode(nodeArray[i]);
        }
    },

    _handleNode: function(node) {
        var typeKeys, typeKey;
        switch (node.type) {
            case "VariableDeclaration":
                typeKeys = this.typeKeys.VariableDeclaration;
                typeKey = typeKeys[0];
                this._variableDeclaration(node[typeKey]);
                break;
            case "ExpressionStatement":
                typeKeys = this.typeKeys.ExpressionStatement;
                typeKey = typeKeys[0];
                this._expressionStatement(node[typeKey]);
                break;
            case "ObjectExpression":
                typeKeys = this.typeKeys.ObjectExpression;
                typeKey = typeKeys[0];
                this._objectExpression(node[typeKey]);
                break;
            default:
                this._logError("Unknown node type " + node.type);
        }
    },

    _variableDeclaration: function(declarations) {
        var declArray = this._makeArray(declarations);
        for (var i = 0; i < declArray.length; i++) {
            var declaration = declArray[i];
            if (declaration.type == "VariableDeclarator") {
                if (
                    declaration.init.type == "CallExpression" &&
                    declaration.init.callee.object.name == "Class" &&
                    declaration.init.callee.property.name == "create"
                ) {
                    continue;
                }
                var varName = declaration.id.name;
                this.markdown.push("### Property: " + varName);
                this.markdown.push(" ");
            } else {
                this._logError("Unknown declaration type " + declaration.type);
            }
        }
    },

    _makeArray: function(obj) {
        var newArray = [];
        if (Array.isArray(obj)) {
            newArray = obj;
        } else {
            newArray.push(obj);
        }
        return newArray;
    },

    _expressionStatement: function(expression) {
        if (
            expression.type == "AssignmentExpression" &&
            expression.left.type == "MemberExpression"
        ) {
            if (expression.left.property.name == "prototype") {
                // This is the object prototype declaration
                return this._handleNode(expression.right);
            } else {
                var varName = expression.left.object.name + "." + expression.left.property.name;
                var type = "Property";
                if (expression.right.type == "FunctionExpression") {
                    type = "Function";
					this._getFunctionParams(expression.right.params);
					this._getReturns(expression.right.body);
                }
                this.markdown.push("### " + type + ": " + varName);
                this.markdown.push(" ");
            }
        }
    },

    _objectExpression: function(properties) {
		var propArray = this._makeArray(properties);
        for (var i = 0; i < propArray.length; i++) {
            if ((propArray[i].type = "Property")) {
                this._handleProperty(propArray[i]);
            } else {
                gs._logError("Unknown properties type " + propArray[i].type);
            }
        }
    },

    _handleProperty: function(property) {
        var propName = property.key.name;
        if (property.value.name == "Literal") {
            this.markdown.push("### Property " + propName);
            this.markdown.push(" ");
            return;
        }
        if (property.value.name == "FunctionExpression") {
            this.markdown.push("### Function " + propName);
			this.markdown.push(" ");
			this._getFunctionParams(property.value.params);
            this._getReturns(property.value.body);
            return;
        }
    },

    _getReturns: function(functionBody) {
    },

    _getFunctionParams: function(params) {
		if (params.length > 0) {
			this.markdown.push("#### Parameters");
			params.forEach(function(param) {
				this.markdown.push("- " + param.name);
			}, this);
			this.markdown.push(" ");
		}
    },

    parseSources: function(docGR) {
        var md = [];
        var sources = this.getSources(docGR.getUniqueValue());
        md.push("# " + docGR.short_description);
        sources.forEach(function(source) {
            md.push("## " + source.className);
            md.push("### Properties");
            source.properties.forEach(function(prop) {
                md.push("#### " + prop);
            }, this);
            source.functions.forEach(function(func) {
                md.push("### " + func.name);
                if (func.parameters.length > 0) {
                    md.push("#### Parameters");
                    func.parameters.forEach(function(parm) {
                        md.push("* " + parm);
                    });
                }
                if (func.returns.length > 0) {
                    md.push("#### Returns " + func.returns);
                }
            }, this);
        }, this);
        return md.join("\n");
    },

    getSourceAST: function(docID) {
        var sourceAST = [];

        var sourceGR = new GlideRecord("x_58056_md_docs_markdown_source");
        sourceGR.addQuery("markdown_document", docID);
        sourceGR.orderBy("order");
        sourceGR.query();
        while (sourceGR.next()) {
            var doc = this._getDocRecord(
                sourceGR.source_table.toString(),
                sourceGR.source_id.toString()
            );
            doc.AST = sourceGR.abstract_syntax_tree.toString();
            sourceAST.push(doc);
        }
        return sourceAST;
    },

    _getDocRecord: function(table, sysID) {
        var doc = { label: "", name: "", description: "", table: table, sys_id: sysID };
        var docGR = new GlideRecord(table);
        if (docGR.get(sysID)) {
            doc.label = docGR.getLabel();
            doc.name = docGR.name.toString();
            if (docGR.isValidField("description")) {
                doc.description = docGR.description.toString();
            }
        }
        return doc;
    },

    getSources: function(docID) {
        var sources = [];

        var sourceGR = new GlideRecord("x_58056_md_docs_markdown_source");
        sourceGR.addQuery("markdown_document", docID);
        sourceGR.orderBy("order");
        sourceGR.query();
        while (sourceGR.next()) {
            sources.push(
                this.getSourceStatements(
                    sourceGR.source_table.toString(),
                    sourceGR.source_id.toString()
                )
            );
        }
        return sources;
    },

    getSourceStatements: function(table, sourceID) {
        var m, m2, result;
        var sourceLines = {
            name: "",
            table: table,
            sys_id: sourceID,
            className: "",
            properties: [],
            functions: []
        };
        var tgtGR = new GlideRecord(table);
        if (tgtGR.get(sourceID)) {
            gs.info("table=" + tgtGR.getRecordClassName());
            if (tgtGR.getRecordClassName() == "sys_script_include") {
                sourceLines.className = tgtGR.name.toString();
                var str = tgtGR.script.toString();
                var currFunction = null;
                while ((m = this.scriptIncludeRegex.exec(str)) !== null) {
                    // This is necessary to avoid infinite loops with zero-width matches
                    if (m.index === this.scriptIncludeRegex.lastIndex) {
                        regex.lastIndex++;
                    }
                    // The result can be accessed through the `m`-variable.
                    m.forEach(function(sourceLine, groupIndex) {
                        gs.info("function regex=" + this.functionRegex);
                        gs.info(
                            "match=" +
                                sourceLine +
                                " is function stmt=" +
                                sourceLine.search(this.functionRegex)
                        );
                        if (sourceLine.search(this.functionRegex) >= 0) {
                            if (currFunction !== null) {
                                gs.info(
                                    "Adding new function due to new function being found=" +
                                        currFunction.name
                                );
                                sourceLines.functions.push(currFunction);
                            }
                            currFunction = { name: "", parameters: [], returns: [] };
                            result = sourceLine.match(/^[^:]+/);
                            currFunction.name = result[0].trim();
                            result = sourceLine.match(/\((.*?)\)/);
                            var parms = result[1].split(",");
                            parms.forEach(function(parm) {
                                parm = parm.trim();
                                if (parm) {
                                    currFunction.parameters.push(parm);
                                }
                            }, this);
                            gs.info("Setting current function name=" + currFunction.name);
                        } else if (sourceLine.search(this.returnRegex) >= 0) {
                            result = sourceLine.match(/return(.*)/);
                            currFunction.returns.push(result[1].trim());
                            gs.info(
                                "Setting return value = " +
                                    currFunction.returns[currFunction.returns.length - 1]
                            );
                        } else if (sourceLine.search(this.prototypeRegex) >= 0) {
                        }
                    }, this);
                }
                if (currFunction !== null) {
                    gs.info("Adding new function due to end of script=" + currFunction.name);
                    sourceLines.functions.push(currFunction);
                }
            }
        }
        return sourceLines;
    },

    /**
     * Creates an informational message in the system log if debugging is turned on
     *
     * @param {string} msg
     */
    _logDebug: function(msg) {
        if (SourceDocumenter.DEBUG) {
            gs.info("[{0}] " + msg, this.type);
        }
    },

    /**
     * Creates an informational message in the system log
     *
     * @param {string} msg
     */
    _logInfo: function(msg) {
        gs.info("[{0}] " + msg, this.type);
    },

    /**
     * Creates an error message in the system log
     *
     * @param {string} msg
     */
    _logWarning: function(msg) {
        gs.warning("[{0}] " + msg, this.type);
    },

    /**
     * Creates an error message in the system log
     *
     * @param {string} msg
     */
    _logError: function(msg) {
        gs.error("[{0}] " + msg, this.type);
    },

    type: "SourceDocumenter"
};
]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2019-01-23 06:16:52</sys_created_on>
        <sys_id>41be9ae34f8f2300ecf18c318110c7d3</sys_id>
        <sys_mod_count>9</sys_mod_count>
        <sys_name>SourceDocumenter</sys_name>
        <sys_package display_value="Markdown Documents" source="x_58056_md_docs">7ac0b5344f212300ecf18c318110c745</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Markdown Documents">7ac0b5344f212300ecf18c318110c745</sys_scope>
        <sys_update_name>sys_script_include_41be9ae34f8f2300ecf18c318110c7d3</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2019-01-23 07:07:19</sys_updated_on>
    </sys_script_include>
</record_update>
